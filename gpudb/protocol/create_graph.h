/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
#ifndef __CREATE_GRAPH_H__
#define __CREATE_GRAPH_H__

namespace gpudb
{

    /**
     * A set of input parameters for {@link
     * #createGraph(const CreateGraphRequest&) const}.
     * <p>
     * Creates a new graph network using given nodes, edges, weights, and
     * restrictions.

     * IMPORTANT: It's highly recommended that you review the
     * <a href="../../../graph_solver/network_graph_solver/"
     * target="_top">Network Graphs & Solvers</a>
     * concepts documentation, the
     * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
     * Tutorial</a>,
     * and/or some <a href="../../../guide-tags/graph/" target="_top">graph
     * examples</a> before
     * using this endpoint.
     */
    struct CreateGraphRequest
    {

        /**
         * Constructs a CreateGraphRequest object with default parameter
         * values.
         */
        CreateGraphRequest() :
            graphName(std::string()),
            directedGraph(bool()),
            nodes(std::vector<std::string>()),
            edges(std::vector<std::string>()),
            weights(std::vector<std::string>()),
            restrictions(std::vector<std::string>()),
            options(std::map<std::string, std::string>())
        {
        }

        /**
         * Constructs a CreateGraphRequest object with the specified
         * parameters.
         * 
         * @param[in] graphName_  Name of the graph resource to generate.
         * @param[in] directedGraph_  If set to @a true, the graph will be
         *                            directed. If set to @a false, the graph
         *                            will not be directed. Consult <a
         *                            href="../../../graph_solver/network_graph_solver/#directed-graphs"
         *                            target="_top">Directed Graphs</a> for
         *                            more details.
         *                            <ul>
         *                                    <li> gpudb::create_graph_true
         *                                    <li> gpudb::create_graph_false
         *                            </ul>
         *                            The default value is
         *                            gpudb::create_graph_true.
         * @param[in] nodes_  Nodes represent fundamental topological units of
         *                    a graph.
         *                    Nodes must be specified using
         *                    <a
         *                    href="../../../graph_solver/network_graph_solver/#identifiers"
         *                    target="_top">identifiers</a>;
         *                    identifiers are grouped as
         *                    <a
         *                    href="../../../graph_solver/network_graph_solver/#id-combos"
         *                    target="_top">combinations</a>.
         *                    Identifiers can be used with existing column
         *                    names, e.g.,
         *                    'table.column AS NODE_ID', expressions, e.g.,
         *                    'ST_MAKEPOINT(column1, column2) AS
         *                    NODE_WKTPOINT', or constant values, e.g.,
         *                    '{9, 10, 11} AS NODE_ID'.
         *                    If using constant values in an identifier
         *                    combination, the number of values
         *                    specified must match across the combination.
         * @param[in] edges_  Edges represent the required fundamental
         *                    topological unit of
         *                    a graph that typically connect nodes. Edges must
         *                    be specified using
         *                    <a
         *                    href="../../../graph_solver/network_graph_solver/#identifiers"
         *                    target="_top">identifiers</a>;
         *                    identifiers are grouped as
         *                    <a
         *                    href="../../../graph_solver/network_graph_solver/#id-combos"
         *                    target="_top">combinations</a>.
         *                    Identifiers can be used with existing column
         *                    names, e.g.,
         *                    'table.column AS EDGE_ID', expressions, e.g.,
         *                    'SUBSTR(column, 1, 6) AS EDGE_NODE1_NAME', or
         *                    constant values, e.g.,
         *                    "{'family', 'coworker'} AS EDGE_LABEL".
         *                    If using constant values in an identifier
         *                    combination, the number of values
         *                    specified must match across the combination.
         * @param[in] weights_  Weights represent a method of informing the
         *                      graph solver of
         *                      the cost of including a given edge in a
         *                      solution. Weights must be specified
         *                      using
         *                      <a
         *                      href="../../../graph_solver/network_graph_solver/#identifiers"
         *                      target="_top">identifiers</a>;
         *                      identifiers are grouped as
         *                      <a
         *                      href="../../../graph_solver/network_graph_solver/#id-combos"
         *                      target="_top">combinations</a>.
         *                      Identifiers can be used with existing column
         *                      names, e.g.,
         *                      'table.column AS WEIGHTS_EDGE_ID', expressions,
         *                      e.g.,
         *                      'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED', or
         *                      constant values, e.g.,
         *                      '{4, 15} AS WEIGHTS_VALUESPECIFIED'.
         *                      If using constant values in an identifier
         *                      combination, the number of values specified
         *                      must match across the combination.
         * @param[in] restrictions_  Restrictions represent a method of
         *                           informing the graph
         *                           solver which edges and/or nodes should be
         *                           ignored for the solution. Restrictions
         *                           must be specified using
         *                           <a
         *                           href="../../../graph_solver/network_graph_solver/#identifiers"
         *                           target="_top">identifiers</a>;
         *                           identifiers are grouped as
         *                           <a
         *                           href="../../../graph_solver/network_graph_solver/#id-combos"
         *                           target="_top">combinations</a>.
         *                           Identifiers can be used with existing
         *                           column names, e.g.,
         *                           'table.column AS RESTRICTIONS_EDGE_ID',
         *                           expressions, e.g.,
         *                           'column/2 AS RESTRICTIONS_VALUECOMPARED',
         *                           or constant values, e.g.,
         *                           '{0, 0, 0, 1} AS
         *                           RESTRICTIONS_ONOFFCOMPARED'.
         *                           If using constant values in an identifier
         *                           combination, the number of values
         *                           specified must match across the
         *                           combination.
         * @param[in] options_  Optional parameters.
         *                      <ul>
         *                              <li>
         *                      gpudb::create_graph_merge_tolerance: If node
         *                      geospatial positions are input (e.g., WKTPOINT,
         *                      X, Y), determines the minimum separation
         *                      allowed between unique nodes. If nodes are
         *                      within the tolerance of each other, they will
         *                      be merged as a single node.  The default value
         *                      is '1.0E-5'.
         *                              <li> gpudb::create_graph_recreate: If
         *                      set to @a true and the graph (using @a
         *                      graphName) already exists, the graph is deleted
         *                      and recreated.
         *                      <ul>
         *                              <li> gpudb::create_graph_true
         *                              <li> gpudb::create_graph_false
         *                      </ul>
         *                      The default value is gpudb::create_graph_false.
         *                              <li> gpudb::create_graph_save_persist:
         *                      If set to @a true, the graph will be saved in
         *                      the persist directory (see the <a
         *                      href="../../../config/#config-main-persistence"
         *                      target="_top">config reference</a> for more
         *                      information). If set to @a false, the graph
         *                      will be removed when the graph server is
         *                      shutdown.
         *                      <ul>
         *                              <li> gpudb::create_graph_true
         *                              <li> gpudb::create_graph_false
         *                      </ul>
         *                      The default value is gpudb::create_graph_false.
         *                              <li>
         *                      gpudb::create_graph_add_table_monitor: Adds a
         *                      table monitor to every table used in the
         *                      creation of the graph; this table monitor will
         *                      trigger the graph to update dynamically upon
         *                      inserts to the source table(s). Note that upon
         *                      database restart, if @a save_persist is also
         *                      set to @a true, the graph will be fully
         *                      reconstructed and the table monitors will be
         *                      reattached. For more details on table monitors,
         *                      see /create/tablemonitor.
         *                      <ul>
         *                              <li> gpudb::create_graph_true
         *                              <li> gpudb::create_graph_false
         *                      </ul>
         *                      The default value is gpudb::create_graph_false.
         *                              <li> gpudb::create_graph_graph_table:
         *                      If specified, the created graph is also created
         *                      as a table with the given name, in
         *                      [schema_name.]table_name format, using standard
         *                      <a
         *                      href="../../../concepts/tables/#table-name-resolution"
         *                      target="_top">name resolution rules</a> and
         *                      meeting <a
         *                      href="../../../concepts/tables/#table-naming-criteria"
         *                      target="_top">table naming criteria</a>.  The
         *                      table will have the following identifier
         *                      columns: 'EDGE_ID', 'EDGE_NODE1_ID',
         *                      'EDGE_NODE2_ID'. If left blank, no table is
         *                      created.  The default value is ''.
         *                              <li> gpudb::create_graph_add_turns:
         *                      Adds dummy 'pillowed' edges around intersection
         *                      nodes where there are more than three edges so
         *                      that additional weight penalties can be imposed
         *                      by the solve endpoints. (increases the total
         *                      number of edges).
         *                      <ul>
         *                              <li> gpudb::create_graph_true
         *                              <li> gpudb::create_graph_false
         *                      </ul>
         *                      The default value is gpudb::create_graph_false.
         *                              <li>
         *                      gpudb::create_graph_is_partitioned:
         *                      <ul>
         *                              <li> gpudb::create_graph_true
         *                              <li> gpudb::create_graph_false
         *                      </ul>
         *                      The default value is gpudb::create_graph_false.
         *                              <li> gpudb::create_graph_server_id:
         *                      Indicates which graph server(s) to send the
         *                      request to. Default is to send to the server
         *                      with the most available memory.
         *                              <li> gpudb::create_graph_use_rtree: Use
         *                      an range tree structure to accelerate and
         *                      improve the accuracy of snapping, especially to
         *                      edges.
         *                      <ul>
         *                              <li> gpudb::create_graph_true
         *                              <li> gpudb::create_graph_false
         *                      </ul>
         *                      The default value is gpudb::create_graph_true.
         *                              <li>
         *                      gpudb::create_graph_label_delimiter: If
         *                      provided the label string will be split
         *                      according to this delimiter and each sub-string
         *                      will be applied as a separate label onto the
         *                      specified edge.  The default value is ''.
         *                              <li>
         *                      gpudb::create_graph_allow_multiple_edges:
         *                      Multigraph choice; allowing multiple edges with
         *                      the same node pairs if set to true, otherwise,
         *                      new edges with existing same node pairs will
         *                      not be inserted.
         *                      <ul>
         *                              <li> gpudb::create_graph_true
         *                              <li> gpudb::create_graph_false
         *                      </ul>
         *                      The default value is gpudb::create_graph_true.
         *                      </ul>
         * 
         */
        CreateGraphRequest(const std::string& graphName_, const bool directedGraph_, const std::vector<std::string>& nodes_, const std::vector<std::string>& edges_, const std::vector<std::string>& weights_, const std::vector<std::string>& restrictions_, const std::map<std::string, std::string>& options_):
            graphName( graphName_ ),
            directedGraph( directedGraph_ ),
            nodes( nodes_ ),
            edges( edges_ ),
            weights( weights_ ),
            restrictions( restrictions_ ),
            options( options_ )
        {
        }

        std::string graphName;
        bool directedGraph;
        std::vector<std::string> nodes;
        std::vector<std::string> edges;
        std::vector<std::string> weights;
        std::vector<std::string> restrictions;
        std::map<std::string, std::string> options;
    };
}

namespace avro
{
    template<> struct codec_traits<gpudb::CreateGraphRequest>
    {
        static void encode(Encoder& e, const gpudb::CreateGraphRequest& v)
        {
            ::avro::encode(e, v.graphName);
            ::avro::encode(e, v.directedGraph);
            ::avro::encode(e, v.nodes);
            ::avro::encode(e, v.edges);
            ::avro::encode(e, v.weights);
            ::avro::encode(e, v.restrictions);
            ::avro::encode(e, v.options);
        }

        static void decode(Decoder& d, gpudb::CreateGraphRequest& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.graphName);
                            break;

                        case 1:
                            ::avro::decode(d, v.directedGraph);
                            break;

                        case 2:
                            ::avro::decode(d, v.nodes);
                            break;

                        case 3:
                            ::avro::decode(d, v.edges);
                            break;

                        case 4:
                            ::avro::decode(d, v.weights);
                            break;

                        case 5:
                            ::avro::decode(d, v.restrictions);
                            break;

                        case 6:
                            ::avro::decode(d, v.options);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.graphName);
                ::avro::decode(d, v.directedGraph);
                ::avro::decode(d, v.nodes);
                ::avro::decode(d, v.edges);
                ::avro::decode(d, v.weights);
                ::avro::decode(d, v.restrictions);
                ::avro::decode(d, v.options);
            }
        }
    };
}

namespace gpudb
{

    /**
     * A set of output parameters for {@link
     * #createGraph(const CreateGraphRequest&) const}.
     * <p>
     * Creates a new graph network using given nodes, edges, weights, and
     * restrictions.

     * IMPORTANT: It's highly recommended that you review the
     * <a href="../../../graph_solver/network_graph_solver/"
     * target="_top">Network Graphs & Solvers</a>
     * concepts documentation, the
     * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
     * Tutorial</a>,
     * and/or some <a href="../../../guide-tags/graph/" target="_top">graph
     * examples</a> before
     * using this endpoint.
     */
    struct CreateGraphResponse
    {

        /**
         * Constructs a CreateGraphResponse object with default parameter
         * values.
         */
        CreateGraphResponse() :
            result(bool()),
            numNodes(int64_t()),
            numEdges(int64_t()),
            edgesIds(std::vector<int64_t>()),
            info(std::map<std::string, std::string>())
        {
        }

        bool result;
        int64_t numNodes;
        int64_t numEdges;
        std::vector<int64_t> edgesIds;
        std::map<std::string, std::string> info;
    };
}

namespace avro
{
    template<> struct codec_traits<gpudb::CreateGraphResponse>
    {
        static void encode(Encoder& e, const gpudb::CreateGraphResponse& v)
        {
            ::avro::encode(e, v.result);
            ::avro::encode(e, v.numNodes);
            ::avro::encode(e, v.numEdges);
            ::avro::encode(e, v.edgesIds);
            ::avro::encode(e, v.info);
        }

        static void decode(Decoder& d, gpudb::CreateGraphResponse& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.result);
                            break;

                        case 1:
                            ::avro::decode(d, v.numNodes);
                            break;

                        case 2:
                            ::avro::decode(d, v.numEdges);
                            break;

                        case 3:
                            ::avro::decode(d, v.edgesIds);
                            break;

                        case 4:
                            ::avro::decode(d, v.info);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.result);
                ::avro::decode(d, v.numNodes);
                ::avro::decode(d, v.numEdges);
                ::avro::decode(d, v.edgesIds);
                ::avro::decode(d, v.info);
            }
        }
    };
}

#endif
