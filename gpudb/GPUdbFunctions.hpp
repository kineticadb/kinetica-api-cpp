/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */

/**
 * Adds a host to an existing cluster.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminAddHostResponse adminAddHost( const AdminAddHostRequest& request_ ) const;

/**
 * Adds a host to an existing cluster.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminAddHostResponse& adminAddHost( const AdminAddHostRequest& request_,
                                    AdminAddHostResponse& response_ ) const;

/**
 * Adds a host to an existing cluster.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param hostAddress  IP address of the host that will be added to the
 *                     cluster. This host must have installed the same version
 *                     of Kinetica as the cluster to which it is being added.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_add_host_dry_run: If set to @a
 *                 true, only validation checks will be performed. No host is
 *                 added.
 *                 <ul>
 *                         <li> gpudb::admin_add_host_true
 *                         <li> gpudb::admin_add_host_false
 *                 </ul>
 *                 The default value is gpudb::admin_add_host_false.
 *                         <li> gpudb::admin_add_host_accepts_failover: If set
 *                 to @a true, the host will accept processes (ranks, graph
 *                 server, etc.) in the event of a failover on another node in
 *                 the cluster.
 *                 <ul>
 *                         <li> gpudb::admin_add_host_true
 *                         <li> gpudb::admin_add_host_false
 *                 </ul>
 *                 The default value is gpudb::admin_add_host_false.
 *                         <li> gpudb::admin_add_host_public_address: The
 *                 publicly-accessible IP address for the host being added,
 *                 typically specified for clients using multi-head operations.
 *                 This setting is required if any other host(s) in the cluster
 *                 specify a public address.
 *                         <li> gpudb::admin_add_host_host_manager_public_url:
 *                 The publicly-accessible full path URL to the host manager on
 *                 the host being added, e.g., 'http://172.123.45.67:9300'. The
 *                 default host manager port can be found in the <a
 *                 href="../../../install/shared/ports/" target="_top">list of
 *                 ports</a> used by Kinetica.
 *                         <li> gpudb::admin_add_host_ram_limit: The desired
 *                 RAM limit for the host being added, i.e. the sum of RAM
 *                 usage for all processes on the host will not be able to
 *                 exceed this value. Supported units: K (thousand), KB
 *                 (kilobytes), M (million), MB (megabytes), G (billion), GB
 *                 (gigabytes); if no unit is provided, the value is assumed to
 *                 be in bytes. For example, if @a ram_limit is set to 10M, the
 *                 resulting RAM limit is 10 million bytes. Set @a ram_limit to
 *                 -1 to have no RAM limit.
 *                         <li> gpudb::admin_add_host_gpus: Comma-delimited
 *                 list of GPU indices (starting at 1) that are eligible for
 *                 running worker processes. If left blank, all GPUs on the
 *                 host being added will be eligible.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminAddHostResponse adminAddHost( const std::string& hostAddress,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Adds a host to an existing cluster.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param hostAddress  IP address of the host that will be added to the
 *                     cluster. This host must have installed the same version
 *                     of Kinetica as the cluster to which it is being added.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_add_host_dry_run: If set to @a
 *                 true, only validation checks will be performed. No host is
 *                 added.
 *                 <ul>
 *                         <li> gpudb::admin_add_host_true
 *                         <li> gpudb::admin_add_host_false
 *                 </ul>
 *                 The default value is gpudb::admin_add_host_false.
 *                         <li> gpudb::admin_add_host_accepts_failover: If set
 *                 to @a true, the host will accept processes (ranks, graph
 *                 server, etc.) in the event of a failover on another node in
 *                 the cluster.
 *                 <ul>
 *                         <li> gpudb::admin_add_host_true
 *                         <li> gpudb::admin_add_host_false
 *                 </ul>
 *                 The default value is gpudb::admin_add_host_false.
 *                         <li> gpudb::admin_add_host_public_address: The
 *                 publicly-accessible IP address for the host being added,
 *                 typically specified for clients using multi-head operations.
 *                 This setting is required if any other host(s) in the cluster
 *                 specify a public address.
 *                         <li> gpudb::admin_add_host_host_manager_public_url:
 *                 The publicly-accessible full path URL to the host manager on
 *                 the host being added, e.g., 'http://172.123.45.67:9300'. The
 *                 default host manager port can be found in the <a
 *                 href="../../../install/shared/ports/" target="_top">list of
 *                 ports</a> used by Kinetica.
 *                         <li> gpudb::admin_add_host_ram_limit: The desired
 *                 RAM limit for the host being added, i.e. the sum of RAM
 *                 usage for all processes on the host will not be able to
 *                 exceed this value. Supported units: K (thousand), KB
 *                 (kilobytes), M (million), MB (megabytes), G (billion), GB
 *                 (gigabytes); if no unit is provided, the value is assumed to
 *                 be in bytes. For example, if @a ram_limit is set to 10M, the
 *                 resulting RAM limit is 10 million bytes. Set @a ram_limit to
 *                 -1 to have no RAM limit.
 *                         <li> gpudb::admin_add_host_gpus: Comma-delimited
 *                 list of GPU indices (starting at 1) that are eligible for
 *                 running worker processes. If left blank, all GPUs on the
 *                 host being added will be eligible.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminAddHostResponse& adminAddHost( const std::string& hostAddress,
                                    const std::map<std::string, std::string>& options,
                                    AdminAddHostResponse& response_ ) const;

/**
 * Add one or more ranks to an existing Kinetica cluster. The new ranks will
 * not contain any data initially (other than replicated tables) and will not
 * be assigned any shards. To rebalance data and shards across the cluster, use
 * {@link #adminRebalance(const AdminRebalanceRequest&) const}.
 * <p>
 * The database must be offline for this operation, see {@link
 * #adminOffline(const AdminOfflineRequest&) const}
 * <p>
 * For example, if attempting to add three new ranks (two ranks on host
 * 172.123.45.67 and one rank on host 172.123.45.68) to a Kinetica cluster with
 * additional configuration parameters:
 * <p>
 * * @a hosts
 *   would be an array including 172.123.45.67 in the first two indices
 *   (signifying two ranks being added to host 172.123.45.67) and
 *   172.123.45.68 in the last index (signifying one rank being added
 *   to host 172.123.45.67)
 * * @a configParams
 *   would be an array of maps, with each map corresponding to the ranks
 *   being added in @a hosts. The key of each map would be
 *   the configuration parameter name and the value would be the
 *   parameter's value, e.g. '{"rank.gpu":"1"}'
 * <p>
 * This endpoint's processing includes copying all replicated table data to the
 * new rank(s) and therefore could take a long time. The API call may time out
 * if run directly.  It is recommended to run this endpoint asynchronously via
 * {@link #createJob(const CreateJobRequest&) const}.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminAddRanksResponse adminAddRanks( const AdminAddRanksRequest& request_ ) const;

/**
 * Add one or more ranks to an existing Kinetica cluster. The new ranks will
 * not contain any data initially (other than replicated tables) and will not
 * be assigned any shards. To rebalance data and shards across the cluster, use
 * {@link
 * #adminRebalance(const AdminRebalanceRequest&,AdminRebalanceResponse&) const}.
 * <p>
 * The database must be offline for this operation, see {@link
 * #adminOffline(const AdminOfflineRequest&,AdminOfflineResponse&) const}
 * <p>
 * For example, if attempting to add three new ranks (two ranks on host
 * 172.123.45.67 and one rank on host 172.123.45.68) to a Kinetica cluster with
 * additional configuration parameters:
 * <p>
 * * @a hosts
 *   would be an array including 172.123.45.67 in the first two indices
 *   (signifying two ranks being added to host 172.123.45.67) and
 *   172.123.45.68 in the last index (signifying one rank being added
 *   to host 172.123.45.67)
 * * @a configParams
 *   would be an array of maps, with each map corresponding to the ranks
 *   being added in @a hosts. The key of each map would be
 *   the configuration parameter name and the value would be the
 *   parameter's value, e.g. '{"rank.gpu":"1"}'
 * <p>
 * This endpoint's processing includes copying all replicated table data to the
 * new rank(s) and therefore could take a long time. The API call may time out
 * if run directly.  It is recommended to run this endpoint asynchronously via
 * {@link #createJob(const CreateJobRequest&,CreateJobResponse&) const}.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminAddRanksResponse& adminAddRanks( const AdminAddRanksRequest& request_,
                                      AdminAddRanksResponse& response_ ) const;

/**
 * Add one or more ranks to an existing Kinetica cluster. The new ranks will
 * not contain any data initially (other than replicated tables) and will not
 * be assigned any shards. To rebalance data and shards across the cluster, use
 * {@link
 * #adminRebalance(const std::map<std::string, std::string>&) const}.
 * <p>
 * The database must be offline for this operation, see {@link
 * #adminOffline(const bool,const std::map<std::string, std::string>&) const}
 * <p>
 * For example, if attempting to add three new ranks (two ranks on host
 * 172.123.45.67 and one rank on host 172.123.45.68) to a Kinetica cluster with
 * additional configuration parameters:
 * <p>
 * * @a hosts
 *   would be an array including 172.123.45.67 in the first two indices
 *   (signifying two ranks being added to host 172.123.45.67) and
 *   172.123.45.68 in the last index (signifying one rank being added
 *   to host 172.123.45.67)
 * * @a configParams
 *   would be an array of maps, with each map corresponding to the ranks
 *   being added in @a hosts. The key of each map would be
 *   the configuration parameter name and the value would be the
 *   parameter's value, e.g. '{"rank.gpu":"1"}'
 * <p>
 * This endpoint's processing includes copying all replicated table data to the
 * new rank(s) and therefore could take a long time. The API call may time out
 * if run directly.  It is recommended to run this endpoint asynchronously via
 * {@link
 * #createJob(const std::string&,const std::string&,const std::vector<uint8_t>&,const std::string&,const std::map<std::string, std::string>&) const}.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param hosts  Array of host IP addresses (matching a hostN.address from the
 *               gpudb.conf file), or host identifiers (e.g. 'host0' from the
 *               gpudb.conf file), on which to add ranks to the cluster. The
 *               hosts must already be in the cluster. If needed beforehand, to
 *               add a new host to the cluster use /admin/add/host. Include the
 *               same entry as many times as there are ranks to add to the
 *               cluster, e.g., if two ranks on host 172.123.45.67 should be
 *               added, @a hosts could look like '["172.123.45.67",
 *               "172.123.45.67"]'. All ranks will be added simultaneously,
 *               i.e. they're not added in the order of this array. Each entry
 *               in this array corresponds to the entry at the same index in
 *               the @a configParams.
 * @param configParams  Array of maps containing configuration parameters to
 *                      apply to the new ranks
 *                      found in @a hosts. For example,
 *                      '{"rank.gpu":"2",
 *                      "tier.ram.rank.limit":"10000000000"}'. Currently, the
 *                      available parameters
 *                      are rank-specific parameters in the <a
 *                      href="../../../config/#config-main-network"
 *                      target="_top">Network</a>,
 *                      <a href="../../../config/#config-main-hardware"
 *                      target="_top">Hardware</a>,
 *                      <a href="../../../config/#config-main-text-search"
 *                      target="_top">Text Search</a>, and
 *                      <a href="../../../config/#config-main-ram-tier"
 *                      target="_top">RAM Tiered Storage</a> sections in the
 *                      gpudb.conf file, with the
 *                      key exception of the 'rankN.host' settings in the
 *                      Network section that will be determined by
 *                      @a hosts instead. Though many of these configuration
 *                      parameters typically are affixed with
 *                      'rankN' in the gpudb.conf file (where N is the rank
 *                      number), the 'N' should be omitted in
 *                      @a configParams as the new rank number(s) are not
 *                      allocated until the ranks have been added
 *                      to the cluster. Each entry in this array corresponds to
 *                      the entry at the same index in the
 *                      @a hosts. This array must either be completely empty or
 *                      have the same number of elements as
 *                      the @a hosts.  An empty @a configParams array will
 *                      result in the new ranks being set
 *                      with default parameters.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_add_ranks_dry_run: If @a true,
 *                 only validation checks will be performed. No ranks are
 *                 added.
 *                 <ul>
 *                         <li> gpudb::admin_add_ranks_true
 *                         <li> gpudb::admin_add_ranks_false
 *                 </ul>
 *                 The default value is gpudb::admin_add_ranks_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminAddRanksResponse adminAddRanks( const std::vector<std::string>& hosts,
                                     const std::vector<std::map<std::string, std::string> >& configParams,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Add one or more ranks to an existing Kinetica cluster. The new ranks will
 * not contain any data initially (other than replicated tables) and will not
 * be assigned any shards. To rebalance data and shards across the cluster, use
 * {@link
 * #adminRebalance(const std::map<std::string, std::string>&,AdminRebalanceResponse&) const}.
 * <p>
 * The database must be offline for this operation, see {@link
 * #adminOffline(const bool,const std::map<std::string, std::string>&,AdminOfflineResponse&) const}
 * <p>
 * For example, if attempting to add three new ranks (two ranks on host
 * 172.123.45.67 and one rank on host 172.123.45.68) to a Kinetica cluster with
 * additional configuration parameters:
 * <p>
 * * @a hosts
 *   would be an array including 172.123.45.67 in the first two indices
 *   (signifying two ranks being added to host 172.123.45.67) and
 *   172.123.45.68 in the last index (signifying one rank being added
 *   to host 172.123.45.67)
 * * @a configParams
 *   would be an array of maps, with each map corresponding to the ranks
 *   being added in @a hosts. The key of each map would be
 *   the configuration parameter name and the value would be the
 *   parameter's value, e.g. '{"rank.gpu":"1"}'
 * <p>
 * This endpoint's processing includes copying all replicated table data to the
 * new rank(s) and therefore could take a long time. The API call may time out
 * if run directly.  It is recommended to run this endpoint asynchronously via
 * {@link
 * #createJob(const std::string&,const std::string&,const std::vector<uint8_t>&,const std::string&,const std::map<std::string, std::string>&,CreateJobResponse&) const}.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param hosts  Array of host IP addresses (matching a hostN.address from the
 *               gpudb.conf file), or host identifiers (e.g. 'host0' from the
 *               gpudb.conf file), on which to add ranks to the cluster. The
 *               hosts must already be in the cluster. If needed beforehand, to
 *               add a new host to the cluster use /admin/add/host. Include the
 *               same entry as many times as there are ranks to add to the
 *               cluster, e.g., if two ranks on host 172.123.45.67 should be
 *               added, @a hosts could look like '["172.123.45.67",
 *               "172.123.45.67"]'. All ranks will be added simultaneously,
 *               i.e. they're not added in the order of this array. Each entry
 *               in this array corresponds to the entry at the same index in
 *               the @a configParams.
 * @param configParams  Array of maps containing configuration parameters to
 *                      apply to the new ranks
 *                      found in @a hosts. For example,
 *                      '{"rank.gpu":"2",
 *                      "tier.ram.rank.limit":"10000000000"}'. Currently, the
 *                      available parameters
 *                      are rank-specific parameters in the <a
 *                      href="../../../config/#config-main-network"
 *                      target="_top">Network</a>,
 *                      <a href="../../../config/#config-main-hardware"
 *                      target="_top">Hardware</a>,
 *                      <a href="../../../config/#config-main-text-search"
 *                      target="_top">Text Search</a>, and
 *                      <a href="../../../config/#config-main-ram-tier"
 *                      target="_top">RAM Tiered Storage</a> sections in the
 *                      gpudb.conf file, with the
 *                      key exception of the 'rankN.host' settings in the
 *                      Network section that will be determined by
 *                      @a hosts instead. Though many of these configuration
 *                      parameters typically are affixed with
 *                      'rankN' in the gpudb.conf file (where N is the rank
 *                      number), the 'N' should be omitted in
 *                      @a configParams as the new rank number(s) are not
 *                      allocated until the ranks have been added
 *                      to the cluster. Each entry in this array corresponds to
 *                      the entry at the same index in the
 *                      @a hosts. This array must either be completely empty or
 *                      have the same number of elements as
 *                      the @a hosts.  An empty @a configParams array will
 *                      result in the new ranks being set
 *                      with default parameters.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_add_ranks_dry_run: If @a true,
 *                 only validation checks will be performed. No ranks are
 *                 added.
 *                 <ul>
 *                         <li> gpudb::admin_add_ranks_true
 *                         <li> gpudb::admin_add_ranks_false
 *                 </ul>
 *                 The default value is gpudb::admin_add_ranks_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminAddRanksResponse& adminAddRanks( const std::vector<std::string>& hosts,
                                      const std::vector<std::map<std::string, std::string> >& configParams,
                                      const std::map<std::string, std::string>& options,
                                      AdminAddRanksResponse& response_ ) const;

/**
 * Alter properties on an existing host in the cluster. Currently, the only
 * property that can be altered is a hosts ability to accept failover
 * processes.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminAlterHostResponse adminAlterHost( const AdminAlterHostRequest& request_ ) const;

/**
 * Alter properties on an existing host in the cluster. Currently, the only
 * property that can be altered is a hosts ability to accept failover
 * processes.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminAlterHostResponse& adminAlterHost( const AdminAlterHostRequest& request_,
                                        AdminAlterHostResponse& response_ ) const;

/**
 * Alter properties on an existing host in the cluster. Currently, the only
 * property that can be altered is a hosts ability to accept failover
 * processes.
 * 
 * @param host  Identifies the host this applies to. Can be the host address,
 *              or formatted as 'hostN' where N is the host number as specified
 *              in gpudb.conf
 * @param options  Optional parameters
 *                 <ul>
 *                         <li> gpudb::admin_alter_host_accepts_failover: If
 *                 set to @a true, the host will accept processes (ranks, graph
 *                 server, etc.) in the event of a failover on another node in
 *                 the cluster.
 *                 <ul>
 *                         <li> gpudb::admin_alter_host_true
 *                         <li> gpudb::admin_alter_host_false
 *                 </ul>
 *                 The default value is gpudb::admin_alter_host_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminAlterHostResponse adminAlterHost( const std::string& host,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Alter properties on an existing host in the cluster. Currently, the only
 * property that can be altered is a hosts ability to accept failover
 * processes.
 * 
 * @param host  Identifies the host this applies to. Can be the host address,
 *              or formatted as 'hostN' where N is the host number as specified
 *              in gpudb.conf
 * @param options  Optional parameters
 *                 <ul>
 *                         <li> gpudb::admin_alter_host_accepts_failover: If
 *                 set to @a true, the host will accept processes (ranks, graph
 *                 server, etc.) in the event of a failover on another node in
 *                 the cluster.
 *                 <ul>
 *                         <li> gpudb::admin_alter_host_true
 *                         <li> gpudb::admin_alter_host_false
 *                 </ul>
 *                 The default value is gpudb::admin_alter_host_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminAlterHostResponse& adminAlterHost( const std::string& host,
                                        const std::map<std::string, std::string>& options,
                                        AdminAlterHostResponse& response_ ) const;

/**
 * Perform the requested action on a list of one or more job(s). Based
 * on the type of job and the current state of execution, the action may not be
 * successfully executed. The final result of the attempted actions for each
 * specified job is returned in the status array of the response. See
 * <a href="../../../admin/job_manager/" target="_top">Job Manager</a> for more
 * information.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminAlterJobsResponse adminAlterJobs( const AdminAlterJobsRequest& request_ ) const;

/**
 * Perform the requested action on a list of one or more job(s). Based
 * on the type of job and the current state of execution, the action may not be
 * successfully executed. The final result of the attempted actions for each
 * specified job is returned in the status array of the response. See
 * <a href="../../../admin/job_manager/" target="_top">Job Manager</a> for more
 * information.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminAlterJobsResponse& adminAlterJobs( const AdminAlterJobsRequest& request_,
                                        AdminAlterJobsResponse& response_ ) const;

/**
 * Perform the requested action on a list of one or more job(s). Based
 * on the type of job and the current state of execution, the action may not be
 * successfully executed. The final result of the attempted actions for each
 * specified job is returned in the status array of the response. See
 * <a href="../../../admin/job_manager/" target="_top">Job Manager</a> for more
 * information.
 * 
 * @param jobIds  Jobs to be modified.
 * @param action  Action to be performed on the jobs specified by job_ids.
 *                <ul>
 *                        <li> gpudb::admin_alter_jobs_cancel
 *                </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_alter_jobs_job_tag: Job tag
 *                 returned in call to create the job
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminAlterJobsResponse adminAlterJobs( const std::vector<int64_t>& jobIds,
                                       const std::string& action,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Perform the requested action on a list of one or more job(s). Based
 * on the type of job and the current state of execution, the action may not be
 * successfully executed. The final result of the attempted actions for each
 * specified job is returned in the status array of the response. See
 * <a href="../../../admin/job_manager/" target="_top">Job Manager</a> for more
 * information.
 * 
 * @param jobIds  Jobs to be modified.
 * @param action  Action to be performed on the jobs specified by job_ids.
 *                <ul>
 *                        <li> gpudb::admin_alter_jobs_cancel
 *                </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_alter_jobs_job_tag: Job tag
 *                 returned in call to create the job
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminAlterJobsResponse& adminAlterJobs( const std::vector<int64_t>& jobIds,
                                        const std::string& action,
                                        const std::map<std::string, std::string>& options,
                                        AdminAlterJobsResponse& response_ ) const;

/**
 * Prepares the system for a backup by closing all open file handles after
 * allowing current active jobs to complete. When the database is in backup
 * mode, queries that result in a disk write operation will be blocked until
 * backup mode has been completed by using {@link
 * #adminBackupEnd(const AdminBackupEndRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminBackupBeginResponse adminBackupBegin( const AdminBackupBeginRequest& request_ ) const;

/**
 * Prepares the system for a backup by closing all open file handles after
 * allowing current active jobs to complete. When the database is in backup
 * mode, queries that result in a disk write operation will be blocked until
 * backup mode has been completed by using {@link
 * #adminBackupEnd(const AdminBackupEndRequest&,AdminBackupEndResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminBackupBeginResponse& adminBackupBegin( const AdminBackupBeginRequest& request_,
                                            AdminBackupBeginResponse& response_ ) const;

/**
 * Prepares the system for a backup by closing all open file handles after
 * allowing current active jobs to complete. When the database is in backup
 * mode, queries that result in a disk write operation will be blocked until
 * backup mode has been completed by using {@link
 * #adminBackupEnd(const std::map<std::string, std::string>&) const}.
 * 
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminBackupBeginResponse adminBackupBegin( const std::map<std::string, std::string>& options ) const;

/**
 * Prepares the system for a backup by closing all open file handles after
 * allowing current active jobs to complete. When the database is in backup
 * mode, queries that result in a disk write operation will be blocked until
 * backup mode has been completed by using {@link
 * #adminBackupEnd(const std::map<std::string, std::string>&,AdminBackupEndResponse&) const}.
 * 
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminBackupBeginResponse& adminBackupBegin( const std::map<std::string, std::string>& options,
                                            AdminBackupBeginResponse& response_ ) const;

/**
 * Restores the system to normal operating mode after a backup has completed,
 * allowing any queries that were blocked to complete.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminBackupEndResponse adminBackupEnd( const AdminBackupEndRequest& request_ ) const;

/**
 * Restores the system to normal operating mode after a backup has completed,
 * allowing any queries that were blocked to complete.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminBackupEndResponse& adminBackupEnd( const AdminBackupEndRequest& request_,
                                        AdminBackupEndResponse& response_ ) const;

/**
 * Restores the system to normal operating mode after a backup has completed,
 * allowing any queries that were blocked to complete.
 * 
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminBackupEndResponse adminBackupEnd( const std::map<std::string, std::string>& options ) const;

/**
 * Restores the system to normal operating mode after a backup has completed,
 * allowing any queries that were blocked to complete.
 * 
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminBackupEndResponse& adminBackupEnd( const std::map<std::string, std::string>& options,
                                        AdminBackupEndResponse& response_ ) const;

/**
 * Restarts the HA processing on the given cluster as a mechanism of accepting
 * breaking HA conf changes. Additionally the cluster is put into read-only
 * while HA is restarting.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminHaRefreshResponse adminHaRefresh( const AdminHaRefreshRequest& request_ ) const;

/**
 * Restarts the HA processing on the given cluster as a mechanism of accepting
 * breaking HA conf changes. Additionally the cluster is put into read-only
 * while HA is restarting.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminHaRefreshResponse& adminHaRefresh( const AdminHaRefreshRequest& request_,
                                        AdminHaRefreshResponse& response_ ) const;

/**
 * Restarts the HA processing on the given cluster as a mechanism of accepting
 * breaking HA conf changes. Additionally the cluster is put into read-only
 * while HA is restarting.
 * 
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminHaRefreshResponse adminHaRefresh( const std::map<std::string, std::string>& options ) const;

/**
 * Restarts the HA processing on the given cluster as a mechanism of accepting
 * breaking HA conf changes. Additionally the cluster is put into read-only
 * while HA is restarting.
 * 
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminHaRefreshResponse& adminHaRefresh( const std::map<std::string, std::string>& options,
                                        AdminHaRefreshResponse& response_ ) const;

/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminOfflineResponse adminOffline( const AdminOfflineRequest& request_ ) const;

/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminOfflineResponse& adminOffline( const AdminOfflineRequest& request_,
                                    AdminOfflineResponse& response_ ) const;

/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param offline  Set to true if desired state is offline.
 *                 <ul>
 *                         <li> gpudb::admin_offline_true
 *                         <li> gpudb::admin_offline_false
 *                 </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_offline_flush_to_disk: Flush to
 *                 disk when going offline
 *                 <ul>
 *                         <li> gpudb::admin_offline_true
 *                         <li> gpudb::admin_offline_false
 *                 </ul>
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminOfflineResponse adminOffline( const bool offline,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param offline  Set to true if desired state is offline.
 *                 <ul>
 *                         <li> gpudb::admin_offline_true
 *                         <li> gpudb::admin_offline_false
 *                 </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_offline_flush_to_disk: Flush to
 *                 disk when going offline
 *                 <ul>
 *                         <li> gpudb::admin_offline_true
 *                         <li> gpudb::admin_offline_false
 *                 </ul>
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminOfflineResponse& adminOffline( const bool offline,
                                    const std::map<std::string, std::string>& options,
                                    AdminOfflineResponse& response_ ) const;

/**
 * Rebalance the data in the cluster so that all nodes contain an equal
 * number of records approximately and/or rebalance the shards to be equally
 * distributed (as much as possible) across all the ranks.
 * <p>
 * The database must be offline for this operation, see {@link
 * #adminOffline(const AdminOfflineRequest&) const}
 * <p>
 * * If {@link #adminRebalance(const AdminRebalanceRequest&) const} is
 * invoked after a change is
 *   made to the cluster, e.g., a host was added or removed,
 *   <a href="../../../concepts/tables/#sharding" target="_top">sharded
 * data</a> will be
 *   evenly redistributed across the cluster by number of shards per rank
 *   while unsharded data will be redistributed across the cluster by data
 *   size per rank
 * * If {@link #adminRebalance(const AdminRebalanceRequest&) const}
 *   is invoked at some point when unsharded data (a.k.a.
 *   <a href="../../../concepts/tables/#random-sharding"
 * target="_top">randomly-sharded</a>)
 *   in the cluster is unevenly distributed over time, sharded data will
 *   not move while unsharded data will be redistributed across the
 *   cluster by data size per rank
 * <p>
 * NOTE: Replicated data will not move as a result of this call
 * <p>
 * This endpoint's processing time depends on the amount of data in the system,
 * thus the API call may time out if run directly.  It is recommended to run
 * this
 * endpoint asynchronously via {@link
 * #createJob(const CreateJobRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminRebalanceResponse adminRebalance( const AdminRebalanceRequest& request_ ) const;

/**
 * Rebalance the data in the cluster so that all nodes contain an equal
 * number of records approximately and/or rebalance the shards to be equally
 * distributed (as much as possible) across all the ranks.
 * <p>
 * The database must be offline for this operation, see {@link
 * #adminOffline(const AdminOfflineRequest&,AdminOfflineResponse&) const}
 * <p>
 * * If {@link
 * #adminRebalance(const AdminRebalanceRequest&,AdminRebalanceResponse&) const}
 * is invoked after a change is
 *   made to the cluster, e.g., a host was added or removed,
 *   <a href="../../../concepts/tables/#sharding" target="_top">sharded
 * data</a> will be
 *   evenly redistributed across the cluster by number of shards per rank
 *   while unsharded data will be redistributed across the cluster by data
 *   size per rank
 * * If {@link
 * #adminRebalance(const AdminRebalanceRequest&,AdminRebalanceResponse&) const}
 *   is invoked at some point when unsharded data (a.k.a.
 *   <a href="../../../concepts/tables/#random-sharding"
 * target="_top">randomly-sharded</a>)
 *   in the cluster is unevenly distributed over time, sharded data will
 *   not move while unsharded data will be redistributed across the
 *   cluster by data size per rank
 * <p>
 * NOTE: Replicated data will not move as a result of this call
 * <p>
 * This endpoint's processing time depends on the amount of data in the system,
 * thus the API call may time out if run directly.  It is recommended to run
 * this
 * endpoint asynchronously via {@link
 * #createJob(const CreateJobRequest&,CreateJobResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminRebalanceResponse& adminRebalance( const AdminRebalanceRequest& request_,
                                        AdminRebalanceResponse& response_ ) const;

/**
 * Rebalance the data in the cluster so that all nodes contain an equal
 * number of records approximately and/or rebalance the shards to be equally
 * distributed (as much as possible) across all the ranks.
 * <p>
 * The database must be offline for this operation, see {@link
 * #adminOffline(const bool,const std::map<std::string, std::string>&) const}
 * <p>
 * * If {@link
 * #adminRebalance(const std::map<std::string, std::string>&) const} is
 * invoked after a change is
 *   made to the cluster, e.g., a host was added or removed,
 *   <a href="../../../concepts/tables/#sharding" target="_top">sharded
 * data</a> will be
 *   evenly redistributed across the cluster by number of shards per rank
 *   while unsharded data will be redistributed across the cluster by data
 *   size per rank
 * * If {@link
 * #adminRebalance(const std::map<std::string, std::string>&) const}
 *   is invoked at some point when unsharded data (a.k.a.
 *   <a href="../../../concepts/tables/#random-sharding"
 * target="_top">randomly-sharded</a>)
 *   in the cluster is unevenly distributed over time, sharded data will
 *   not move while unsharded data will be redistributed across the
 *   cluster by data size per rank
 * <p>
 * NOTE: Replicated data will not move as a result of this call
 * <p>
 * This endpoint's processing time depends on the amount of data in the system,
 * thus the API call may time out if run directly.  It is recommended to run
 * this
 * endpoint asynchronously via {@link
 * #createJob(const std::string&,const std::string&,const std::vector<uint8_t>&,const std::string&,const std::map<std::string, std::string>&) const}.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_rebalance_sharded_data:
 *                 If @a true, <a href="../../../concepts/tables/#sharding"
 *                 target="_top">sharded data</a> will be rebalanced
 *                 approximately equally across the cluster. Note that for
 *                 clusters with large amounts of sharded data, this data
 *                 transfer could be time consuming and result in delayed query
 *                 responses.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_true
 *                         <li> gpudb::admin_rebalance_false
 *                 </ul>
 *                 The default value is gpudb::admin_rebalance_true.
 *                         <li>
 *                 gpudb::admin_rebalance_rebalance_unsharded_data: If @a true,
 *                 unsharded data (a.k.a. <a
 *                 href="../../../concepts/tables/#random-sharding"
 *                 target="_top">randomly-sharded</a>) will be rebalanced
 *                 approximately equally across the cluster. Note that for
 *                 clusters with large amounts of unsharded data, this data
 *                 transfer could be time consuming and result in delayed query
 *                 responses.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_true
 *                         <li> gpudb::admin_rebalance_false
 *                 </ul>
 *                 The default value is gpudb::admin_rebalance_true.
 *                         <li> gpudb::admin_rebalance_table_includes:
 *                 Comma-separated list of unsharded table names to rebalance.
 *                 Not applicable to sharded tables because they are always
 *                 rebalanced. Cannot be used simultaneously with @a
 *                 table_excludes. This parameter is ignored if @a
 *                 rebalance_unsharded_data is @a false.
 *                         <li> gpudb::admin_rebalance_table_excludes:
 *                 Comma-separated list of unsharded table names to not
 *                 rebalance. Not applicable to sharded tables because they are
 *                 always rebalanced. Cannot be used simultaneously with @a
 *                 table_includes. This parameter is ignored if @a
 *                 rebalance_unsharded_data is @a false.
 *                         <li> gpudb::admin_rebalance_aggressiveness:
 *                 Influences how much data is moved at a time during
 *                 rebalance.  A higher @a aggressiveness will complete the
 *                 rebalance faster.  A lower @a aggressiveness will take
 *                 longer but allow for better interleaving between the
 *                 rebalance and other queries. Valid values are constants from
 *                 1 (lowest) to 10 (highest).  The default value is '10'.
 *                         <li> gpudb::admin_rebalance_compact_after_rebalance:
 *                 Perform compaction of deleted records once the rebalance
 *                 completes to reclaim memory and disk space. Default is @a
 *                 true, unless @a repair_incorrectly_sharded_data is set to @a
 *                 true.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_true
 *                         <li> gpudb::admin_rebalance_false
 *                 </ul>
 *                 The default value is gpudb::admin_rebalance_true.
 *                         <li> gpudb::admin_rebalance_compact_only: If set to
 *                 @a true, ignore rebalance options and attempt to perform
 *                 compaction of deleted records to reclaim memory and disk
 *                 space without rebalancing first.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_true
 *                         <li> gpudb::admin_rebalance_false
 *                 </ul>
 *                 The default value is gpudb::admin_rebalance_false.
 *                         <li>
 *                 gpudb::admin_rebalance_repair_incorrectly_sharded_data:
 *                 Scans for any data sharded incorrectly and re-routes the
 *                 data to the correct location. Only necessary if
 *                 /admin/verifydb reports an error in sharding alignment. This
 *                 can be done as part of a typical rebalance after expanding
 *                 the cluster or in a standalone fashion when it is believed
 *                 that data is sharded incorrectly somewhere in the cluster.
 *                 Compaction will not be performed by default when this is
 *                 enabled. If this option is set to @a true, the time
 *                 necessary to rebalance and the memory used by the rebalance
 *                 may increase.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_true
 *                         <li> gpudb::admin_rebalance_false
 *                 </ul>
 *                 The default value is gpudb::admin_rebalance_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminRebalanceResponse adminRebalance( const std::map<std::string, std::string>& options ) const;

/**
 * Rebalance the data in the cluster so that all nodes contain an equal
 * number of records approximately and/or rebalance the shards to be equally
 * distributed (as much as possible) across all the ranks.
 * <p>
 * The database must be offline for this operation, see {@link
 * #adminOffline(const bool,const std::map<std::string, std::string>&,AdminOfflineResponse&) const}
 * <p>
 * * If {@link
 * #adminRebalance(const std::map<std::string, std::string>&,AdminRebalanceResponse&) const}
 * is invoked after a change is
 *   made to the cluster, e.g., a host was added or removed,
 *   <a href="../../../concepts/tables/#sharding" target="_top">sharded
 * data</a> will be
 *   evenly redistributed across the cluster by number of shards per rank
 *   while unsharded data will be redistributed across the cluster by data
 *   size per rank
 * * If {@link
 * #adminRebalance(const std::map<std::string, std::string>&,AdminRebalanceResponse&) const}
 *   is invoked at some point when unsharded data (a.k.a.
 *   <a href="../../../concepts/tables/#random-sharding"
 * target="_top">randomly-sharded</a>)
 *   in the cluster is unevenly distributed over time, sharded data will
 *   not move while unsharded data will be redistributed across the
 *   cluster by data size per rank
 * <p>
 * NOTE: Replicated data will not move as a result of this call
 * <p>
 * This endpoint's processing time depends on the amount of data in the system,
 * thus the API call may time out if run directly.  It is recommended to run
 * this
 * endpoint asynchronously via {@link
 * #createJob(const std::string&,const std::string&,const std::vector<uint8_t>&,const std::string&,const std::map<std::string, std::string>&,CreateJobResponse&) const}.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_rebalance_sharded_data:
 *                 If @a true, <a href="../../../concepts/tables/#sharding"
 *                 target="_top">sharded data</a> will be rebalanced
 *                 approximately equally across the cluster. Note that for
 *                 clusters with large amounts of sharded data, this data
 *                 transfer could be time consuming and result in delayed query
 *                 responses.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_true
 *                         <li> gpudb::admin_rebalance_false
 *                 </ul>
 *                 The default value is gpudb::admin_rebalance_true.
 *                         <li>
 *                 gpudb::admin_rebalance_rebalance_unsharded_data: If @a true,
 *                 unsharded data (a.k.a. <a
 *                 href="../../../concepts/tables/#random-sharding"
 *                 target="_top">randomly-sharded</a>) will be rebalanced
 *                 approximately equally across the cluster. Note that for
 *                 clusters with large amounts of unsharded data, this data
 *                 transfer could be time consuming and result in delayed query
 *                 responses.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_true
 *                         <li> gpudb::admin_rebalance_false
 *                 </ul>
 *                 The default value is gpudb::admin_rebalance_true.
 *                         <li> gpudb::admin_rebalance_table_includes:
 *                 Comma-separated list of unsharded table names to rebalance.
 *                 Not applicable to sharded tables because they are always
 *                 rebalanced. Cannot be used simultaneously with @a
 *                 table_excludes. This parameter is ignored if @a
 *                 rebalance_unsharded_data is @a false.
 *                         <li> gpudb::admin_rebalance_table_excludes:
 *                 Comma-separated list of unsharded table names to not
 *                 rebalance. Not applicable to sharded tables because they are
 *                 always rebalanced. Cannot be used simultaneously with @a
 *                 table_includes. This parameter is ignored if @a
 *                 rebalance_unsharded_data is @a false.
 *                         <li> gpudb::admin_rebalance_aggressiveness:
 *                 Influences how much data is moved at a time during
 *                 rebalance.  A higher @a aggressiveness will complete the
 *                 rebalance faster.  A lower @a aggressiveness will take
 *                 longer but allow for better interleaving between the
 *                 rebalance and other queries. Valid values are constants from
 *                 1 (lowest) to 10 (highest).  The default value is '10'.
 *                         <li> gpudb::admin_rebalance_compact_after_rebalance:
 *                 Perform compaction of deleted records once the rebalance
 *                 completes to reclaim memory and disk space. Default is @a
 *                 true, unless @a repair_incorrectly_sharded_data is set to @a
 *                 true.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_true
 *                         <li> gpudb::admin_rebalance_false
 *                 </ul>
 *                 The default value is gpudb::admin_rebalance_true.
 *                         <li> gpudb::admin_rebalance_compact_only: If set to
 *                 @a true, ignore rebalance options and attempt to perform
 *                 compaction of deleted records to reclaim memory and disk
 *                 space without rebalancing first.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_true
 *                         <li> gpudb::admin_rebalance_false
 *                 </ul>
 *                 The default value is gpudb::admin_rebalance_false.
 *                         <li>
 *                 gpudb::admin_rebalance_repair_incorrectly_sharded_data:
 *                 Scans for any data sharded incorrectly and re-routes the
 *                 data to the correct location. Only necessary if
 *                 /admin/verifydb reports an error in sharding alignment. This
 *                 can be done as part of a typical rebalance after expanding
 *                 the cluster or in a standalone fashion when it is believed
 *                 that data is sharded incorrectly somewhere in the cluster.
 *                 Compaction will not be performed by default when this is
 *                 enabled. If this option is set to @a true, the time
 *                 necessary to rebalance and the memory used by the rebalance
 *                 may increase.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_true
 *                         <li> gpudb::admin_rebalance_false
 *                 </ul>
 *                 The default value is gpudb::admin_rebalance_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminRebalanceResponse& adminRebalance( const std::map<std::string, std::string>& options,
                                        AdminRebalanceResponse& response_ ) const;

/**
 * Removes a host from an existing cluster. If the host to be removed has any
 * ranks running on it, the ranks must be removed using {@link
 * #adminRemoveRanks(const AdminRemoveRanksRequest&) const} or manually
 * switched over to a new host using {@link
 * #adminSwitchover(const AdminSwitchoverRequest&) const} prior to host
 * removal. If the host to be removed has the graph server or SQL planner
 * running on it, these must be manually switched over to a new host using
 * {@link #adminSwitchover(const AdminSwitchoverRequest&) const}.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminRemoveHostResponse adminRemoveHost( const AdminRemoveHostRequest& request_ ) const;

/**
 * Removes a host from an existing cluster. If the host to be removed has any
 * ranks running on it, the ranks must be removed using {@link
 * #adminRemoveRanks(const AdminRemoveRanksRequest&,AdminRemoveRanksResponse&) const}
 * or manually switched over to a new host using {@link
 * #adminSwitchover(const AdminSwitchoverRequest&,AdminSwitchoverResponse&) const}
 * prior to host removal. If the host to be removed has the graph server or SQL
 * planner running on it, these must be manually switched over to a new host
 * using {@link
 * #adminSwitchover(const AdminSwitchoverRequest&,AdminSwitchoverResponse&) const}.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminRemoveHostResponse& adminRemoveHost( const AdminRemoveHostRequest& request_,
                                          AdminRemoveHostResponse& response_ ) const;

/**
 * Removes a host from an existing cluster. If the host to be removed has any
 * ranks running on it, the ranks must be removed using {@link
 * #adminRemoveRanks(const std::vector<std::string>&,const std::map<std::string, std::string>&) const}
 * or manually switched over to a new host using {@link
 * #adminSwitchover(const std::vector<std::string>&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}
 * prior to host removal. If the host to be removed has the graph server or SQL
 * planner running on it, these must be manually switched over to a new host
 * using {@link
 * #adminSwitchover(const std::vector<std::string>&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param host  Identifies the host this applies to. Can be the host address,
 *              or formatted as 'hostN' where N is the host number as specified
 *              in gpudb.conf
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_remove_host_dry_run: If set to @a
 *                 true, only validation checks will be performed. No host is
 *                 removed.
 *                 <ul>
 *                         <li> gpudb::admin_remove_host_true
 *                         <li> gpudb::admin_remove_host_false
 *                 </ul>
 *                 The default value is gpudb::admin_remove_host_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminRemoveHostResponse adminRemoveHost( const std::string& host,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Removes a host from an existing cluster. If the host to be removed has any
 * ranks running on it, the ranks must be removed using {@link
 * #adminRemoveRanks(const std::vector<std::string>&,const std::map<std::string, std::string>&,AdminRemoveRanksResponse&) const}
 * or manually switched over to a new host using {@link
 * #adminSwitchover(const std::vector<std::string>&,const std::vector<std::string>&,const std::map<std::string, std::string>&,AdminSwitchoverResponse&) const}
 * prior to host removal. If the host to be removed has the graph server or SQL
 * planner running on it, these must be manually switched over to a new host
 * using {@link
 * #adminSwitchover(const std::vector<std::string>&,const std::vector<std::string>&,const std::map<std::string, std::string>&,AdminSwitchoverResponse&) const}.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param host  Identifies the host this applies to. Can be the host address,
 *              or formatted as 'hostN' where N is the host number as specified
 *              in gpudb.conf
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_remove_host_dry_run: If set to @a
 *                 true, only validation checks will be performed. No host is
 *                 removed.
 *                 <ul>
 *                         <li> gpudb::admin_remove_host_true
 *                         <li> gpudb::admin_remove_host_false
 *                 </ul>
 *                 The default value is gpudb::admin_remove_host_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminRemoveHostResponse& adminRemoveHost( const std::string& host,
                                          const std::map<std::string, std::string>& options,
                                          AdminRemoveHostResponse& response_ ) const;

/**
 * Remove one or more ranks from an existing Kinetica cluster. All data
 * will be rebalanced to other ranks before the rank(s) is removed unless the
 * @a rebalance_sharded_data or
 * @a rebalance_unsharded_data parameters are set to
 * @a false in the
 * @a options, in which case the corresponding
 * <a href="../../../concepts/tables/#sharding" target="_top">sharded data</a>
 * and/or unsharded data (a.k.a.
 * <a href="../../../concepts/tables/#random-sharding"
 * target="_top">randomly-sharded</a>) will be deleted.
 * <p>
 * The database must be offline for this operation, see {@link
 * #adminOffline(const AdminOfflineRequest&) const}
 * <p>
 * This endpoint's processing time depends on the amount of data in the system,
 * thus the API call may time out if run directly.  It is recommended to run
 * this
 * endpoint asynchronously via {@link
 * #createJob(const CreateJobRequest&) const}.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminRemoveRanksResponse adminRemoveRanks( const AdminRemoveRanksRequest& request_ ) const;

/**
 * Remove one or more ranks from an existing Kinetica cluster. All data
 * will be rebalanced to other ranks before the rank(s) is removed unless the
 * @a rebalance_sharded_data or
 * @a rebalance_unsharded_data parameters are set to
 * @a false in the
 * @a options, in which case the corresponding
 * <a href="../../../concepts/tables/#sharding" target="_top">sharded data</a>
 * and/or unsharded data (a.k.a.
 * <a href="../../../concepts/tables/#random-sharding"
 * target="_top">randomly-sharded</a>) will be deleted.
 * <p>
 * The database must be offline for this operation, see {@link
 * #adminOffline(const AdminOfflineRequest&,AdminOfflineResponse&) const}
 * <p>
 * This endpoint's processing time depends on the amount of data in the system,
 * thus the API call may time out if run directly.  It is recommended to run
 * this
 * endpoint asynchronously via {@link
 * #createJob(const CreateJobRequest&,CreateJobResponse&) const}.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminRemoveRanksResponse& adminRemoveRanks( const AdminRemoveRanksRequest& request_,
                                            AdminRemoveRanksResponse& response_ ) const;

/**
 * Remove one or more ranks from an existing Kinetica cluster. All data
 * will be rebalanced to other ranks before the rank(s) is removed unless the
 * @a rebalance_sharded_data or
 * @a rebalance_unsharded_data parameters are set to
 * @a false in the
 * @a options, in which case the corresponding
 * <a href="../../../concepts/tables/#sharding" target="_top">sharded data</a>
 * and/or unsharded data (a.k.a.
 * <a href="../../../concepts/tables/#random-sharding"
 * target="_top">randomly-sharded</a>) will be deleted.
 * <p>
 * The database must be offline for this operation, see {@link
 * #adminOffline(const bool,const std::map<std::string, std::string>&) const}
 * <p>
 * This endpoint's processing time depends on the amount of data in the system,
 * thus the API call may time out if run directly.  It is recommended to run
 * this
 * endpoint asynchronously via {@link
 * #createJob(const std::string&,const std::string&,const std::vector<uint8_t>&,const std::string&,const std::map<std::string, std::string>&) const}.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param ranks  Each array value designates one or more ranks to remove from
 *               the cluster. Values can be formatted as 'rankN' for a specific
 *               rank, 'hostN' (from the gpudb.conf file) to remove all ranks
 *               on that host, or the host IP address (hostN.address from the
 *               gpub.conf file) which also removes all ranks on that host.
 *               Rank 0 (the head rank) cannot be removed (but can be moved to
 *               another host using /admin/switchover). At least one worker
 *               rank must be left in the cluster after the operation.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::admin_remove_ranks_rebalance_sharded_data: If @a
 *                 true, <a href="../../../concepts/tables/#sharding"
 *                 target="_top">sharded data</a> will be rebalanced
 *                 approximately equally across the cluster. Note that for
 *                 clusters with large amounts of sharded data, this data
 *                 transfer could be time consuming and result in delayed query
 *                 responses.
 *                 <ul>
 *                         <li> gpudb::admin_remove_ranks_true
 *                         <li> gpudb::admin_remove_ranks_false
 *                 </ul>
 *                 The default value is gpudb::admin_remove_ranks_true.
 *                         <li>
 *                 gpudb::admin_remove_ranks_rebalance_unsharded_data: If @a
 *                 true, unsharded data (a.k.a. <a
 *                 href="../../../concepts/tables/#random-sharding"
 *                 target="_top">randomly-sharded</a>) will be rebalanced
 *                 approximately equally across the cluster. Note that for
 *                 clusters with large amounts of unsharded data, this data
 *                 transfer could be time consuming and result in delayed query
 *                 responses.
 *                 <ul>
 *                         <li> gpudb::admin_remove_ranks_true
 *                         <li> gpudb::admin_remove_ranks_false
 *                 </ul>
 *                 The default value is gpudb::admin_remove_ranks_true.
 *                         <li> gpudb::admin_remove_ranks_aggressiveness:
 *                 Influences how much data is moved at a time during
 *                 rebalance.  A higher @a aggressiveness will complete the
 *                 rebalance faster.  A lower @a aggressiveness will take
 *                 longer but allow for better interleaving between the
 *                 rebalance and other queries. Valid values are constants from
 *                 1 (lowest) to 10 (highest).  The default value is '10'.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminRemoveRanksResponse adminRemoveRanks( const std::vector<std::string>& ranks,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * Remove one or more ranks from an existing Kinetica cluster. All data
 * will be rebalanced to other ranks before the rank(s) is removed unless the
 * @a rebalance_sharded_data or
 * @a rebalance_unsharded_data parameters are set to
 * @a false in the
 * @a options, in which case the corresponding
 * <a href="../../../concepts/tables/#sharding" target="_top">sharded data</a>
 * and/or unsharded data (a.k.a.
 * <a href="../../../concepts/tables/#random-sharding"
 * target="_top">randomly-sharded</a>) will be deleted.
 * <p>
 * The database must be offline for this operation, see {@link
 * #adminOffline(const bool,const std::map<std::string, std::string>&,AdminOfflineResponse&) const}
 * <p>
 * This endpoint's processing time depends on the amount of data in the system,
 * thus the API call may time out if run directly.  It is recommended to run
 * this
 * endpoint asynchronously via {@link
 * #createJob(const std::string&,const std::string&,const std::vector<uint8_t>&,const std::string&,const std::map<std::string, std::string>&,CreateJobResponse&) const}.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param ranks  Each array value designates one or more ranks to remove from
 *               the cluster. Values can be formatted as 'rankN' for a specific
 *               rank, 'hostN' (from the gpudb.conf file) to remove all ranks
 *               on that host, or the host IP address (hostN.address from the
 *               gpub.conf file) which also removes all ranks on that host.
 *               Rank 0 (the head rank) cannot be removed (but can be moved to
 *               another host using /admin/switchover). At least one worker
 *               rank must be left in the cluster after the operation.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::admin_remove_ranks_rebalance_sharded_data: If @a
 *                 true, <a href="../../../concepts/tables/#sharding"
 *                 target="_top">sharded data</a> will be rebalanced
 *                 approximately equally across the cluster. Note that for
 *                 clusters with large amounts of sharded data, this data
 *                 transfer could be time consuming and result in delayed query
 *                 responses.
 *                 <ul>
 *                         <li> gpudb::admin_remove_ranks_true
 *                         <li> gpudb::admin_remove_ranks_false
 *                 </ul>
 *                 The default value is gpudb::admin_remove_ranks_true.
 *                         <li>
 *                 gpudb::admin_remove_ranks_rebalance_unsharded_data: If @a
 *                 true, unsharded data (a.k.a. <a
 *                 href="../../../concepts/tables/#random-sharding"
 *                 target="_top">randomly-sharded</a>) will be rebalanced
 *                 approximately equally across the cluster. Note that for
 *                 clusters with large amounts of unsharded data, this data
 *                 transfer could be time consuming and result in delayed query
 *                 responses.
 *                 <ul>
 *                         <li> gpudb::admin_remove_ranks_true
 *                         <li> gpudb::admin_remove_ranks_false
 *                 </ul>
 *                 The default value is gpudb::admin_remove_ranks_true.
 *                         <li> gpudb::admin_remove_ranks_aggressiveness:
 *                 Influences how much data is moved at a time during
 *                 rebalance.  A higher @a aggressiveness will complete the
 *                 rebalance faster.  A lower @a aggressiveness will take
 *                 longer but allow for better interleaving between the
 *                 rebalance and other queries. Valid values are constants from
 *                 1 (lowest) to 10 (highest).  The default value is '10'.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminRemoveRanksResponse& adminRemoveRanks( const std::vector<std::string>& ranks,
                                            const std::map<std::string, std::string>& options,
                                            AdminRemoveRanksResponse& response_ ) const;

/**
 * Requests a list of the most recent alerts.
 * Returns lists of alert data, including timestamp and type.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowAlertsResponse adminShowAlerts( const AdminShowAlertsRequest& request_ ) const;

/**
 * Requests a list of the most recent alerts.
 * Returns lists of alert data, including timestamp and type.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowAlertsResponse& adminShowAlerts( const AdminShowAlertsRequest& request_,
                                          AdminShowAlertsResponse& response_ ) const;

/**
 * Requests a list of the most recent alerts.
 * Returns lists of alert data, including timestamp and type.
 * 
 * @param numAlerts  Number of most recent alerts to request. The response will
 *                   include up to @a numAlerts depending on how many alerts
 *                   there are in the system. A value of 0 returns all stored
 *                   alerts.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowAlertsResponse adminShowAlerts( const int32_t numAlerts,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Requests a list of the most recent alerts.
 * Returns lists of alert data, including timestamp and type.
 * 
 * @param numAlerts  Number of most recent alerts to request. The response will
 *                   include up to @a numAlerts depending on how many alerts
 *                   there are in the system. A value of 0 returns all stored
 *                   alerts.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowAlertsResponse& adminShowAlerts( const int32_t numAlerts,
                                          const std::map<std::string, std::string>& options,
                                          AdminShowAlertsResponse& response_ ) const;

/**
 * Requests the detailed status of the current operation (by default) or a
 * prior cluster operation specified by @a historyIndex.
 * Returns details on the requested cluster operation.
 * <p>
 * The response will also indicate how many cluster operations are stored in
 * the history.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowClusterOperationsResponse adminShowClusterOperations( const AdminShowClusterOperationsRequest& request_ ) const;

/**
 * Requests the detailed status of the current operation (by default) or a
 * prior cluster operation specified by @a historyIndex.
 * Returns details on the requested cluster operation.
 * <p>
 * The response will also indicate how many cluster operations are stored in
 * the history.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowClusterOperationsResponse& adminShowClusterOperations( const AdminShowClusterOperationsRequest& request_,
                                                                AdminShowClusterOperationsResponse& response_ ) const;

/**
 * Requests the detailed status of the current operation (by default) or a
 * prior cluster operation specified by @a historyIndex.
 * Returns details on the requested cluster operation.
 * <p>
 * The response will also indicate how many cluster operations are stored in
 * the history.
 * 
 * @param historyIndex  Indicates which cluster operation to retrieve.  Use 0
 *                      for the most recent.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowClusterOperationsResponse adminShowClusterOperations( const int32_t historyIndex,
                                                               const std::map<std::string, std::string>& options ) const;

/**
 * Requests the detailed status of the current operation (by default) or a
 * prior cluster operation specified by @a historyIndex.
 * Returns details on the requested cluster operation.
 * <p>
 * The response will also indicate how many cluster operations are stored in
 * the history.
 * 
 * @param historyIndex  Indicates which cluster operation to retrieve.  Use 0
 *                      for the most recent.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowClusterOperationsResponse& adminShowClusterOperations( const int32_t historyIndex,
                                                                const std::map<std::string, std::string>& options,
                                                                AdminShowClusterOperationsResponse& response_ ) const;

/**
 * Get a list of the current jobs in GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowJobsResponse adminShowJobs( const AdminShowJobsRequest& request_ ) const;

/**
 * Get a list of the current jobs in GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowJobsResponse& adminShowJobs( const AdminShowJobsRequest& request_,
                                      AdminShowJobsResponse& response_ ) const;

/**
 * Get a list of the current jobs in GPUdb.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_show_jobs_show_async_jobs: If @a
 *                 true, then the completed async jobs are also included in the
 *                 response. By default, once the async jobs are completed they
 *                 are no longer included in the jobs list.
 *                 <ul>
 *                         <li> gpudb::admin_show_jobs_true
 *                         <li> gpudb::admin_show_jobs_false
 *                 </ul>
 *                 The default value is gpudb::admin_show_jobs_false.
 *                         <li> gpudb::admin_show_jobs_show_worker_info: If @a
 *                 true, then information is also returned from worker ranks.
 *                 By default only status from the head rank is returned.
 *                 <ul>
 *                         <li> gpudb::admin_show_jobs_true
 *                         <li> gpudb::admin_show_jobs_false
 *                 </ul>
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowJobsResponse adminShowJobs( const std::map<std::string, std::string>& options ) const;

/**
 * Get a list of the current jobs in GPUdb.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_show_jobs_show_async_jobs: If @a
 *                 true, then the completed async jobs are also included in the
 *                 response. By default, once the async jobs are completed they
 *                 are no longer included in the jobs list.
 *                 <ul>
 *                         <li> gpudb::admin_show_jobs_true
 *                         <li> gpudb::admin_show_jobs_false
 *                 </ul>
 *                 The default value is gpudb::admin_show_jobs_false.
 *                         <li> gpudb::admin_show_jobs_show_worker_info: If @a
 *                 true, then information is also returned from worker ranks.
 *                 By default only status from the head rank is returned.
 *                 <ul>
 *                         <li> gpudb::admin_show_jobs_true
 *                         <li> gpudb::admin_show_jobs_false
 *                 </ul>
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowJobsResponse& adminShowJobs( const std::map<std::string, std::string>& options,
                                      AdminShowJobsResponse& response_ ) const;

/**
 * Show the mapping of shards to the corresponding rank and tom.  The response
 * message contains list of 16384 (total number of shards in the system) Rank
 * and TOM numbers corresponding to each shard.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowShardsResponse adminShowShards( const AdminShowShardsRequest& request_ ) const;

/**
 * Show the mapping of shards to the corresponding rank and tom.  The response
 * message contains list of 16384 (total number of shards in the system) Rank
 * and TOM numbers corresponding to each shard.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowShardsResponse& adminShowShards( const AdminShowShardsRequest& request_,
                                          AdminShowShardsResponse& response_ ) const;

/**
 * Show the mapping of shards to the corresponding rank and tom.  The response
 * message contains list of 16384 (total number of shards in the system) Rank
 * and TOM numbers corresponding to each shard.
 * 
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowShardsResponse adminShowShards( const std::map<std::string, std::string>& options ) const;

/**
 * Show the mapping of shards to the corresponding rank and tom.  The response
 * message contains list of 16384 (total number of shards in the system) Rank
 * and TOM numbers corresponding to each shard.
 * 
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowShardsResponse& adminShowShards( const std::map<std::string, std::string>& options,
                                          AdminShowShardsResponse& response_ ) const;

/**
 * Exits the database server application.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShutdownResponse adminShutdown( const AdminShutdownRequest& request_ ) const;

/**
 * Exits the database server application.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShutdownResponse& adminShutdown( const AdminShutdownRequest& request_,
                                      AdminShutdownResponse& response_ ) const;

/**
 * Exits the database server application.
 * 
 * @param exitType  Reserved for future use. User can pass an empty string.
 * @param authorization  No longer used. User can pass an empty string.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShutdownResponse adminShutdown( const std::string& exitType,
                                     const std::string& authorization,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Exits the database server application.
 * 
 * @param exitType  Reserved for future use. User can pass an empty string.
 * @param authorization  No longer used. User can pass an empty string.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShutdownResponse& adminShutdown( const std::string& exitType,
                                      const std::string& authorization,
                                      const std::map<std::string, std::string>& options,
                                      AdminShutdownResponse& response_ ) const;

/**
 * Manually switch over one or more processes to another host. Individual ranks
 * or entire hosts may be moved to another host.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminSwitchoverResponse adminSwitchover( const AdminSwitchoverRequest& request_ ) const;

/**
 * Manually switch over one or more processes to another host. Individual ranks
 * or entire hosts may be moved to another host.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminSwitchoverResponse& adminSwitchover( const AdminSwitchoverRequest& request_,
                                          AdminSwitchoverResponse& response_ ) const;

/**
 * Manually switch over one or more processes to another host. Individual ranks
 * or entire hosts may be moved to another host.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param processes  Indicates the process identifier to switch over to another
 *                   host. Options are
 *                   'hostN' and 'rankN' where 'N' corresponds to the number
 *                   associated with a host or rank in the
 *                   <a href="../../../config/#config-main-network"
 *                   target="_top">Network</a> section of the gpudb.conf file;
 *                   e.g.,
 *                   'host[N].address' or 'rank[N].host'. If 'hostN' is
 *                   provided, all processes on that host will be
 *                   moved to another host. Each entry in this array will be
 *                   switched over to the corresponding host
 *                   entry at the same index in @a destinations.
 * @param destinations  Indicates to which host to switch over each
 *                      corresponding process given in
 *                      @a processes. Each index must be specified as 'hostN'
 *                      where 'N' corresponds to the number
 *                      associated with a host or rank in the <a
 *                      href="../../../config/#config-main-network"
 *                      target="_top">Network</a> section of the
 *                      gpudb.conf file; e.g., 'host[N].address'. Each entry in
 *                      this array will receive the corresponding
 *                      process entry at the same index in @a processes.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_switchover_dry_run: If set to @a
 *                 true, only validation checks will be performed. Nothing is
 *                 switched over.
 *                 <ul>
 *                         <li> gpudb::admin_switchover_true
 *                         <li> gpudb::admin_switchover_false
 *                 </ul>
 *                 The default value is gpudb::admin_switchover_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminSwitchoverResponse adminSwitchover( const std::vector<std::string>& processes,
                                         const std::vector<std::string>& destinations,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Manually switch over one or more processes to another host. Individual ranks
 * or entire hosts may be moved to another host.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param processes  Indicates the process identifier to switch over to another
 *                   host. Options are
 *                   'hostN' and 'rankN' where 'N' corresponds to the number
 *                   associated with a host or rank in the
 *                   <a href="../../../config/#config-main-network"
 *                   target="_top">Network</a> section of the gpudb.conf file;
 *                   e.g.,
 *                   'host[N].address' or 'rank[N].host'. If 'hostN' is
 *                   provided, all processes on that host will be
 *                   moved to another host. Each entry in this array will be
 *                   switched over to the corresponding host
 *                   entry at the same index in @a destinations.
 * @param destinations  Indicates to which host to switch over each
 *                      corresponding process given in
 *                      @a processes. Each index must be specified as 'hostN'
 *                      where 'N' corresponds to the number
 *                      associated with a host or rank in the <a
 *                      href="../../../config/#config-main-network"
 *                      target="_top">Network</a> section of the
 *                      gpudb.conf file; e.g., 'host[N].address'. Each entry in
 *                      this array will receive the corresponding
 *                      process entry at the same index in @a processes.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_switchover_dry_run: If set to @a
 *                 true, only validation checks will be performed. Nothing is
 *                 switched over.
 *                 <ul>
 *                         <li> gpudb::admin_switchover_true
 *                         <li> gpudb::admin_switchover_false
 *                 </ul>
 *                 The default value is gpudb::admin_switchover_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminSwitchoverResponse& adminSwitchover( const std::vector<std::string>& processes,
                                          const std::vector<std::string>& destinations,
                                          const std::map<std::string, std::string>& options,
                                          AdminSwitchoverResponse& response_ ) const;

/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminVerifyDbResponse adminVerifyDb( const AdminVerifyDbRequest& request_ ) const;

/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminVerifyDbResponse& adminVerifyDb( const AdminVerifyDbRequest& request_,
                                      AdminVerifyDbResponse& response_ ) const;

/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_rebuild_on_error:
 *                 [DEPRECATED -- Use the Rebuild DB feature of GAdmin
 *                 instead.]
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li> gpudb::admin_verify_db_verify_nulls: When @a
 *                 true, verifies that null values are set to zero
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li> gpudb::admin_verify_db_verify_persist: When @a
 *                 true, persistent objects will be compared against their
 *                 state in memory and workers will be checked for orphaned
 *                 table data in persist. To check for orphaned worker data,
 *                 either set @a concurrent_safe in @a options to @a true or
 *                 place the database offline.
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li> gpudb::admin_verify_db_concurrent_safe: When @a
 *                 true, allows this endpoint to be run safely with other
 *                 concurrent database operations. Other operations may be
 *                 slower while this is running.
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_true.
 *                         <li> gpudb::admin_verify_db_verify_rank0: If @a
 *                 true, compare rank0 table metadata against workers' metadata
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li> gpudb::admin_verify_db_delete_orphaned_tables:
 *                 If @a true, orphaned table directories found on workers for
 *                 which there is no corresponding metadata will be deleted.
 *                 Must set @a verify_persist in @a options to @a true. It is
 *                 recommended to run this while the database is offline OR set
 *                 @a concurrent_safe in @a options to @a true
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li>
 *                 gpudb::admin_verify_db_verify_orphaned_tables_only: If @a
 *                 true, only the presence of orphaned table directories will
 *                 be checked, all persistence checks will be skipped
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminVerifyDbResponse adminVerifyDb( const std::map<std::string, std::string>& options ) const;

/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_rebuild_on_error:
 *                 [DEPRECATED -- Use the Rebuild DB feature of GAdmin
 *                 instead.]
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li> gpudb::admin_verify_db_verify_nulls: When @a
 *                 true, verifies that null values are set to zero
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li> gpudb::admin_verify_db_verify_persist: When @a
 *                 true, persistent objects will be compared against their
 *                 state in memory and workers will be checked for orphaned
 *                 table data in persist. To check for orphaned worker data,
 *                 either set @a concurrent_safe in @a options to @a true or
 *                 place the database offline.
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li> gpudb::admin_verify_db_concurrent_safe: When @a
 *                 true, allows this endpoint to be run safely with other
 *                 concurrent database operations. Other operations may be
 *                 slower while this is running.
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_true.
 *                         <li> gpudb::admin_verify_db_verify_rank0: If @a
 *                 true, compare rank0 table metadata against workers' metadata
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li> gpudb::admin_verify_db_delete_orphaned_tables:
 *                 If @a true, orphaned table directories found on workers for
 *                 which there is no corresponding metadata will be deleted.
 *                 Must set @a verify_persist in @a options to @a true. It is
 *                 recommended to run this while the database is offline OR set
 *                 @a concurrent_safe in @a options to @a true
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li>
 *                 gpudb::admin_verify_db_verify_orphaned_tables_only: If @a
 *                 true, only the presence of orphaned table directories will
 *                 be checked, all persistence checks will be skipped
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminVerifyDbResponse& adminVerifyDb( const std::map<std::string, std::string>& options,
                                      AdminVerifyDbResponse& response_ ) const;

/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateConvexHullResponse aggregateConvexHull( const AggregateConvexHullRequest& request_ ) const;

/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateConvexHullResponse& aggregateConvexHull( const AggregateConvexHullRequest& request_,
                                                  AggregateConvexHullResponse& response_ ) const;

/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param tableName  Name of table on which the operation will be performed.
 *                   Must be an existing table, in [schema_name.]table_name
 *                   format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param xColumnName  Name of the column containing the x coordinates of the
 *                     points for the operation being performed.
 * @param yColumnName  Name of the column containing the y coordinates of the
 *                     points for the operation being performed.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateConvexHullResponse aggregateConvexHull( const std::string& tableName,
                                                 const std::string& xColumnName,
                                                 const std::string& yColumnName,
                                                 const std::map<std::string, std::string>& options ) const;

/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param tableName  Name of table on which the operation will be performed.
 *                   Must be an existing table, in [schema_name.]table_name
 *                   format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param xColumnName  Name of the column containing the x coordinates of the
 *                     points for the operation being performed.
 * @param yColumnName  Name of the column containing the y coordinates of the
 *                     points for the operation being performed.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateConvexHullResponse& aggregateConvexHull( const std::string& tableName,
                                                  const std::string& xColumnName,
                                                  const std::string& yColumnName,
                                                  const std::map<std::string, std::string>& options,
                                                  AggregateConvexHullResponse& response_ ) const;

/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table or view and computes aggregates on each unique combination. This
 * is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * <p>
 * For aggregation details and examples, see <a
 * href="../../../concepts/aggregation/" target="_top">Aggregation</a>.  For
 * limitations, see <a href="../../../concepts/aggregation/#limitations"
 * target="_top">Aggregation Limitations</a>.
 * <p>
 * Any column(s) can be grouped on, and all column types except
 * unrestricted-length strings may be used for computing applicable aggregates;
 * columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a> are unable to be used in grouping or
 * aggregation.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by columns 'x' and 'y' and compute the number of objects within
 * each group, use:  column_names=['x','y','count(*)'].
 * <p>
 * To also compute the sum of 'z' over each group, use:
 * column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available <a href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> are: count(*), sum, min, max, avg,
 * mean, stddev, stddev_pop, stddev_samp, var, var_pop, var_samp, arg_min,
 * arg_max and count_distinct.
 * <p>
 * Available grouping functions are <a href="../../../concepts/rollup/"
 * target="_top">Rollup</a>, <a href="../../../concepts/cube/"
 * target="_top">Cube</a>, and <a href="../../../concepts/grouping_sets/"
 * target="_top">Grouping Sets</a>
 * <p>
 * This service also provides support for <a href="../../../concepts/pivot/"
 * target="_top">Pivot</a> operations.
 * <p>
 * Filtering on aggregates is supported via expressions using <a
 * href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> supplied to @a having.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column names must adhere to <a
 * href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>; column/aggregation expressions will need to be aliased.  If
 * the source table's <a href="../../../concepts/tables/#shard-keys"
 * target="_top">shard key</a> is used as the grouping column(s) and all result
 * records are selected (@a offset is 0 and @a limit is -9999), the result
 * table will be sharded, in all other cases it will be replicated.  Sorting
 * will properly function only if the result table is replicated or if there is
 * only one processing node and should not be relied upon in other cases.  Not
 * available when any of the values of @a columnNames is an unrestricted-length
 * string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawAggregateGroupByResponse aggregateGroupByRaw( const AggregateGroupByRequest& request_ ) const;

/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table or view and computes aggregates on each unique combination. This
 * is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * <p>
 * For aggregation details and examples, see <a
 * href="../../../concepts/aggregation/" target="_top">Aggregation</a>.  For
 * limitations, see <a href="../../../concepts/aggregation/#limitations"
 * target="_top">Aggregation Limitations</a>.
 * <p>
 * Any column(s) can be grouped on, and all column types except
 * unrestricted-length strings may be used for computing applicable aggregates;
 * columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a> are unable to be used in grouping or
 * aggregation.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by columns 'x' and 'y' and compute the number of objects within
 * each group, use:  column_names=['x','y','count(*)'].
 * <p>
 * To also compute the sum of 'z' over each group, use:
 * column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available <a href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> are: count(*), sum, min, max, avg,
 * mean, stddev, stddev_pop, stddev_samp, var, var_pop, var_samp, arg_min,
 * arg_max and count_distinct.
 * <p>
 * Available grouping functions are <a href="../../../concepts/rollup/"
 * target="_top">Rollup</a>, <a href="../../../concepts/cube/"
 * target="_top">Cube</a>, and <a href="../../../concepts/grouping_sets/"
 * target="_top">Grouping Sets</a>
 * <p>
 * This service also provides support for <a href="../../../concepts/pivot/"
 * target="_top">Pivot</a> operations.
 * <p>
 * Filtering on aggregates is supported via expressions using <a
 * href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> supplied to @a having.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column names must adhere to <a
 * href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>; column/aggregation expressions will need to be aliased.  If
 * the source table's <a href="../../../concepts/tables/#shard-keys"
 * target="_top">shard key</a> is used as the grouping column(s) and all result
 * records are selected (@a offset is 0 and @a limit is -9999), the result
 * table will be sharded, in all other cases it will be replicated.  Sorting
 * will properly function only if the result table is replicated or if there is
 * only one processing node and should not be relied upon in other cases.  Not
 * available when any of the values of @a columnNames is an unrestricted-length
 * string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawAggregateGroupByResponse& aggregateGroupByRaw( const AggregateGroupByRequest& request_,
                                                  RawAggregateGroupByResponse& response_ ) const;

/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table or view and computes aggregates on each unique combination. This
 * is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * <p>
 * For aggregation details and examples, see <a
 * href="../../../concepts/aggregation/" target="_top">Aggregation</a>.  For
 * limitations, see <a href="../../../concepts/aggregation/#limitations"
 * target="_top">Aggregation Limitations</a>.
 * <p>
 * Any column(s) can be grouped on, and all column types except
 * unrestricted-length strings may be used for computing applicable aggregates;
 * columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a> are unable to be used in grouping or
 * aggregation.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by columns 'x' and 'y' and compute the number of objects within
 * each group, use:  column_names=['x','y','count(*)'].
 * <p>
 * To also compute the sum of 'z' over each group, use:
 * column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available <a href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> are: count(*), sum, min, max, avg,
 * mean, stddev, stddev_pop, stddev_samp, var, var_pop, var_samp, arg_min,
 * arg_max and count_distinct.
 * <p>
 * Available grouping functions are <a href="../../../concepts/rollup/"
 * target="_top">Rollup</a>, <a href="../../../concepts/cube/"
 * target="_top">Cube</a>, and <a href="../../../concepts/grouping_sets/"
 * target="_top">Grouping Sets</a>
 * <p>
 * This service also provides support for <a href="../../../concepts/pivot/"
 * target="_top">Pivot</a> operations.
 * <p>
 * Filtering on aggregates is supported via expressions using <a
 * href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> supplied to @a having.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column names must adhere to <a
 * href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>; column/aggregation expressions will need to be aliased.  If
 * the source table's <a href="../../../concepts/tables/#shard-keys"
 * target="_top">shard key</a> is used as the grouping column(s) and all result
 * records are selected (@a offset is 0 and @a limit is -9999), the result
 * table will be sharded, in all other cases it will be replicated.  Sorting
 * will properly function only if the result table is replicated or if there is
 * only one processing node and should not be relied upon in other cases.  Not
 * available when any of the values of @a columnNames is an unrestricted-length
 * string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateGroupByResponse aggregateGroupBy( const AggregateGroupByRequest& request_ ) const;

/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table or view and computes aggregates on each unique combination. This
 * is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * <p>
 * For aggregation details and examples, see <a
 * href="../../../concepts/aggregation/" target="_top">Aggregation</a>.  For
 * limitations, see <a href="../../../concepts/aggregation/#limitations"
 * target="_top">Aggregation Limitations</a>.
 * <p>
 * Any column(s) can be grouped on, and all column types except
 * unrestricted-length strings may be used for computing applicable aggregates;
 * columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a> are unable to be used in grouping or
 * aggregation.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by columns 'x' and 'y' and compute the number of objects within
 * each group, use:  column_names=['x','y','count(*)'].
 * <p>
 * To also compute the sum of 'z' over each group, use:
 * column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available <a href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> are: count(*), sum, min, max, avg,
 * mean, stddev, stddev_pop, stddev_samp, var, var_pop, var_samp, arg_min,
 * arg_max and count_distinct.
 * <p>
 * Available grouping functions are <a href="../../../concepts/rollup/"
 * target="_top">Rollup</a>, <a href="../../../concepts/cube/"
 * target="_top">Cube</a>, and <a href="../../../concepts/grouping_sets/"
 * target="_top">Grouping Sets</a>
 * <p>
 * This service also provides support for <a href="../../../concepts/pivot/"
 * target="_top">Pivot</a> operations.
 * <p>
 * Filtering on aggregates is supported via expressions using <a
 * href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> supplied to @a having.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column names must adhere to <a
 * href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>; column/aggregation expressions will need to be aliased.  If
 * the source table's <a href="../../../concepts/tables/#shard-keys"
 * target="_top">shard key</a> is used as the grouping column(s) and all result
 * records are selected (@a offset is 0 and @a limit is -9999), the result
 * table will be sharded, in all other cases it will be replicated.  Sorting
 * will properly function only if the result table is replicated or if there is
 * only one processing node and should not be relied upon in other cases.  Not
 * available when any of the values of @a columnNames is an unrestricted-length
 * string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateGroupByResponse& aggregateGroupBy( const AggregateGroupByRequest& request_,
                                            AggregateGroupByResponse& response_ ) const;

/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table or view and computes aggregates on each unique combination. This
 * is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * <p>
 * For aggregation details and examples, see <a
 * href="../../../concepts/aggregation/" target="_top">Aggregation</a>.  For
 * limitations, see <a href="../../../concepts/aggregation/#limitations"
 * target="_top">Aggregation Limitations</a>.
 * <p>
 * Any column(s) can be grouped on, and all column types except
 * unrestricted-length strings may be used for computing applicable aggregates;
 * columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a> are unable to be used in grouping or
 * aggregation.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by columns 'x' and 'y' and compute the number of objects within
 * each group, use:  column_names=['x','y','count(*)'].
 * <p>
 * To also compute the sum of 'z' over each group, use:
 * column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available <a href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> are: count(*), sum, min, max, avg,
 * mean, stddev, stddev_pop, stddev_samp, var, var_pop, var_samp, arg_min,
 * arg_max and count_distinct.
 * <p>
 * Available grouping functions are <a href="../../../concepts/rollup/"
 * target="_top">Rollup</a>, <a href="../../../concepts/cube/"
 * target="_top">Cube</a>, and <a href="../../../concepts/grouping_sets/"
 * target="_top">Grouping Sets</a>
 * <p>
 * This service also provides support for <a href="../../../concepts/pivot/"
 * target="_top">Pivot</a> operations.
 * <p>
 * Filtering on aggregates is supported via expressions using <a
 * href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> supplied to @a having.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column names must adhere to <a
 * href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>; column/aggregation expressions will need to be aliased.  If
 * the source table's <a href="../../../concepts/tables/#shard-keys"
 * target="_top">shard key</a> is used as the grouping column(s) and all result
 * records are selected (@a offset is 0 and @a limit is -9999), the result
 * table will be sharded, in all other cases it will be replicated.  Sorting
 * will properly function only if the result table is replicated or if there is
 * only one processing node and should not be relied upon in other cases.  Not
 * available when any of the values of @a columnNames is an unrestricted-length
 * string.
 * 
 * @param tableName  Name of an existing table or view on which the operation
 *                   will be performed, in [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnNames  List of one or more column names, expressions, and
 *                     aggregate expressions.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a hasMoreRecords to see if more records exist in the
 *               result to be fetched, and
 *               @a offset & @a limit to request subsequent pages of results.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a result_table. If
 *                 @a result_table_persist is @a false (or unspecified), then
 *                 this is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_result_table_name.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li> gpudb::aggregate_group_by_collection_name:
 *                 [DEPRECATED--please specify the containing schema as part of
 *                 @a result_table and use /create/schema to create the schema
 *                 if non-existent]  Name of a schema which is to contain the
 *                 table specified in @a result_table. If the schema provided
 *                 is non-existent, it will be automatically created.
 *                         <li> gpudb::aggregate_group_by_expression: Filter
 *                 expression to apply to the table prior to computing the
 *                 aggregate group by.
 *                         <li> gpudb::aggregate_group_by_having: Filter
 *                 expression to apply to the aggregated results.
 *                         <li> gpudb::aggregate_group_by_sort_order: String
 *                 indicating how the returned values should be sorted -
 *                 ascending or descending.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_ascending: Indicates
 *                 that the returned values should be sorted in ascending
 *                 order.
 *                         <li> gpudb::aggregate_group_by_descending: Indicates
 *                 that the returned values should be sorted in descending
 *                 order.
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_ascending.
 *                         <li> gpudb::aggregate_group_by_sort_by: String
 *                 determining how the results are sorted.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_key: Indicates that
 *                 the returned values should be sorted by key, which
 *                 corresponds to the grouping columns. If you have multiple
 *                 grouping columns (and are sorting by key), it will first
 *                 sort the first grouping column, then the second grouping
 *                 column, etc.
 *                         <li> gpudb::aggregate_group_by_value: Indicates that
 *                 the returned values should be sorted by value, which
 *                 corresponds to the aggregates. If you have multiple
 *                 aggregates (and are sorting by value), it will first sort by
 *                 the first aggregate, then the second aggregate, etc.
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_value.
 *                         <li> gpudb::aggregate_group_by_strategy_definition:
 *                 The <a href="../../../rm/concepts/#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns.
 *                         <li> gpudb::aggregate_group_by_result_table: The
 *                 name of a table used to store the results, in
 *                 [schema_name.]table_name format, using standard <a
 *                 href="../../../concepts/tables/#table-name-resolution"
 *                 target="_top">name resolution rules</a> and meeting <a
 *                 href="../../../concepts/tables/#table-naming-criteria"
 *                 target="_top">table naming criteria</a>.  Column names
 *                 (group-by and aggregate fields) need to be given aliases
 *                 e.g. ["FChar256 as fchar256", "sum(FDouble) as sfd"].  If
 *                 present, no results are returned in the response.  This
 *                 option is not available if one of the grouping attributes is
 *                 an unrestricted string (i.e.; not charN) type.
 *                         <li> gpudb::aggregate_group_by_result_table_persist:
 *                 If @a true, then the result table specified in @a
 *                 result_table will be persisted and will not expire unless a
 *                 @a ttl is specified.   If @a false, then the result table
 *                 will be an in-memory table and will expire unless a @a ttl
 *                 is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li>
 *                 gpudb::aggregate_group_by_result_table_force_replicated:
 *                 Force the result table to be replicated (ignores any
 *                 sharding). Must be used in combination with the @a
 *                 result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li>
 *                 gpudb::aggregate_group_by_result_table_generate_pk: If @a
 *                 true then set a primary key for the result table. Must be
 *                 used in combination with the @a result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li> gpudb::aggregate_group_by_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 table specified in @a result_table.
 *                         <li> gpudb::aggregate_group_by_chunk_size: Indicates
 *                 the number of records per chunk to be used for the result
 *                 table. Must be used in combination with the @a result_table
 *                 option.
 *                         <li> gpudb::aggregate_group_by_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the result table. Must be used in combination with the @a
 *                 result_table option.
 *                         <li> gpudb::aggregate_group_by_view_id: ID of view
 *                 of which the result table will be a member.  The default
 *                 value is ''.
 *                         <li> gpudb::aggregate_group_by_pivot: pivot column
 *                         <li> gpudb::aggregate_group_by_pivot_values: The
 *                 value list provided will become the column headers in the
 *                 output. Should be the values from the pivot_column.
 *                         <li> gpudb::aggregate_group_by_grouping_sets:
 *                 Customize the grouping attribute sets to compute the
 *                 aggregates. These sets can include ROLLUP or CUBE
 *                 operartors. The attribute sets should be enclosed in
 *                 paranthesis and can include composite attributes. All
 *                 attributes specified in the grouping sets must present in
 *                 the groupby attributes.
 *                         <li> gpudb::aggregate_group_by_rollup: This option
 *                 is used to specify the multilevel aggregates.
 *                         <li> gpudb::aggregate_group_by_cube: This option is
 *                 used to specify the multidimensional aggregates.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateGroupByResponse aggregateGroupBy( const std::string& tableName,
                                           const std::vector<std::string>& columnNames,
                                           const int64_t offset,
                                           const int64_t limit,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table or view and computes aggregates on each unique combination. This
 * is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * <p>
 * For aggregation details and examples, see <a
 * href="../../../concepts/aggregation/" target="_top">Aggregation</a>.  For
 * limitations, see <a href="../../../concepts/aggregation/#limitations"
 * target="_top">Aggregation Limitations</a>.
 * <p>
 * Any column(s) can be grouped on, and all column types except
 * unrestricted-length strings may be used for computing applicable aggregates;
 * columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a> are unable to be used in grouping or
 * aggregation.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by columns 'x' and 'y' and compute the number of objects within
 * each group, use:  column_names=['x','y','count(*)'].
 * <p>
 * To also compute the sum of 'z' over each group, use:
 * column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available <a href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> are: count(*), sum, min, max, avg,
 * mean, stddev, stddev_pop, stddev_samp, var, var_pop, var_samp, arg_min,
 * arg_max and count_distinct.
 * <p>
 * Available grouping functions are <a href="../../../concepts/rollup/"
 * target="_top">Rollup</a>, <a href="../../../concepts/cube/"
 * target="_top">Cube</a>, and <a href="../../../concepts/grouping_sets/"
 * target="_top">Grouping Sets</a>
 * <p>
 * This service also provides support for <a href="../../../concepts/pivot/"
 * target="_top">Pivot</a> operations.
 * <p>
 * Filtering on aggregates is supported via expressions using <a
 * href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> supplied to @a having.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column names must adhere to <a
 * href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>; column/aggregation expressions will need to be aliased.  If
 * the source table's <a href="../../../concepts/tables/#shard-keys"
 * target="_top">shard key</a> is used as the grouping column(s) and all result
 * records are selected (@a offset is 0 and @a limit is -9999), the result
 * table will be sharded, in all other cases it will be replicated.  Sorting
 * will properly function only if the result table is replicated or if there is
 * only one processing node and should not be relied upon in other cases.  Not
 * available when any of the values of @a columnNames is an unrestricted-length
 * string.
 * 
 * @param tableName  Name of an existing table or view on which the operation
 *                   will be performed, in [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnNames  List of one or more column names, expressions, and
 *                     aggregate expressions.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a hasMoreRecords to see if more records exist in the
 *               result to be fetched, and
 *               @a offset & @a limit to request subsequent pages of results.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a result_table. If
 *                 @a result_table_persist is @a false (or unspecified), then
 *                 this is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_result_table_name.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li> gpudb::aggregate_group_by_collection_name:
 *                 [DEPRECATED--please specify the containing schema as part of
 *                 @a result_table and use /create/schema to create the schema
 *                 if non-existent]  Name of a schema which is to contain the
 *                 table specified in @a result_table. If the schema provided
 *                 is non-existent, it will be automatically created.
 *                         <li> gpudb::aggregate_group_by_expression: Filter
 *                 expression to apply to the table prior to computing the
 *                 aggregate group by.
 *                         <li> gpudb::aggregate_group_by_having: Filter
 *                 expression to apply to the aggregated results.
 *                         <li> gpudb::aggregate_group_by_sort_order: String
 *                 indicating how the returned values should be sorted -
 *                 ascending or descending.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_ascending: Indicates
 *                 that the returned values should be sorted in ascending
 *                 order.
 *                         <li> gpudb::aggregate_group_by_descending: Indicates
 *                 that the returned values should be sorted in descending
 *                 order.
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_ascending.
 *                         <li> gpudb::aggregate_group_by_sort_by: String
 *                 determining how the results are sorted.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_key: Indicates that
 *                 the returned values should be sorted by key, which
 *                 corresponds to the grouping columns. If you have multiple
 *                 grouping columns (and are sorting by key), it will first
 *                 sort the first grouping column, then the second grouping
 *                 column, etc.
 *                         <li> gpudb::aggregate_group_by_value: Indicates that
 *                 the returned values should be sorted by value, which
 *                 corresponds to the aggregates. If you have multiple
 *                 aggregates (and are sorting by value), it will first sort by
 *                 the first aggregate, then the second aggregate, etc.
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_value.
 *                         <li> gpudb::aggregate_group_by_strategy_definition:
 *                 The <a href="../../../rm/concepts/#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns.
 *                         <li> gpudb::aggregate_group_by_result_table: The
 *                 name of a table used to store the results, in
 *                 [schema_name.]table_name format, using standard <a
 *                 href="../../../concepts/tables/#table-name-resolution"
 *                 target="_top">name resolution rules</a> and meeting <a
 *                 href="../../../concepts/tables/#table-naming-criteria"
 *                 target="_top">table naming criteria</a>.  Column names
 *                 (group-by and aggregate fields) need to be given aliases
 *                 e.g. ["FChar256 as fchar256", "sum(FDouble) as sfd"].  If
 *                 present, no results are returned in the response.  This
 *                 option is not available if one of the grouping attributes is
 *                 an unrestricted string (i.e.; not charN) type.
 *                         <li> gpudb::aggregate_group_by_result_table_persist:
 *                 If @a true, then the result table specified in @a
 *                 result_table will be persisted and will not expire unless a
 *                 @a ttl is specified.   If @a false, then the result table
 *                 will be an in-memory table and will expire unless a @a ttl
 *                 is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li>
 *                 gpudb::aggregate_group_by_result_table_force_replicated:
 *                 Force the result table to be replicated (ignores any
 *                 sharding). Must be used in combination with the @a
 *                 result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li>
 *                 gpudb::aggregate_group_by_result_table_generate_pk: If @a
 *                 true then set a primary key for the result table. Must be
 *                 used in combination with the @a result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li> gpudb::aggregate_group_by_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 table specified in @a result_table.
 *                         <li> gpudb::aggregate_group_by_chunk_size: Indicates
 *                 the number of records per chunk to be used for the result
 *                 table. Must be used in combination with the @a result_table
 *                 option.
 *                         <li> gpudb::aggregate_group_by_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the result table. Must be used in combination with the @a
 *                 result_table option.
 *                         <li> gpudb::aggregate_group_by_view_id: ID of view
 *                 of which the result table will be a member.  The default
 *                 value is ''.
 *                         <li> gpudb::aggregate_group_by_pivot: pivot column
 *                         <li> gpudb::aggregate_group_by_pivot_values: The
 *                 value list provided will become the column headers in the
 *                 output. Should be the values from the pivot_column.
 *                         <li> gpudb::aggregate_group_by_grouping_sets:
 *                 Customize the grouping attribute sets to compute the
 *                 aggregates. These sets can include ROLLUP or CUBE
 *                 operartors. The attribute sets should be enclosed in
 *                 paranthesis and can include composite attributes. All
 *                 attributes specified in the grouping sets must present in
 *                 the groupby attributes.
 *                         <li> gpudb::aggregate_group_by_rollup: This option
 *                 is used to specify the multilevel aggregates.
 *                         <li> gpudb::aggregate_group_by_cube: This option is
 *                 used to specify the multidimensional aggregates.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateGroupByResponse& aggregateGroupBy( const std::string& tableName,
                                            const std::vector<std::string>& columnNames,
                                            const int64_t offset,
                                            const int64_t limit,
                                            const std::map<std::string, std::string>& options,
                                            AggregateGroupByResponse& response_ ) const;

/**
 * Performs a histogram calculation given a table, a column, and an
 * interval function. The @a interval is used to produce bins of that size
 * and the result, computed over the records falling within each bin, is
 * returned.
 * For each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a
 * @a value_column.  In this latter case the sum of the
 * values corresponding to the @a value_column is used as the
 * result instead.  The total number of bins requested cannot exceed 10,000.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service a request that specifies a @a value_column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateHistogramResponse aggregateHistogram( const AggregateHistogramRequest& request_ ) const;

/**
 * Performs a histogram calculation given a table, a column, and an
 * interval function. The @a interval is used to produce bins of that size
 * and the result, computed over the records falling within each bin, is
 * returned.
 * For each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a
 * @a value_column.  In this latter case the sum of the
 * values corresponding to the @a value_column is used as the
 * result instead.  The total number of bins requested cannot exceed 10,000.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service a request that specifies a @a value_column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateHistogramResponse& aggregateHistogram( const AggregateHistogramRequest& request_,
                                                AggregateHistogramResponse& response_ ) const;

/**
 * Performs a histogram calculation given a table, a column, and an
 * interval function. The @a interval is used to produce bins of that size
 * and the result, computed over the records falling within each bin, is
 * returned.
 * For each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a
 * @a value_column.  In this latter case the sum of the
 * values corresponding to the @a value_column is used as the
 * result instead.  The total number of bins requested cannot exceed 10,000.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service a request that specifies a @a value_column.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnName  Name of a column or an expression of one or more column
 *                    names over which the histogram will be calculated.
 * @param start  Lower end value of the histogram interval, inclusive.
 * @param end  Upper end value of the histogram interval, inclusive.
 * @param interval  The size of each bin within the start and end parameters.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_histogram_value_column: The
 *                 name of the column to use when calculating the bin values
 *                 (values are summed).  The column must be a numerical type
 *                 (int, double, long, float).
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateHistogramResponse aggregateHistogram( const std::string& tableName,
                                               const std::string& columnName,
                                               const double start,
                                               const double end,
                                               const double interval,
                                               const std::map<std::string, std::string>& options ) const;

/**
 * Performs a histogram calculation given a table, a column, and an
 * interval function. The @a interval is used to produce bins of that size
 * and the result, computed over the records falling within each bin, is
 * returned.
 * For each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a
 * @a value_column.  In this latter case the sum of the
 * values corresponding to the @a value_column is used as the
 * result instead.  The total number of bins requested cannot exceed 10,000.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service a request that specifies a @a value_column.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnName  Name of a column or an expression of one or more column
 *                    names over which the histogram will be calculated.
 * @param start  Lower end value of the histogram interval, inclusive.
 * @param end  Upper end value of the histogram interval, inclusive.
 * @param interval  The size of each bin within the start and end parameters.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_histogram_value_column: The
 *                 name of the column to use when calculating the bin values
 *                 (values are summed).  The column must be a numerical type
 *                 (int, double, long, float).
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateHistogramResponse& aggregateHistogram( const std::string& tableName,
                                                const std::string& columnName,
                                                const double start,
                                                const double end,
                                                const double interval,
                                                const std::map<std::string, std::string>& options,
                                                AggregateHistogramResponse& response_ ) const;

/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm
 * that attempts to do k-means clustering.  An ideal k-means clustering
 * algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member
 * of the set to the nearest of the k points is minimized.  The k-means
 * algorithm
 * however does not necessarily produce such an ideal cluster.   It begins with
 * a
 * randomly selected set of k points and then refines the location of the
 * points
 * iteratively and settles to a local minimum.  Various parameters and options
 * are
 * provided to control the heuristic search.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service this request.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateKMeansResponse aggregateKMeans( const AggregateKMeansRequest& request_ ) const;

/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm
 * that attempts to do k-means clustering.  An ideal k-means clustering
 * algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member
 * of the set to the nearest of the k points is minimized.  The k-means
 * algorithm
 * however does not necessarily produce such an ideal cluster.   It begins with
 * a
 * randomly selected set of k points and then refines the location of the
 * points
 * iteratively and settles to a local minimum.  Various parameters and options
 * are
 * provided to control the heuristic search.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service this request.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateKMeansResponse& aggregateKMeans( const AggregateKMeansRequest& request_,
                                          AggregateKMeansResponse& response_ ) const;

/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm
 * that attempts to do k-means clustering.  An ideal k-means clustering
 * algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member
 * of the set to the nearest of the k points is minimized.  The k-means
 * algorithm
 * however does not necessarily produce such an ideal cluster.   It begins with
 * a
 * randomly selected set of k points and then refines the location of the
 * points
 * iteratively and settles to a local minimum.  Various parameters and options
 * are
 * provided to control the heuristic search.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service this request.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnNames  List of column names on which the operation would be
 *                     performed. If n columns are provided then each of the k
 *                     result points will have n dimensions corresponding to
 *                     the n columns.
 * @param k  The number of mean points to be determined by the algorithm.
 * @param tolerance  Stop iterating when the distances between successive
 *                   points is less than the given tolerance.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_k_means_whiten: When set to 1
 *                 each of the columns is first normalized by its stdv -
 *                 default is not to whiten.
 *                         <li> gpudb::aggregate_k_means_max_iters: Number of
 *                 times to try to hit the tolerance limit before giving up -
 *                 default is 10.
 *                         <li> gpudb::aggregate_k_means_num_tries: Number of
 *                 times to run the k-means algorithm with a different randomly
 *                 selected starting points - helps avoid local minimum.
 *                 Default is 1.
 *                         <li> gpudb::aggregate_k_means_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a result_table. If
 *                 @a result_table_persist is @a false (or unspecified), then
 *                 this is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_result_table_name.
 *                 <ul>
 *                         <li> gpudb::aggregate_k_means_true
 *                         <li> gpudb::aggregate_k_means_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_k_means_false.
 *                         <li> gpudb::aggregate_k_means_result_table: The name
 *                 of a table used to store the results, in
 *                 [schema_name.]table_name format, using standard <a
 *                 href="../../../concepts/tables/#table-name-resolution"
 *                 target="_top">name resolution rules</a> and meeting <a
 *                 href="../../../concepts/tables/#table-naming-criteria"
 *                 target="_top">table naming criteria</a>.  If this option is
 *                 specified, the results are not returned in the response.
 *                         <li> gpudb::aggregate_k_means_result_table_persist:
 *                 If @a true, then the result table specified in @a
 *                 result_table will be persisted and will not expire unless a
 *                 @a ttl is specified.   If @a false, then the result table
 *                 will be an in-memory table and will expire unless a @a ttl
 *                 is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::aggregate_k_means_true
 *                         <li> gpudb::aggregate_k_means_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_k_means_false.
 *                         <li> gpudb::aggregate_k_means_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 table specified in @a result_table.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateKMeansResponse aggregateKMeans( const std::string& tableName,
                                         const std::vector<std::string>& columnNames,
                                         const int32_t k,
                                         const double tolerance,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm
 * that attempts to do k-means clustering.  An ideal k-means clustering
 * algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member
 * of the set to the nearest of the k points is minimized.  The k-means
 * algorithm
 * however does not necessarily produce such an ideal cluster.   It begins with
 * a
 * randomly selected set of k points and then refines the location of the
 * points
 * iteratively and settles to a local minimum.  Various parameters and options
 * are
 * provided to control the heuristic search.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service this request.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnNames  List of column names on which the operation would be
 *                     performed. If n columns are provided then each of the k
 *                     result points will have n dimensions corresponding to
 *                     the n columns.
 * @param k  The number of mean points to be determined by the algorithm.
 * @param tolerance  Stop iterating when the distances between successive
 *                   points is less than the given tolerance.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_k_means_whiten: When set to 1
 *                 each of the columns is first normalized by its stdv -
 *                 default is not to whiten.
 *                         <li> gpudb::aggregate_k_means_max_iters: Number of
 *                 times to try to hit the tolerance limit before giving up -
 *                 default is 10.
 *                         <li> gpudb::aggregate_k_means_num_tries: Number of
 *                 times to run the k-means algorithm with a different randomly
 *                 selected starting points - helps avoid local minimum.
 *                 Default is 1.
 *                         <li> gpudb::aggregate_k_means_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a result_table. If
 *                 @a result_table_persist is @a false (or unspecified), then
 *                 this is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_result_table_name.
 *                 <ul>
 *                         <li> gpudb::aggregate_k_means_true
 *                         <li> gpudb::aggregate_k_means_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_k_means_false.
 *                         <li> gpudb::aggregate_k_means_result_table: The name
 *                 of a table used to store the results, in
 *                 [schema_name.]table_name format, using standard <a
 *                 href="../../../concepts/tables/#table-name-resolution"
 *                 target="_top">name resolution rules</a> and meeting <a
 *                 href="../../../concepts/tables/#table-naming-criteria"
 *                 target="_top">table naming criteria</a>.  If this option is
 *                 specified, the results are not returned in the response.
 *                         <li> gpudb::aggregate_k_means_result_table_persist:
 *                 If @a true, then the result table specified in @a
 *                 result_table will be persisted and will not expire unless a
 *                 @a ttl is specified.   If @a false, then the result table
 *                 will be an in-memory table and will expire unless a @a ttl
 *                 is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::aggregate_k_means_true
 *                         <li> gpudb::aggregate_k_means_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_k_means_false.
 *                         <li> gpudb::aggregate_k_means_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 table specified in @a result_table.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateKMeansResponse& aggregateKMeans( const std::string& tableName,
                                          const std::vector<std::string>& columnNames,
                                          const int32_t k,
                                          const double tolerance,
                                          const std::map<std::string, std::string>& options,
                                          AggregateKMeansResponse& response_ ) const;

/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateMinMaxResponse aggregateMinMax( const AggregateMinMaxRequest& request_ ) const;

/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateMinMaxResponse& aggregateMinMax( const AggregateMinMaxRequest& request_,
                                          AggregateMinMaxResponse& response_ ) const;

/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnName  Name of a column or an expression of one or more column
 *                    on which the min-max will be calculated.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateMinMaxResponse aggregateMinMax( const std::string& tableName,
                                         const std::string& columnName,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnName  Name of a column or an expression of one or more column
 *                    on which the min-max will be calculated.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateMinMaxResponse& aggregateMinMax( const std::string& tableName,
                                          const std::string& columnName,
                                          const std::map<std::string, std::string>& options,
                                          AggregateMinMaxResponse& response_ ) const;

/**
 * Calculates and returns the minimum and maximum x- and y-coordinates
 * of a particular geospatial geometry column in a table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateMinMaxGeometryResponse aggregateMinMaxGeometry( const AggregateMinMaxGeometryRequest& request_ ) const;

/**
 * Calculates and returns the minimum and maximum x- and y-coordinates
 * of a particular geospatial geometry column in a table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateMinMaxGeometryResponse& aggregateMinMaxGeometry( const AggregateMinMaxGeometryRequest& request_,
                                                          AggregateMinMaxGeometryResponse& response_ ) const;

/**
 * Calculates and returns the minimum and maximum x- and y-coordinates
 * of a particular geospatial geometry column in a table.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnName  Name of a geospatial geometry column on which the min-max
 *                    will be calculated.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateMinMaxGeometryResponse aggregateMinMaxGeometry( const std::string& tableName,
                                                         const std::string& columnName,
                                                         const std::map<std::string, std::string>& options ) const;

/**
 * Calculates and returns the minimum and maximum x- and y-coordinates
 * of a particular geospatial geometry column in a table.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnName  Name of a geospatial geometry column on which the min-max
 *                    will be calculated.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateMinMaxGeometryResponse& aggregateMinMaxGeometry( const std::string& tableName,
                                                          const std::string& columnName,
                                                          const std::map<std::string, std::string>& options,
                                                          AggregateMinMaxGeometryResponse& response_ ) const;

/**
 * Calculates the requested statistics of the given column(s) in a
 * given table.
 * <p>
 * The available statistics are:
 *   @a count (number of total objects),
 *   @a mean,
 *   @a stdv (standard deviation),
 *   @a variance,
 *   @a skew,
 *   @a kurtosis,
 *   @a sum,
 *   @a min,
 *   @a max,
 *   @a weighted_average,
 *   @a cardinality (unique count),
 *   @a estimated_cardinality,
 *   @a percentile, and
 *   @a percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile ranks are approximate and are calculated using
 * the
 * t-digest algorithm. They must include the desired
 * @a percentile/@a percentile_rank.
 * To compute multiple percentiles each value must be specified separately
 * (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * A second, comma-separated value can be added to the
 * @a percentile statistic to calculate percentile
 * resolution, e.g., a 50th percentile with 200 resolution would be
 * 'percentile(50,200)'.
 * <p>
 * The weighted average statistic requires a weight column to be specified in
 * @a weight_column_name.  The weighted average is then
 * defined as the sum of the products of @a columnName times the
 * @a weight_column_name values divided by the sum of the
 * @a weight_column_name values.
 * <p>
 * Additional columns can be used in the calculation of statistics via
 * @a additional_column_names.  Values in these columns will
 * be included in the overall aggregate calculation--individual aggregates will
 * not
 * be calculated per additional column.  For instance, requesting the
 * @a count & @a mean of
 * @a columnName x and @a additional_column_names
 * y & z, where x holds the numbers 1-10, y holds 11-20, and z holds 21-30,
 * would
 * return the total number of x, y, & z values (30), and the single average
 * value
 * across all x, y, & z values (15.5).
 * <p>
 * The response includes a list of key/value pairs of each statistic requested
 * and
 * its corresponding value.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsResponse aggregateStatistics( const AggregateStatisticsRequest& request_ ) const;

/**
 * Calculates the requested statistics of the given column(s) in a
 * given table.
 * <p>
 * The available statistics are:
 *   @a count (number of total objects),
 *   @a mean,
 *   @a stdv (standard deviation),
 *   @a variance,
 *   @a skew,
 *   @a kurtosis,
 *   @a sum,
 *   @a min,
 *   @a max,
 *   @a weighted_average,
 *   @a cardinality (unique count),
 *   @a estimated_cardinality,
 *   @a percentile, and
 *   @a percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile ranks are approximate and are calculated using
 * the
 * t-digest algorithm. They must include the desired
 * @a percentile/@a percentile_rank.
 * To compute multiple percentiles each value must be specified separately
 * (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * A second, comma-separated value can be added to the
 * @a percentile statistic to calculate percentile
 * resolution, e.g., a 50th percentile with 200 resolution would be
 * 'percentile(50,200)'.
 * <p>
 * The weighted average statistic requires a weight column to be specified in
 * @a weight_column_name.  The weighted average is then
 * defined as the sum of the products of @a columnName times the
 * @a weight_column_name values divided by the sum of the
 * @a weight_column_name values.
 * <p>
 * Additional columns can be used in the calculation of statistics via
 * @a additional_column_names.  Values in these columns will
 * be included in the overall aggregate calculation--individual aggregates will
 * not
 * be calculated per additional column.  For instance, requesting the
 * @a count & @a mean of
 * @a columnName x and @a additional_column_names
 * y & z, where x holds the numbers 1-10, y holds 11-20, and z holds 21-30,
 * would
 * return the total number of x, y, & z values (30), and the single average
 * value
 * across all x, y, & z values (15.5).
 * <p>
 * The response includes a list of key/value pairs of each statistic requested
 * and
 * its corresponding value.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsResponse& aggregateStatistics( const AggregateStatisticsRequest& request_,
                                                  AggregateStatisticsResponse& response_ ) const;

/**
 * Calculates the requested statistics of the given column(s) in a
 * given table.
 * <p>
 * The available statistics are:
 *   @a count (number of total objects),
 *   @a mean,
 *   @a stdv (standard deviation),
 *   @a variance,
 *   @a skew,
 *   @a kurtosis,
 *   @a sum,
 *   @a min,
 *   @a max,
 *   @a weighted_average,
 *   @a cardinality (unique count),
 *   @a estimated_cardinality,
 *   @a percentile, and
 *   @a percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile ranks are approximate and are calculated using
 * the
 * t-digest algorithm. They must include the desired
 * @a percentile/@a percentile_rank.
 * To compute multiple percentiles each value must be specified separately
 * (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * A second, comma-separated value can be added to the
 * @a percentile statistic to calculate percentile
 * resolution, e.g., a 50th percentile with 200 resolution would be
 * 'percentile(50,200)'.
 * <p>
 * The weighted average statistic requires a weight column to be specified in
 * @a weight_column_name.  The weighted average is then
 * defined as the sum of the products of @a columnName times the
 * @a weight_column_name values divided by the sum of the
 * @a weight_column_name values.
 * <p>
 * Additional columns can be used in the calculation of statistics via
 * @a additional_column_names.  Values in these columns will
 * be included in the overall aggregate calculation--individual aggregates will
 * not
 * be calculated per additional column.  For instance, requesting the
 * @a count & @a mean of
 * @a columnName x and @a additional_column_names
 * y & z, where x holds the numbers 1-10, y holds 11-20, and z holds 21-30,
 * would
 * return the total number of x, y, & z values (30), and the single average
 * value
 * across all x, y, & z values (15.5).
 * <p>
 * The response includes a list of key/value pairs of each statistic requested
 * and
 * its corresponding value.
 * 
 * @param tableName  Name of the table on which the statistics operation will
 *                   be performed, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnName  Name of the primary column for which the statistics are
 *                    to be calculated.
 * @param stats  Comma separated list of the statistics to calculate, e.g.
 *               "sum,mean".
 *               <ul>
 *                       <li> gpudb::aggregate_statistics_count: Number of
 *               objects (independent of the given column(s)).
 *                       <li> gpudb::aggregate_statistics_mean: Arithmetic mean
 *               (average), equivalent to sum/count.
 *                       <li> gpudb::aggregate_statistics_stdv: Sample standard
 *               deviation (denominator is count-1).
 *                       <li> gpudb::aggregate_statistics_variance: Unbiased
 *               sample variance (denominator is count-1).
 *                       <li> gpudb::aggregate_statistics_skew: Skewness (third
 *               standardized moment).
 *                       <li> gpudb::aggregate_statistics_kurtosis: Kurtosis
 *               (fourth standardized moment).
 *                       <li> gpudb::aggregate_statistics_sum: Sum of all
 *               values in the column(s).
 *                       <li> gpudb::aggregate_statistics_min: Minimum value of
 *               the column(s).
 *                       <li> gpudb::aggregate_statistics_max: Maximum value of
 *               the column(s).
 *                       <li> gpudb::aggregate_statistics_weighted_average:
 *               Weighted arithmetic mean (using the option @a
 *               weight_column_name as the weighting column).
 *                       <li> gpudb::aggregate_statistics_cardinality: Number
 *               of unique values in the column(s).
 *                       <li>
 *               gpudb::aggregate_statistics_estimated_cardinality: Estimate
 *               (via hyperloglog technique) of the number of unique values in
 *               the column(s).
 *                       <li> gpudb::aggregate_statistics_percentile: Estimate
 *               (via t-digest) of the given percentile of the column(s)
 *               (percentile(50.0) will be an approximation of the median). Add
 *               a second, comma-separated value to calculate percentile
 *               resolution, e.g., 'percentile(75,150)'
 *                       <li> gpudb::aggregate_statistics_percentile_rank:
 *               Estimate (via t-digest) of the percentile rank of the given
 *               value in the column(s) (if the given value is the median of
 *               the column(s), percentile_rank(<median>) will return
 *               approximately 50.0).
 *               </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::aggregate_statistics_additional_column_names: A list
 *                 of comma separated column names over which statistics can be
 *                 accumulated along with the primary column.  All columns
 *                 listed and @a columnName must be of the same type.  Must not
 *                 include the column specified in @a columnName and no column
 *                 can be listed twice.
 *                         <li> gpudb::aggregate_statistics_weight_column_name:
 *                 Name of column used as weighting attribute for the weighted
 *                 average statistic.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsResponse aggregateStatistics( const std::string& tableName,
                                                 const std::string& columnName,
                                                 const std::string& stats,
                                                 const std::map<std::string, std::string>& options ) const;

/**
 * Calculates the requested statistics of the given column(s) in a
 * given table.
 * <p>
 * The available statistics are:
 *   @a count (number of total objects),
 *   @a mean,
 *   @a stdv (standard deviation),
 *   @a variance,
 *   @a skew,
 *   @a kurtosis,
 *   @a sum,
 *   @a min,
 *   @a max,
 *   @a weighted_average,
 *   @a cardinality (unique count),
 *   @a estimated_cardinality,
 *   @a percentile, and
 *   @a percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile ranks are approximate and are calculated using
 * the
 * t-digest algorithm. They must include the desired
 * @a percentile/@a percentile_rank.
 * To compute multiple percentiles each value must be specified separately
 * (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * A second, comma-separated value can be added to the
 * @a percentile statistic to calculate percentile
 * resolution, e.g., a 50th percentile with 200 resolution would be
 * 'percentile(50,200)'.
 * <p>
 * The weighted average statistic requires a weight column to be specified in
 * @a weight_column_name.  The weighted average is then
 * defined as the sum of the products of @a columnName times the
 * @a weight_column_name values divided by the sum of the
 * @a weight_column_name values.
 * <p>
 * Additional columns can be used in the calculation of statistics via
 * @a additional_column_names.  Values in these columns will
 * be included in the overall aggregate calculation--individual aggregates will
 * not
 * be calculated per additional column.  For instance, requesting the
 * @a count & @a mean of
 * @a columnName x and @a additional_column_names
 * y & z, where x holds the numbers 1-10, y holds 11-20, and z holds 21-30,
 * would
 * return the total number of x, y, & z values (30), and the single average
 * value
 * across all x, y, & z values (15.5).
 * <p>
 * The response includes a list of key/value pairs of each statistic requested
 * and
 * its corresponding value.
 * 
 * @param tableName  Name of the table on which the statistics operation will
 *                   be performed, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnName  Name of the primary column for which the statistics are
 *                    to be calculated.
 * @param stats  Comma separated list of the statistics to calculate, e.g.
 *               "sum,mean".
 *               <ul>
 *                       <li> gpudb::aggregate_statistics_count: Number of
 *               objects (independent of the given column(s)).
 *                       <li> gpudb::aggregate_statistics_mean: Arithmetic mean
 *               (average), equivalent to sum/count.
 *                       <li> gpudb::aggregate_statistics_stdv: Sample standard
 *               deviation (denominator is count-1).
 *                       <li> gpudb::aggregate_statistics_variance: Unbiased
 *               sample variance (denominator is count-1).
 *                       <li> gpudb::aggregate_statistics_skew: Skewness (third
 *               standardized moment).
 *                       <li> gpudb::aggregate_statistics_kurtosis: Kurtosis
 *               (fourth standardized moment).
 *                       <li> gpudb::aggregate_statistics_sum: Sum of all
 *               values in the column(s).
 *                       <li> gpudb::aggregate_statistics_min: Minimum value of
 *               the column(s).
 *                       <li> gpudb::aggregate_statistics_max: Maximum value of
 *               the column(s).
 *                       <li> gpudb::aggregate_statistics_weighted_average:
 *               Weighted arithmetic mean (using the option @a
 *               weight_column_name as the weighting column).
 *                       <li> gpudb::aggregate_statistics_cardinality: Number
 *               of unique values in the column(s).
 *                       <li>
 *               gpudb::aggregate_statistics_estimated_cardinality: Estimate
 *               (via hyperloglog technique) of the number of unique values in
 *               the column(s).
 *                       <li> gpudb::aggregate_statistics_percentile: Estimate
 *               (via t-digest) of the given percentile of the column(s)
 *               (percentile(50.0) will be an approximation of the median). Add
 *               a second, comma-separated value to calculate percentile
 *               resolution, e.g., 'percentile(75,150)'
 *                       <li> gpudb::aggregate_statistics_percentile_rank:
 *               Estimate (via t-digest) of the percentile rank of the given
 *               value in the column(s) (if the given value is the median of
 *               the column(s), percentile_rank(<median>) will return
 *               approximately 50.0).
 *               </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::aggregate_statistics_additional_column_names: A list
 *                 of comma separated column names over which statistics can be
 *                 accumulated along with the primary column.  All columns
 *                 listed and @a columnName must be of the same type.  Must not
 *                 include the column specified in @a columnName and no column
 *                 can be listed twice.
 *                         <li> gpudb::aggregate_statistics_weight_column_name:
 *                 Name of column used as weighting attribute for the weighted
 *                 average statistic.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsResponse& aggregateStatistics( const std::string& tableName,
                                                  const std::string& columnName,
                                                  const std::string& stats,
                                                  const std::map<std::string, std::string>& options,
                                                  AggregateStatisticsResponse& response_ ) const;

/**
 * Divides the given set into bins and calculates statistics of the
 * values of a value-column in each bin.  The bins are based on the values of a
 * given binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and
 * weighted average. In addition to the requested statistics the count of total
 * samples in each bin is returned. This counts vector is just the histogram of
 * the
 * column used to divide the set members into bins. The weighted average
 * statistic
 * requires a weight column to be specified in
 * @a weight_column_name. The weighted average is then
 * defined as the sum of the products of the value column times the weight
 * column
 * divided by the sum of the weight column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be
 * used for numeric valued binning-columns, a min, max and interval are
 * specified.
 * The number of bins, nbins, is the integer upper bound of (max-min)/interval.
 * Values that fall in the range [min+n*interval,min+(n+1)*interval) are placed
 * in
 * the nth bin where n ranges from 0..nbin-2. The final bin is
 * [min+(nbin-1)*interval,max]. In the second method,
 * @a bin_values specifies a list of binning column values.
 * Binning-columns whose value matches the nth member of the
 * @a bin_values list are placed in the nth bin. When a list
 * is provided, the binning-column must be of type string or int.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service this request.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsByRangeResponse aggregateStatisticsByRange( const AggregateStatisticsByRangeRequest& request_ ) const;

/**
 * Divides the given set into bins and calculates statistics of the
 * values of a value-column in each bin.  The bins are based on the values of a
 * given binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and
 * weighted average. In addition to the requested statistics the count of total
 * samples in each bin is returned. This counts vector is just the histogram of
 * the
 * column used to divide the set members into bins. The weighted average
 * statistic
 * requires a weight column to be specified in
 * @a weight_column_name. The weighted average is then
 * defined as the sum of the products of the value column times the weight
 * column
 * divided by the sum of the weight column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be
 * used for numeric valued binning-columns, a min, max and interval are
 * specified.
 * The number of bins, nbins, is the integer upper bound of (max-min)/interval.
 * Values that fall in the range [min+n*interval,min+(n+1)*interval) are placed
 * in
 * the nth bin where n ranges from 0..nbin-2. The final bin is
 * [min+(nbin-1)*interval,max]. In the second method,
 * @a bin_values specifies a list of binning column values.
 * Binning-columns whose value matches the nth member of the
 * @a bin_values list are placed in the nth bin. When a list
 * is provided, the binning-column must be of type string or int.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service this request.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsByRangeResponse& aggregateStatisticsByRange( const AggregateStatisticsByRangeRequest& request_,
                                                                AggregateStatisticsByRangeResponse& response_ ) const;

/**
 * Divides the given set into bins and calculates statistics of the
 * values of a value-column in each bin.  The bins are based on the values of a
 * given binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and
 * weighted average. In addition to the requested statistics the count of total
 * samples in each bin is returned. This counts vector is just the histogram of
 * the
 * column used to divide the set members into bins. The weighted average
 * statistic
 * requires a weight column to be specified in
 * @a weight_column_name. The weighted average is then
 * defined as the sum of the products of the value column times the weight
 * column
 * divided by the sum of the weight column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be
 * used for numeric valued binning-columns, a min, max and interval are
 * specified.
 * The number of bins, nbins, is the integer upper bound of (max-min)/interval.
 * Values that fall in the range [min+n*interval,min+(n+1)*interval) are placed
 * in
 * the nth bin where n ranges from 0..nbin-2. The final bin is
 * [min+(nbin-1)*interval,max]. In the second method,
 * @a bin_values specifies a list of binning column values.
 * Binning-columns whose value matches the nth member of the
 * @a bin_values list are placed in the nth bin. When a list
 * is provided, the binning-column must be of type string or int.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service this request.
 * 
 * @param tableName  Name of the table on which the ranged-statistics operation
 *                   will be performed, in [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param selectExpression  For a non-empty expression statistics are
 *                          calculated for those records for which the
 *                          expression is true.
 * @param columnName  Name of the binning-column used to divide the set samples
 *                    into bins.
 * @param valueColumnName  Name of the value-column for which statistics are to
 *                         be computed.
 * @param stats  A string of comma separated list of the statistics to
 *               calculate, e.g. 'sum,mean'. Available statistics: mean, stdv
 *               (standard deviation), variance, skew, kurtosis, sum.
 * @param start  The lower bound of the binning-column.
 * @param end  The upper bound of the binning-column.
 * @param interval  The interval of a bin. Set members fall into bin i if the
 *                  binning-column falls in the range [start+interval*i,
 *                  start+interval*(i+1)).
 * @param options  Map of optional parameters:
 *                 <ul>
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_additional_column_names:
 *                 A list of comma separated value-column names over which
 *                 statistics can be accumulated along with the primary
 *                 value_column.
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_bin_values: A list of
 *                 comma separated binning-column values. Values that match the
 *                 nth bin_values value are placed in the nth bin.
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_weight_column_name:
 *                 Name of the column used as weighting column for the
 *                 weighted_average statistic.
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_order_column_name: Name
 *                 of the column used for candlestick charting techniques.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsByRangeResponse aggregateStatisticsByRange( const std::string& tableName,
                                                               const std::string& selectExpression,
                                                               const std::string& columnName,
                                                               const std::string& valueColumnName,
                                                               const std::string& stats,
                                                               const double start,
                                                               const double end,
                                                               const double interval,
                                                               const std::map<std::string, std::string>& options ) const;

/**
 * Divides the given set into bins and calculates statistics of the
 * values of a value-column in each bin.  The bins are based on the values of a
 * given binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and
 * weighted average. In addition to the requested statistics the count of total
 * samples in each bin is returned. This counts vector is just the histogram of
 * the
 * column used to divide the set members into bins. The weighted average
 * statistic
 * requires a weight column to be specified in
 * @a weight_column_name. The weighted average is then
 * defined as the sum of the products of the value column times the weight
 * column
 * divided by the sum of the weight column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be
 * used for numeric valued binning-columns, a min, max and interval are
 * specified.
 * The number of bins, nbins, is the integer upper bound of (max-min)/interval.
 * Values that fall in the range [min+n*interval,min+(n+1)*interval) are placed
 * in
 * the nth bin where n ranges from 0..nbin-2. The final bin is
 * [min+(nbin-1)*interval,max]. In the second method,
 * @a bin_values specifies a list of binning column values.
 * Binning-columns whose value matches the nth member of the
 * @a bin_values list are placed in the nth bin. When a list
 * is provided, the binning-column must be of type string or int.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service this request.
 * 
 * @param tableName  Name of the table on which the ranged-statistics operation
 *                   will be performed, in [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param selectExpression  For a non-empty expression statistics are
 *                          calculated for those records for which the
 *                          expression is true.
 * @param columnName  Name of the binning-column used to divide the set samples
 *                    into bins.
 * @param valueColumnName  Name of the value-column for which statistics are to
 *                         be computed.
 * @param stats  A string of comma separated list of the statistics to
 *               calculate, e.g. 'sum,mean'. Available statistics: mean, stdv
 *               (standard deviation), variance, skew, kurtosis, sum.
 * @param start  The lower bound of the binning-column.
 * @param end  The upper bound of the binning-column.
 * @param interval  The interval of a bin. Set members fall into bin i if the
 *                  binning-column falls in the range [start+interval*i,
 *                  start+interval*(i+1)).
 * @param options  Map of optional parameters:
 *                 <ul>
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_additional_column_names:
 *                 A list of comma separated value-column names over which
 *                 statistics can be accumulated along with the primary
 *                 value_column.
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_bin_values: A list of
 *                 comma separated binning-column values. Values that match the
 *                 nth bin_values value are placed in the nth bin.
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_weight_column_name:
 *                 Name of the column used as weighting column for the
 *                 weighted_average statistic.
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_order_column_name: Name
 *                 of the column used for candlestick charting techniques.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsByRangeResponse& aggregateStatisticsByRange( const std::string& tableName,
                                                                const std::string& selectExpression,
                                                                const std::string& columnName,
                                                                const std::string& valueColumnName,
                                                                const std::string& stats,
                                                                const double start,
                                                                const double end,
                                                                const double interval,
                                                                const std::map<std::string, std::string>& options,
                                                                AggregateStatisticsByRangeResponse& response_ ) const;

/**
 * Returns all the unique values from a particular column
 * (specified by @a columnName) of a particular table or view
 * (specified by @a tableName). If @a columnName is a numeric column,
 * the values will be in @a binaryEncodedResponse. Otherwise if
 * @a columnName is a string column, the values will be in
 * @a jsonEncodedResponse.  The results can be paged via @a offset
 * and @a limit parameters.
 * <p>
 * Columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a>
 * are unable to be used with this function.
 * <p>
 * To get the first 10 unique values sorted in descending order @a options
 * would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * <p>
 * If a @a result_table name is specified in the
 * @a options, the results are stored in a new table with that name--no
 * results are returned in the response.  Both the table name and resulting
 * column
 * name must adhere to
 * <a href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>;
 * any column expression will need to be aliased.  If the source table's
 * <a href="../../../concepts/tables/#shard-keys" target="_top">shard key</a>
 * is used as the
 * @a columnName, the result table will be sharded, in all other cases it
 * will be replicated.  Sorting will properly function only if the result table
 * is
 * replicated or if there is only one processing node and should not be relied
 * upon
 * in other cases.  Not available if the value of @a columnName is an
 * unrestricted-length string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawAggregateUniqueResponse aggregateUniqueRaw( const AggregateUniqueRequest& request_ ) const;

/**
 * Returns all the unique values from a particular column
 * (specified by @a columnName) of a particular table or view
 * (specified by @a tableName). If @a columnName is a numeric column,
 * the values will be in @a binaryEncodedResponse. Otherwise if
 * @a columnName is a string column, the values will be in
 * @a jsonEncodedResponse.  The results can be paged via @a offset
 * and @a limit parameters.
 * <p>
 * Columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a>
 * are unable to be used with this function.
 * <p>
 * To get the first 10 unique values sorted in descending order @a options
 * would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * <p>
 * If a @a result_table name is specified in the
 * @a options, the results are stored in a new table with that name--no
 * results are returned in the response.  Both the table name and resulting
 * column
 * name must adhere to
 * <a href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>;
 * any column expression will need to be aliased.  If the source table's
 * <a href="../../../concepts/tables/#shard-keys" target="_top">shard key</a>
 * is used as the
 * @a columnName, the result table will be sharded, in all other cases it
 * will be replicated.  Sorting will properly function only if the result table
 * is
 * replicated or if there is only one processing node and should not be relied
 * upon
 * in other cases.  Not available if the value of @a columnName is an
 * unrestricted-length string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawAggregateUniqueResponse& aggregateUniqueRaw( const AggregateUniqueRequest& request_,
                                                RawAggregateUniqueResponse& response_ ) const;

/**
 * Returns all the unique values from a particular column
 * (specified by @a columnName) of a particular table or view
 * (specified by @a tableName). If @a columnName is a numeric column,
 * the values will be in @a binaryEncodedResponse. Otherwise if
 * @a columnName is a string column, the values will be in
 * @a jsonEncodedResponse.  The results can be paged via @a offset
 * and @a limit parameters.
 * <p>
 * Columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a>
 * are unable to be used with this function.
 * <p>
 * To get the first 10 unique values sorted in descending order @a options
 * would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * <p>
 * If a @a result_table name is specified in the
 * @a options, the results are stored in a new table with that name--no
 * results are returned in the response.  Both the table name and resulting
 * column
 * name must adhere to
 * <a href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>;
 * any column expression will need to be aliased.  If the source table's
 * <a href="../../../concepts/tables/#shard-keys" target="_top">shard key</a>
 * is used as the
 * @a columnName, the result table will be sharded, in all other cases it
 * will be replicated.  Sorting will properly function only if the result table
 * is
 * replicated or if there is only one processing node and should not be relied
 * upon
 * in other cases.  Not available if the value of @a columnName is an
 * unrestricted-length string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateUniqueResponse aggregateUnique( const AggregateUniqueRequest& request_ ) const;

/**
 * Returns all the unique values from a particular column
 * (specified by @a columnName) of a particular table or view
 * (specified by @a tableName). If @a columnName is a numeric column,
 * the values will be in @a binaryEncodedResponse. Otherwise if
 * @a columnName is a string column, the values will be in
 * @a jsonEncodedResponse.  The results can be paged via @a offset
 * and @a limit parameters.
 * <p>
 * Columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a>
 * are unable to be used with this function.
 * <p>
 * To get the first 10 unique values sorted in descending order @a options
 * would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * <p>
 * If a @a result_table name is specified in the
 * @a options, the results are stored in a new table with that name--no
 * results are returned in the response.  Both the table name and resulting
 * column
 * name must adhere to
 * <a href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>;
 * any column expression will need to be aliased.  If the source table's
 * <a href="../../../concepts/tables/#shard-keys" target="_top">shard key</a>
 * is used as the
 * @a columnName, the result table will be sharded, in all other cases it
 * will be replicated.  Sorting will properly function only if the result table
 * is
 * replicated or if there is only one processing node and should not be relied
 * upon
 * in other cases.  Not available if the value of @a columnName is an
 * unrestricted-length string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateUniqueResponse& aggregateUnique( const AggregateUniqueRequest& request_,
                                          AggregateUniqueResponse& response_ ) const;

/**
 * Returns all the unique values from a particular column
 * (specified by @a columnName) of a particular table or view
 * (specified by @a tableName). If @a columnName is a numeric column,
 * the values will be in @a binaryEncodedResponse. Otherwise if
 * @a columnName is a string column, the values will be in
 * @a jsonEncodedResponse.  The results can be paged via @a offset
 * and @a limit parameters.
 * <p>
 * Columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a>
 * are unable to be used with this function.
 * <p>
 * To get the first 10 unique values sorted in descending order @a options
 * would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * <p>
 * If a @a result_table name is specified in the
 * @a options, the results are stored in a new table with that name--no
 * results are returned in the response.  Both the table name and resulting
 * column
 * name must adhere to
 * <a href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>;
 * any column expression will need to be aliased.  If the source table's
 * <a href="../../../concepts/tables/#shard-keys" target="_top">shard key</a>
 * is used as the
 * @a columnName, the result table will be sharded, in all other cases it
 * will be replicated.  Sorting will properly function only if the result table
 * is
 * replicated or if there is only one processing node and should not be relied
 * upon
 * in other cases.  Not available if the value of @a columnName is an
 * unrestricted-length string.
 * 
 * @param tableName  Name of an existing table or view on which the operation
 *                   will be performed, in [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnName  Name of the column or an expression containing one or
 *                    more column names on which the unique function would be
 *                    applied.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a hasMoreRecords to see if more records exist in the
 *               result to be fetched, and
 *               @a offset & @a limit to request subsequent pages of results.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a result_table. If
 *                 @a result_table_persist is @a false (or unspecified), then
 *                 this is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_result_table_name.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_true
 *                         <li> gpudb::aggregate_unique_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_false.
 *                         <li> gpudb::aggregate_unique_collection_name:
 *                 [DEPRECATED--please specify the containing schema as part of
 *                 @a result_table and use /create/schema to create the schema
 *                 if non-existent]  Name of a schema which is to contain the
 *                 table specified in @a result_table. If the schema provided
 *                 is non-existent, it will be automatically created.
 *                         <li> gpudb::aggregate_unique_expression: Optional
 *                 filter expression to apply to the table.
 *                         <li> gpudb::aggregate_unique_sort_order: String
 *                 indicating how the returned values should be sorted.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_ascending
 *                         <li> gpudb::aggregate_unique_descending
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_ascending.
 *                         <li> gpudb::aggregate_unique_result_table: The name
 *                 of the table used to store the results, in
 *                 [schema_name.]table_name format, using standard <a
 *                 href="../../../concepts/tables/#table-name-resolution"
 *                 target="_top">name resolution rules</a> and meeting <a
 *                 href="../../../concepts/tables/#table-naming-criteria"
 *                 target="_top">table naming criteria</a>.  If present, no
 *                 results are returned in the response.  Not available if @a
 *                 columnName is an unrestricted-length string.
 *                         <li> gpudb::aggregate_unique_result_table_persist:
 *                 If @a true, then the result table specified in @a
 *                 result_table will be persisted and will not expire unless a
 *                 @a ttl is specified.   If @a false, then the result table
 *                 will be an in-memory table and will expire unless a @a ttl
 *                 is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_true
 *                         <li> gpudb::aggregate_unique_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_false.
 *                         <li>
 *                 gpudb::aggregate_unique_result_table_force_replicated: Force
 *                 the result table to be replicated (ignores any sharding).
 *                 Must be used in combination with the @a result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_true
 *                         <li> gpudb::aggregate_unique_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_false.
 *                         <li>
 *                 gpudb::aggregate_unique_result_table_generate_pk: If @a true
 *                 then set a primary key for the result table. Must be used in
 *                 combination with the @a result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_true
 *                         <li> gpudb::aggregate_unique_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_false.
 *                         <li> gpudb::aggregate_unique_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 table specified in @a result_table.
 *                         <li> gpudb::aggregate_unique_chunk_size: Indicates
 *                 the number of records per chunk to be used for the result
 *                 table. Must be used in combination with the @a result_table
 *                 option.
 *                         <li> gpudb::aggregate_unique_view_id: ID of view of
 *                 which the result table will be a member.  The default value
 *                 is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateUniqueResponse aggregateUnique( const std::string& tableName,
                                         const std::string& columnName,
                                         const int64_t offset,
                                         const int64_t limit,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Returns all the unique values from a particular column
 * (specified by @a columnName) of a particular table or view
 * (specified by @a tableName). If @a columnName is a numeric column,
 * the values will be in @a binaryEncodedResponse. Otherwise if
 * @a columnName is a string column, the values will be in
 * @a jsonEncodedResponse.  The results can be paged via @a offset
 * and @a limit parameters.
 * <p>
 * Columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a>
 * are unable to be used with this function.
 * <p>
 * To get the first 10 unique values sorted in descending order @a options
 * would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * <p>
 * If a @a result_table name is specified in the
 * @a options, the results are stored in a new table with that name--no
 * results are returned in the response.  Both the table name and resulting
 * column
 * name must adhere to
 * <a href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>;
 * any column expression will need to be aliased.  If the source table's
 * <a href="../../../concepts/tables/#shard-keys" target="_top">shard key</a>
 * is used as the
 * @a columnName, the result table will be sharded, in all other cases it
 * will be replicated.  Sorting will properly function only if the result table
 * is
 * replicated or if there is only one processing node and should not be relied
 * upon
 * in other cases.  Not available if the value of @a columnName is an
 * unrestricted-length string.
 * 
 * @param tableName  Name of an existing table or view on which the operation
 *                   will be performed, in [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnName  Name of the column or an expression containing one or
 *                    more column names on which the unique function would be
 *                    applied.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a hasMoreRecords to see if more records exist in the
 *               result to be fetched, and
 *               @a offset & @a limit to request subsequent pages of results.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a result_table. If
 *                 @a result_table_persist is @a false (or unspecified), then
 *                 this is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_result_table_name.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_true
 *                         <li> gpudb::aggregate_unique_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_false.
 *                         <li> gpudb::aggregate_unique_collection_name:
 *                 [DEPRECATED--please specify the containing schema as part of
 *                 @a result_table and use /create/schema to create the schema
 *                 if non-existent]  Name of a schema which is to contain the
 *                 table specified in @a result_table. If the schema provided
 *                 is non-existent, it will be automatically created.
 *                         <li> gpudb::aggregate_unique_expression: Optional
 *                 filter expression to apply to the table.
 *                         <li> gpudb::aggregate_unique_sort_order: String
 *                 indicating how the returned values should be sorted.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_ascending
 *                         <li> gpudb::aggregate_unique_descending
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_ascending.
 *                         <li> gpudb::aggregate_unique_result_table: The name
 *                 of the table used to store the results, in
 *                 [schema_name.]table_name format, using standard <a
 *                 href="../../../concepts/tables/#table-name-resolution"
 *                 target="_top">name resolution rules</a> and meeting <a
 *                 href="../../../concepts/tables/#table-naming-criteria"
 *                 target="_top">table naming criteria</a>.  If present, no
 *                 results are returned in the response.  Not available if @a
 *                 columnName is an unrestricted-length string.
 *                         <li> gpudb::aggregate_unique_result_table_persist:
 *                 If @a true, then the result table specified in @a
 *                 result_table will be persisted and will not expire unless a
 *                 @a ttl is specified.   If @a false, then the result table
 *                 will be an in-memory table and will expire unless a @a ttl
 *                 is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_true
 *                         <li> gpudb::aggregate_unique_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_false.
 *                         <li>
 *                 gpudb::aggregate_unique_result_table_force_replicated: Force
 *                 the result table to be replicated (ignores any sharding).
 *                 Must be used in combination with the @a result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_true
 *                         <li> gpudb::aggregate_unique_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_false.
 *                         <li>
 *                 gpudb::aggregate_unique_result_table_generate_pk: If @a true
 *                 then set a primary key for the result table. Must be used in
 *                 combination with the @a result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_true
 *                         <li> gpudb::aggregate_unique_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_false.
 *                         <li> gpudb::aggregate_unique_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 table specified in @a result_table.
 *                         <li> gpudb::aggregate_unique_chunk_size: Indicates
 *                 the number of records per chunk to be used for the result
 *                 table. Must be used in combination with the @a result_table
 *                 option.
 *                         <li> gpudb::aggregate_unique_view_id: ID of view of
 *                 which the result table will be a member.  The default value
 *                 is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateUniqueResponse& aggregateUnique( const std::string& tableName,
                                          const std::string& columnName,
                                          const int64_t offset,
                                          const int64_t limit,
                                          const std::map<std::string, std::string>& options,
                                          AggregateUniqueResponse& response_ ) const;

/**
 * Rotate the column values into rows values.
 * <p>
 * For unpivot details and examples, see
 * <a href="../../../concepts/unpivot/" target="_top">Unpivot</a>.  For
 * limitations, see
 * <a href="../../../concepts/unpivot/#limitations" target="_top">Unpivot
 * Limitations</a>.
 * <p>
 * Unpivot is used to normalize tables that are built for cross tabular
 * reporting
 * purposes. The unpivot operator rotates the column values for all the pivoted
 * columns. A variable column, value column and all columns from the source
 * table
 * except the unpivot columns are projected into the result table. The variable
 * column and value columns in the result table indicate the pivoted column
 * name
 * and values respectively.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawAggregateUnpivotResponse aggregateUnpivotRaw( const AggregateUnpivotRequest& request_ ) const;

/**
 * Rotate the column values into rows values.
 * <p>
 * For unpivot details and examples, see
 * <a href="../../../concepts/unpivot/" target="_top">Unpivot</a>.  For
 * limitations, see
 * <a href="../../../concepts/unpivot/#limitations" target="_top">Unpivot
 * Limitations</a>.
 * <p>
 * Unpivot is used to normalize tables that are built for cross tabular
 * reporting
 * purposes. The unpivot operator rotates the column values for all the pivoted
 * columns. A variable column, value column and all columns from the source
 * table
 * except the unpivot columns are projected into the result table. The variable
 * column and value columns in the result table indicate the pivoted column
 * name
 * and values respectively.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawAggregateUnpivotResponse& aggregateUnpivotRaw( const AggregateUnpivotRequest& request_,
                                                  RawAggregateUnpivotResponse& response_ ) const;

/**
 * Rotate the column values into rows values.
 * <p>
 * For unpivot details and examples, see
 * <a href="../../../concepts/unpivot/" target="_top">Unpivot</a>.  For
 * limitations, see
 * <a href="../../../concepts/unpivot/#limitations" target="_top">Unpivot
 * Limitations</a>.
 * <p>
 * Unpivot is used to normalize tables that are built for cross tabular
 * reporting
 * purposes. The unpivot operator rotates the column values for all the pivoted
 * columns. A variable column, value column and all columns from the source
 * table
 * except the unpivot columns are projected into the result table. The variable
 * column and value columns in the result table indicate the pivoted column
 * name
 * and values respectively.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateUnpivotResponse aggregateUnpivot( const AggregateUnpivotRequest& request_ ) const;

/**
 * Rotate the column values into rows values.
 * <p>
 * For unpivot details and examples, see
 * <a href="../../../concepts/unpivot/" target="_top">Unpivot</a>.  For
 * limitations, see
 * <a href="../../../concepts/unpivot/#limitations" target="_top">Unpivot
 * Limitations</a>.
 * <p>
 * Unpivot is used to normalize tables that are built for cross tabular
 * reporting
 * purposes. The unpivot operator rotates the column values for all the pivoted
 * columns. A variable column, value column and all columns from the source
 * table
 * except the unpivot columns are projected into the result table. The variable
 * column and value columns in the result table indicate the pivoted column
 * name
 * and values respectively.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateUnpivotResponse& aggregateUnpivot( const AggregateUnpivotRequest& request_,
                                            AggregateUnpivotResponse& response_ ) const;

/**
 * Rotate the column values into rows values.
 * <p>
 * For unpivot details and examples, see
 * <a href="../../../concepts/unpivot/" target="_top">Unpivot</a>.  For
 * limitations, see
 * <a href="../../../concepts/unpivot/#limitations" target="_top">Unpivot
 * Limitations</a>.
 * <p>
 * Unpivot is used to normalize tables that are built for cross tabular
 * reporting
 * purposes. The unpivot operator rotates the column values for all the pivoted
 * columns. A variable column, value column and all columns from the source
 * table
 * except the unpivot columns are projected into the result table. The variable
 * column and value columns in the result table indicate the pivoted column
 * name
 * and values respectively.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table/view, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnNames  List of column names or expressions. A wildcard '*' can
 *                     be used to include all the non-pivoted columns from the
 *                     source table.
 * @param variableColumnName  Specifies the variable/parameter column name.
 * @param valueColumnName  Specifies the value column name.
 * @param pivotedColumns  List of one or more values typically the column names
 *                        of the input table. All the columns in the source
 *                        table must have the same data type.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a result_table. If
 *                 @a result_table_persist is @a false (or unspecified), then
 *                 this is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_result_table_name.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_true
 *                         <li> gpudb::aggregate_unpivot_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unpivot_false.
 *                         <li> gpudb::aggregate_unpivot_collection_name:
 *                 [DEPRECATED--please specify the containing schema as part of
 *                 @a result_table and use /create/schema to create the schema
 *                 if non-existent]  Name of a schema which is to contain the
 *                 table specified in @a result_table. If the schema is
 *                 non-existent, it will be automatically created.
 *                         <li> gpudb::aggregate_unpivot_result_table: The name
 *                 of a table used to store the results, in
 *                 [schema_name.]table_name format, using standard <a
 *                 href="../../../concepts/tables/#table-name-resolution"
 *                 target="_top">name resolution rules</a> and meeting <a
 *                 href="../../../concepts/tables/#table-naming-criteria"
 *                 target="_top">table naming criteria</a>. If present, no
 *                 results are returned in the response.
 *                         <li> gpudb::aggregate_unpivot_result_table_persist:
 *                 If @a true, then the result table specified in @a
 *                 result_table will be persisted and will not expire unless a
 *                 @a ttl is specified.   If @a false, then the result table
 *                 will be an in-memory table and will expire unless a @a ttl
 *                 is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_true
 *                         <li> gpudb::aggregate_unpivot_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unpivot_false.
 *                         <li> gpudb::aggregate_unpivot_expression: Filter
 *                 expression to apply to the table prior to unpivot
 *                 processing.
 *                         <li> gpudb::aggregate_unpivot_order_by:
 *                 Comma-separated list of the columns to be sorted by; e.g.
 *                 'timestamp asc, x desc'.  The columns specified must be
 *                 present in input table.  If any alias is given for any
 *                 column name, the alias must be used, rather than the
 *                 original column name.  The default value is ''.
 *                         <li> gpudb::aggregate_unpivot_chunk_size: Indicates
 *                 the number of records per chunk to be used for the result
 *                 table. Must be used in combination with the @a result_table
 *                 option.
 *                         <li> gpudb::aggregate_unpivot_limit: The number of
 *                 records to keep.  The default value is ''.
 *                         <li> gpudb::aggregate_unpivot_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 table specified in @a result_table.
 *                         <li> gpudb::aggregate_unpivot_view_id: view this
 *                 result table is part of.  The default value is ''.
 *                         <li> gpudb::aggregate_unpivot_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the table specified in @a result_table. The columns
 *                 specified must be present in output column names.  If any
 *                 alias is given for any column name, the alias must be used,
 *                 rather than the original column name.
 *                         <li>
 *                 gpudb::aggregate_unpivot_result_table_force_replicated:
 *                 Force the result table to be replicated (ignores any
 *                 sharding). Must be used in combination with the @a
 *                 result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_true
 *                         <li> gpudb::aggregate_unpivot_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unpivot_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateUnpivotResponse aggregateUnpivot( const std::string& tableName,
                                           const std::vector<std::string>& columnNames,
                                           const std::string& variableColumnName,
                                           const std::string& valueColumnName,
                                           const std::vector<std::string>& pivotedColumns,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * Rotate the column values into rows values.
 * <p>
 * For unpivot details and examples, see
 * <a href="../../../concepts/unpivot/" target="_top">Unpivot</a>.  For
 * limitations, see
 * <a href="../../../concepts/unpivot/#limitations" target="_top">Unpivot
 * Limitations</a>.
 * <p>
 * Unpivot is used to normalize tables that are built for cross tabular
 * reporting
 * purposes. The unpivot operator rotates the column values for all the pivoted
 * columns. A variable column, value column and all columns from the source
 * table
 * except the unpivot columns are projected into the result table. The variable
 * column and value columns in the result table indicate the pivoted column
 * name
 * and values respectively.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table/view, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnNames  List of column names or expressions. A wildcard '*' can
 *                     be used to include all the non-pivoted columns from the
 *                     source table.
 * @param variableColumnName  Specifies the variable/parameter column name.
 * @param valueColumnName  Specifies the value column name.
 * @param pivotedColumns  List of one or more values typically the column names
 *                        of the input table. All the columns in the source
 *                        table must have the same data type.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a result_table. If
 *                 @a result_table_persist is @a false (or unspecified), then
 *                 this is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_result_table_name.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_true
 *                         <li> gpudb::aggregate_unpivot_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unpivot_false.
 *                         <li> gpudb::aggregate_unpivot_collection_name:
 *                 [DEPRECATED--please specify the containing schema as part of
 *                 @a result_table and use /create/schema to create the schema
 *                 if non-existent]  Name of a schema which is to contain the
 *                 table specified in @a result_table. If the schema is
 *                 non-existent, it will be automatically created.
 *                         <li> gpudb::aggregate_unpivot_result_table: The name
 *                 of a table used to store the results, in
 *                 [schema_name.]table_name format, using standard <a
 *                 href="../../../concepts/tables/#table-name-resolution"
 *                 target="_top">name resolution rules</a> and meeting <a
 *                 href="../../../concepts/tables/#table-naming-criteria"
 *                 target="_top">table naming criteria</a>. If present, no
 *                 results are returned in the response.
 *                         <li> gpudb::aggregate_unpivot_result_table_persist:
 *                 If @a true, then the result table specified in @a
 *                 result_table will be persisted and will not expire unless a
 *                 @a ttl is specified.   If @a false, then the result table
 *                 will be an in-memory table and will expire unless a @a ttl
 *                 is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_true
 *                         <li> gpudb::aggregate_unpivot_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unpivot_false.
 *                         <li> gpudb::aggregate_unpivot_expression: Filter
 *                 expression to apply to the table prior to unpivot
 *                 processing.
 *                         <li> gpudb::aggregate_unpivot_order_by:
 *                 Comma-separated list of the columns to be sorted by; e.g.
 *                 'timestamp asc, x desc'.  The columns specified must be
 *                 present in input table.  If any alias is given for any
 *                 column name, the alias must be used, rather than the
 *                 original column name.  The default value is ''.
 *                         <li> gpudb::aggregate_unpivot_chunk_size: Indicates
 *                 the number of records per chunk to be used for the result
 *                 table. Must be used in combination with the @a result_table
 *                 option.
 *                         <li> gpudb::aggregate_unpivot_limit: The number of
 *                 records to keep.  The default value is ''.
 *                         <li> gpudb::aggregate_unpivot_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 table specified in @a result_table.
 *                         <li> gpudb::aggregate_unpivot_view_id: view this
 *                 result table is part of.  The default value is ''.
 *                         <li> gpudb::aggregate_unpivot_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the table specified in @a result_table. The columns
 *                 specified must be present in output column names.  If any
 *                 alias is given for any column name, the alias must be used,
 *                 rather than the original column name.
 *                         <li>
 *                 gpudb::aggregate_unpivot_result_table_force_replicated:
 *                 Force the result table to be replicated (ignores any
 *                 sharding). Must be used in combination with the @a
 *                 result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_true
 *                         <li> gpudb::aggregate_unpivot_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unpivot_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateUnpivotResponse& aggregateUnpivot( const std::string& tableName,
                                            const std::vector<std::string>& columnNames,
                                            const std::string& variableColumnName,
                                            const std::string& valueColumnName,
                                            const std::vector<std::string>& pivotedColumns,
                                            const std::map<std::string, std::string>& options,
                                            AggregateUnpivotResponse& response_ ) const;

/**
 * Alter the properties of an existing <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterCredentialResponse alterCredential( const AlterCredentialRequest& request_ ) const;

/**
 * Alter the properties of an existing <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterCredentialResponse& alterCredential( const AlterCredentialRequest& request_,
                                          AlterCredentialResponse& response_ ) const;

/**
 * Alter the properties of an existing <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 * 
 * @param credentialName  Name of the credential to be altered. Must be an
 *                        existing credential.
 * @param credentialUpdatesMap  Map containing the properties of the credential
 *                              to be updated. Error if empty.
 *                              <ul>
 *                                      <li> gpudb::alter_credential_type: New
 *                              type for the credential.
 *                              <ul>
 *                                      <li>
 *                              gpudb::alter_credential_aws_access_key
 *                                      <li>
 *                              gpudb::alter_credential_aws_iam_role
 *                                      <li> gpudb::alter_credential_azure_ad
 *                                      <li>
 *                              gpudb::alter_credential_azure_oauth
 *                                      <li> gpudb::alter_credential_azure_sas
 *                                      <li>
 *                              gpudb::alter_credential_azure_storage_key
 *                                      <li> gpudb::alter_credential_docker
 *                                      <li>
 *                              gpudb::alter_credential_gcs_service_account_id
 *                                      <li>
 *                              gpudb::alter_credential_gcs_service_account_keys
 *                                      <li> gpudb::alter_credential_hdfs
 *                                      <li> gpudb::alter_credential_kafka
 *                              </ul>
 *                                      <li> gpudb::alter_credential_identity:
 *                              New user for the credential
 *                                      <li> gpudb::alter_credential_secret:
 *                              New password for the credential
 *                                      <li>
 *                              gpudb::alter_credential_schema_name: Updates
 *                              the schema name.  If @a schema_name
 *                              doesn't exist, an error will be thrown. If @a
 *                              schema_name is empty, then the user's
 *                              default schema will be used.
 *                              </ul>
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterCredentialResponse alterCredential( const std::string& credentialName,
                                         const std::map<std::string, std::string>& credentialUpdatesMap,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Alter the properties of an existing <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 * 
 * @param credentialName  Name of the credential to be altered. Must be an
 *                        existing credential.
 * @param credentialUpdatesMap  Map containing the properties of the credential
 *                              to be updated. Error if empty.
 *                              <ul>
 *                                      <li> gpudb::alter_credential_type: New
 *                              type for the credential.
 *                              <ul>
 *                                      <li>
 *                              gpudb::alter_credential_aws_access_key
 *                                      <li>
 *                              gpudb::alter_credential_aws_iam_role
 *                                      <li> gpudb::alter_credential_azure_ad
 *                                      <li>
 *                              gpudb::alter_credential_azure_oauth
 *                                      <li> gpudb::alter_credential_azure_sas
 *                                      <li>
 *                              gpudb::alter_credential_azure_storage_key
 *                                      <li> gpudb::alter_credential_docker
 *                                      <li>
 *                              gpudb::alter_credential_gcs_service_account_id
 *                                      <li>
 *                              gpudb::alter_credential_gcs_service_account_keys
 *                                      <li> gpudb::alter_credential_hdfs
 *                                      <li> gpudb::alter_credential_kafka
 *                              </ul>
 *                                      <li> gpudb::alter_credential_identity:
 *                              New user for the credential
 *                                      <li> gpudb::alter_credential_secret:
 *                              New password for the credential
 *                                      <li>
 *                              gpudb::alter_credential_schema_name: Updates
 *                              the schema name.  If @a schema_name
 *                              doesn't exist, an error will be thrown. If @a
 *                              schema_name is empty, then the user's
 *                              default schema will be used.
 *                              </ul>
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterCredentialResponse& alterCredential( const std::string& credentialName,
                                          const std::map<std::string, std::string>& credentialUpdatesMap,
                                          const std::map<std::string, std::string>& options,
                                          AlterCredentialResponse& response_ ) const;

/**
 * Alters the properties of an existing <a href="../../../concepts/data_sinks/"
 * target="_top">data sink</a>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterDatasinkResponse alterDatasink( const AlterDatasinkRequest& request_ ) const;

/**
 * Alters the properties of an existing <a href="../../../concepts/data_sinks/"
 * target="_top">data sink</a>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterDatasinkResponse& alterDatasink( const AlterDatasinkRequest& request_,
                                      AlterDatasinkResponse& response_ ) const;

/**
 * Alters the properties of an existing <a href="../../../concepts/data_sinks/"
 * target="_top">data sink</a>
 * 
 * @param name  Name of the data sink to be altered. Must be an existing data
 *              sink.
 * @param datasinkUpdatesMap  Map containing the properties of the data sink to
 *                            be updated. Error if empty.
 *                            <ul>
 *                                    <li> gpudb::alter_datasink_destination:
 *                            Destination for the output data in format
 *                            'destination_type://path[:port]'.
 *                            Supported destination types are 'http', 'https'
 *                            and 'kafka'.
 *                                    <li>
 *                            gpudb::alter_datasink_connection_timeout: Timeout
 *                            in seconds for connecting to this sink
 *                                    <li> gpudb::alter_datasink_wait_timeout:
 *                            Timeout in seconds for waiting for a response
 *                            from this sink
 *                                    <li> gpudb::alter_datasink_credential:
 *                            Name of the <a
 *                            href="../../../concepts/credentials/"
 *                            target="_top">credential</a> object to be used in
 *                            this data sink
 *                                    <li>
 *                            gpudb::alter_datasink_s3_bucket_name: Name of the
 *                            Amazon S3 bucket to use as the data sink
 *                                    <li> gpudb::alter_datasink_s3_region:
 *                            Name of the Amazon S3 region where the given
 *                            bucket is located
 *                                    <li>
 *                            gpudb::alter_datasink_s3_aws_role_arn: Amazon IAM
 *                            Role ARN which has required S3 permissions that
 *                            can be assumed for the given S3 IAM user
 *                                    <li>
 *                            gpudb::alter_datasink_hdfs_kerberos_keytab:
 *                            Kerberos keytab file location for the given HDFS
 *                            user.  This may be a KIFS file.
 *                                    <li>
 *                            gpudb::alter_datasink_hdfs_delegation_token:
 *                            Delegation token for the given HDFS user
 *                                    <li>
 *                            gpudb::alter_datasink_hdfs_use_kerberos: Use
 *                            kerberos authentication for the given HDFS
 *                            cluster
 *                            <ul>
 *                                    <li> gpudb::alter_datasink_true
 *                                    <li> gpudb::alter_datasink_false
 *                            </ul>
 *                            The default value is gpudb::alter_datasink_false.
 *                                    <li>
 *                            gpudb::alter_datasink_azure_storage_account_name:
 *                            Name of the Azure storage account to use as the
 *                            data sink, this is valid only if tenant_id is
 *                            specified
 *                                    <li>
 *                            gpudb::alter_datasink_azure_container_name: Name
 *                            of the Azure storage container to use as the data
 *                            sink
 *                                    <li>
 *                            gpudb::alter_datasink_azure_tenant_id: Active
 *                            Directory tenant ID (or directory ID)
 *                                    <li>
 *                            gpudb::alter_datasink_azure_sas_token: Shared
 *                            access signature token for Azure storage account
 *                            to use as the data sink
 *                                    <li>
 *                            gpudb::alter_datasink_azure_oauth_token: Oauth
 *                            token to access given storage container
 *                                    <li>
 *                            gpudb::alter_datasink_gcs_bucket_name: Name of
 *                            the Google Cloud Storage bucket to use as the
 *                            data sink
 *                                    <li>
 *                            gpudb::alter_datasink_gcs_project_id: Name of the
 *                            Google Cloud project to use as the data sink
 *                                    <li>
 *                            gpudb::alter_datasink_gcs_service_account_keys:
 *                            Google Cloud service account keys to use for
 *                            authenticating the data sink
 *                                    <li> gpudb::alter_datasink_kafka_url: The
 *                            publicly-accessible full path URL to the kafka
 *                            broker, e.g., 'http://172.123.45.67:9300'.
 *                                    <li>
 *                            gpudb::alter_datasink_kafka_topic_name: Name of
 *                            the Kafka topic to use for this data sink, if it
 *                            references a Kafka broker
 *                                    <li> gpudb::alter_datasink_anonymous:
 *                            Create an anonymous connection to the storage
 *                            provider--DEPRECATED: this is now the default.
 *                            Specify use_managed_credentials for non-anonymous
 *                            connection
 *                            <ul>
 *                                    <li> gpudb::alter_datasink_true
 *                                    <li> gpudb::alter_datasink_false
 *                            </ul>
 *                            The default value is gpudb::alter_datasink_true.
 *                                    <li>
 *                            gpudb::alter_datasink_use_managed_credentials:
 *                            When no credentials are supplied, we use
 *                            anonymous access by default.  If this is set, we
 *                            will use cloud provider user settings.
 *                            <ul>
 *                                    <li> gpudb::alter_datasink_true
 *                                    <li> gpudb::alter_datasink_false
 *                            </ul>
 *                            The default value is gpudb::alter_datasink_false.
 *                                    <li> gpudb::alter_datasink_use_https: Use
 *                            https to connect to datasink if true, otherwise
 *                            use http
 *                            <ul>
 *                                    <li> gpudb::alter_datasink_true
 *                                    <li> gpudb::alter_datasink_false
 *                            </ul>
 *                            The default value is gpudb::alter_datasink_true.
 *                                    <li>
 *                            gpudb::alter_datasink_max_batch_size: Maximum
 *                            number of records per notification message.  The
 *                            default value is '1'.
 *                                    <li>
 *                            gpudb::alter_datasink_max_message_size: Maximum
 *                            size in bytes of each notification message.  The
 *                            default value is '1000000'.
 *                                    <li> gpudb::alter_datasink_json_format:
 *                            The desired format of JSON encoded notifications
 *                            message.
 *                            If @a nested, records are returned as an array.
 *                            Otherwise, only a single record per messages is
 *                            returned.
 *                            <ul>
 *                                    <li> gpudb::alter_datasink_flat
 *                                    <li> gpudb::alter_datasink_nested
 *                            </ul>
 *                            The default value is gpudb::alter_datasink_flat.
 *                                    <li>
 *                            gpudb::alter_datasink_skip_validation: Bypass
 *                            validation of connection to this data sink.
 *                            <ul>
 *                                    <li> gpudb::alter_datasink_true
 *                                    <li> gpudb::alter_datasink_false
 *                            </ul>
 *                            The default value is gpudb::alter_datasink_false.
 *                                    <li> gpudb::alter_datasink_schema_name:
 *                            Updates the schema name.  If @a schema_name
 *                            doesn't exist, an error will be thrown. If @a
 *                            schema_name is empty, then the user's
 *                            default schema will be used.
 *                            </ul>
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterDatasinkResponse alterDatasink( const std::string& name,
                                     const std::map<std::string, std::string>& datasinkUpdatesMap,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Alters the properties of an existing <a href="../../../concepts/data_sinks/"
 * target="_top">data sink</a>
 * 
 * @param name  Name of the data sink to be altered. Must be an existing data
 *              sink.
 * @param datasinkUpdatesMap  Map containing the properties of the data sink to
 *                            be updated. Error if empty.
 *                            <ul>
 *                                    <li> gpudb::alter_datasink_destination:
 *                            Destination for the output data in format
 *                            'destination_type://path[:port]'.
 *                            Supported destination types are 'http', 'https'
 *                            and 'kafka'.
 *                                    <li>
 *                            gpudb::alter_datasink_connection_timeout: Timeout
 *                            in seconds for connecting to this sink
 *                                    <li> gpudb::alter_datasink_wait_timeout:
 *                            Timeout in seconds for waiting for a response
 *                            from this sink
 *                                    <li> gpudb::alter_datasink_credential:
 *                            Name of the <a
 *                            href="../../../concepts/credentials/"
 *                            target="_top">credential</a> object to be used in
 *                            this data sink
 *                                    <li>
 *                            gpudb::alter_datasink_s3_bucket_name: Name of the
 *                            Amazon S3 bucket to use as the data sink
 *                                    <li> gpudb::alter_datasink_s3_region:
 *                            Name of the Amazon S3 region where the given
 *                            bucket is located
 *                                    <li>
 *                            gpudb::alter_datasink_s3_aws_role_arn: Amazon IAM
 *                            Role ARN which has required S3 permissions that
 *                            can be assumed for the given S3 IAM user
 *                                    <li>
 *                            gpudb::alter_datasink_hdfs_kerberos_keytab:
 *                            Kerberos keytab file location for the given HDFS
 *                            user.  This may be a KIFS file.
 *                                    <li>
 *                            gpudb::alter_datasink_hdfs_delegation_token:
 *                            Delegation token for the given HDFS user
 *                                    <li>
 *                            gpudb::alter_datasink_hdfs_use_kerberos: Use
 *                            kerberos authentication for the given HDFS
 *                            cluster
 *                            <ul>
 *                                    <li> gpudb::alter_datasink_true
 *                                    <li> gpudb::alter_datasink_false
 *                            </ul>
 *                            The default value is gpudb::alter_datasink_false.
 *                                    <li>
 *                            gpudb::alter_datasink_azure_storage_account_name:
 *                            Name of the Azure storage account to use as the
 *                            data sink, this is valid only if tenant_id is
 *                            specified
 *                                    <li>
 *                            gpudb::alter_datasink_azure_container_name: Name
 *                            of the Azure storage container to use as the data
 *                            sink
 *                                    <li>
 *                            gpudb::alter_datasink_azure_tenant_id: Active
 *                            Directory tenant ID (or directory ID)
 *                                    <li>
 *                            gpudb::alter_datasink_azure_sas_token: Shared
 *                            access signature token for Azure storage account
 *                            to use as the data sink
 *                                    <li>
 *                            gpudb::alter_datasink_azure_oauth_token: Oauth
 *                            token to access given storage container
 *                                    <li>
 *                            gpudb::alter_datasink_gcs_bucket_name: Name of
 *                            the Google Cloud Storage bucket to use as the
 *                            data sink
 *                                    <li>
 *                            gpudb::alter_datasink_gcs_project_id: Name of the
 *                            Google Cloud project to use as the data sink
 *                                    <li>
 *                            gpudb::alter_datasink_gcs_service_account_keys:
 *                            Google Cloud service account keys to use for
 *                            authenticating the data sink
 *                                    <li> gpudb::alter_datasink_kafka_url: The
 *                            publicly-accessible full path URL to the kafka
 *                            broker, e.g., 'http://172.123.45.67:9300'.
 *                                    <li>
 *                            gpudb::alter_datasink_kafka_topic_name: Name of
 *                            the Kafka topic to use for this data sink, if it
 *                            references a Kafka broker
 *                                    <li> gpudb::alter_datasink_anonymous:
 *                            Create an anonymous connection to the storage
 *                            provider--DEPRECATED: this is now the default.
 *                            Specify use_managed_credentials for non-anonymous
 *                            connection
 *                            <ul>
 *                                    <li> gpudb::alter_datasink_true
 *                                    <li> gpudb::alter_datasink_false
 *                            </ul>
 *                            The default value is gpudb::alter_datasink_true.
 *                                    <li>
 *                            gpudb::alter_datasink_use_managed_credentials:
 *                            When no credentials are supplied, we use
 *                            anonymous access by default.  If this is set, we
 *                            will use cloud provider user settings.
 *                            <ul>
 *                                    <li> gpudb::alter_datasink_true
 *                                    <li> gpudb::alter_datasink_false
 *                            </ul>
 *                            The default value is gpudb::alter_datasink_false.
 *                                    <li> gpudb::alter_datasink_use_https: Use
 *                            https to connect to datasink if true, otherwise
 *                            use http
 *                            <ul>
 *                                    <li> gpudb::alter_datasink_true
 *                                    <li> gpudb::alter_datasink_false
 *                            </ul>
 *                            The default value is gpudb::alter_datasink_true.
 *                                    <li>
 *                            gpudb::alter_datasink_max_batch_size: Maximum
 *                            number of records per notification message.  The
 *                            default value is '1'.
 *                                    <li>
 *                            gpudb::alter_datasink_max_message_size: Maximum
 *                            size in bytes of each notification message.  The
 *                            default value is '1000000'.
 *                                    <li> gpudb::alter_datasink_json_format:
 *                            The desired format of JSON encoded notifications
 *                            message.
 *                            If @a nested, records are returned as an array.
 *                            Otherwise, only a single record per messages is
 *                            returned.
 *                            <ul>
 *                                    <li> gpudb::alter_datasink_flat
 *                                    <li> gpudb::alter_datasink_nested
 *                            </ul>
 *                            The default value is gpudb::alter_datasink_flat.
 *                                    <li>
 *                            gpudb::alter_datasink_skip_validation: Bypass
 *                            validation of connection to this data sink.
 *                            <ul>
 *                                    <li> gpudb::alter_datasink_true
 *                                    <li> gpudb::alter_datasink_false
 *                            </ul>
 *                            The default value is gpudb::alter_datasink_false.
 *                                    <li> gpudb::alter_datasink_schema_name:
 *                            Updates the schema name.  If @a schema_name
 *                            doesn't exist, an error will be thrown. If @a
 *                            schema_name is empty, then the user's
 *                            default schema will be used.
 *                            </ul>
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterDatasinkResponse& alterDatasink( const std::string& name,
                                      const std::map<std::string, std::string>& datasinkUpdatesMap,
                                      const std::map<std::string, std::string>& options,
                                      AlterDatasinkResponse& response_ ) const;

/**
 * Alters the properties of an existing <a
 * href="../../../concepts/data_sources/" target="_top">data source</a>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterDatasourceResponse alterDatasource( const AlterDatasourceRequest& request_ ) const;

/**
 * Alters the properties of an existing <a
 * href="../../../concepts/data_sources/" target="_top">data source</a>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterDatasourceResponse& alterDatasource( const AlterDatasourceRequest& request_,
                                          AlterDatasourceResponse& response_ ) const;

/**
 * Alters the properties of an existing <a
 * href="../../../concepts/data_sources/" target="_top">data source</a>
 * 
 * @param name  Name of the data source to be altered. Must be an existing data
 *              source.
 * @param datasourceUpdatesMap  Map containing the properties of the data
 *                              source to be updated. Error if empty.
 *                              <ul>
 *                                      <li> gpudb::alter_datasource_location:
 *                              Location of the remote storage in
 *                              'storage_provider_type://[storage_path[:storage_port]]'
 *                              format.
 *                              Supported storage provider types are
 *                              'azure','gcs','hdfs','kafka' and 's3'.
 *                                      <li> gpudb::alter_datasource_user_name:
 *                              Name of the remote system user; may be an empty
 *                              string
 *                                      <li> gpudb::alter_datasource_password:
 *                              Password for the remote system user; may be an
 *                              empty string
 *                                      <li>
 *                              gpudb::alter_datasource_skip_validation: Bypass
 *                              validation of connection to remote source.
 *                              <ul>
 *                                      <li> gpudb::alter_datasource_true
 *                                      <li> gpudb::alter_datasource_false
 *                              </ul>
 *                              The default value is
 *                              gpudb::alter_datasource_false.
 *                                      <li>
 *                              gpudb::alter_datasource_connection_timeout:
 *                              Timeout in seconds for connecting to this
 *                              storage provider
 *                                      <li>
 *                              gpudb::alter_datasource_wait_timeout: Timeout
 *                              in seconds for reading from this storage
 *                              provider
 *                                      <li>
 *                              gpudb::alter_datasource_credential: Name of the
 *                              Credential object to be used in data source
 *                                      <li>
 *                              gpudb::alter_datasource_s3_bucket_name: Name of
 *                              the Amazon S3 bucket to use as the data source
 *                                      <li> gpudb::alter_datasource_s3_region:
 *                              Name of the Amazon S3 region where the given
 *                              bucket is located
 *                                      <li>
 *                              gpudb::alter_datasource_s3_aws_role_arn: Amazon
 *                              IAM Role ARN which has required S3 permissions
 *                              that can be assumed for the given S3 IAM user
 *                                      <li>
 *                              gpudb::alter_datasource_s3_encryption_customer_algorithm:
 *                              Customer encryption algorithm used encrypting
 *                              data
 *                                      <li>
 *                              gpudb::alter_datasource_s3_encryption_customer_key:
 *                              Customer encryption key to encrypt or decrypt
 *                              data
 *                                      <li>
 *                              gpudb::alter_datasource_hdfs_kerberos_keytab:
 *                              Kerberos keytab file location for the given
 *                              HDFS user.  This may be a KIFS file.
 *                                      <li>
 *                              gpudb::alter_datasource_hdfs_delegation_token:
 *                              Delegation token for the given HDFS user
 *                                      <li>
 *                              gpudb::alter_datasource_hdfs_use_kerberos: Use
 *                              kerberos authentication for the given HDFS
 *                              cluster
 *                              <ul>
 *                                      <li> gpudb::alter_datasource_true
 *                                      <li> gpudb::alter_datasource_false
 *                              </ul>
 *                              The default value is
 *                              gpudb::alter_datasource_false.
 *                                      <li>
 *                              gpudb::alter_datasource_azure_storage_account_name:
 *                              Name of the Azure storage account to use as the
 *                              data source, this is valid only if tenant_id is
 *                              specified
 *                                      <li>
 *                              gpudb::alter_datasource_azure_container_name:
 *                              Name of the Azure storage container to use as
 *                              the data source
 *                                      <li>
 *                              gpudb::alter_datasource_azure_tenant_id: Active
 *                              Directory tenant ID (or directory ID)
 *                                      <li>
 *                              gpudb::alter_datasource_azure_sas_token: Shared
 *                              access signature token for Azure storage
 *                              account to use as the data source
 *                                      <li>
 *                              gpudb::alter_datasource_azure_oauth_token:
 *                              Oauth token to access given storage container
 *                                      <li>
 *                              gpudb::alter_datasource_gcs_bucket_name: Name
 *                              of the Google Cloud Storage bucket to use as
 *                              the data source
 *                                      <li>
 *                              gpudb::alter_datasource_gcs_project_id: Name of
 *                              the Google Cloud project to use as the data
 *                              source
 *                                      <li>
 *                              gpudb::alter_datasource_gcs_service_account_keys:
 *                              Google Cloud service account keys to use for
 *                              authenticating the data source
 *                                      <li> gpudb::alter_datasource_kafka_url:
 *                              The publicly-accessible full path URL to the
 *                              kafka broker, e.g.,
 *                              'http://172.123.45.67:9300'.
 *                                      <li>
 *                              gpudb::alter_datasource_kafka_topic_name: Name
 *                              of the Kafka topic to use as the data source
 *                                      <li>
 *                              gpudb::alter_datasource_jdbc_driver_jar_path:
 *                              JDBC driver jar file location.  This may be a
 *                              KIFS file.
 *                                      <li>
 *                              gpudb::alter_datasource_jdbc_driver_class_name:
 *                              Name of the JDBC driver class
 *                                      <li> gpudb::alter_datasource_anonymous:
 *                              Create an anonymous connection to the storage
 *                              provider--DEPRECATED: this is now the default.
 *                              Specify use_managed_credentials for
 *                              non-anonymous connection
 *                              <ul>
 *                                      <li> gpudb::alter_datasource_true
 *                                      <li> gpudb::alter_datasource_false
 *                              </ul>
 *                              The default value is
 *                              gpudb::alter_datasource_true.
 *                                      <li>
 *                              gpudb::alter_datasource_use_managed_credentials:
 *                              When no credentials are supplied, we use
 *                              anonymous access by default.  If this is set,
 *                              we will use cloud provider user settings.
 *                              <ul>
 *                                      <li> gpudb::alter_datasource_true
 *                                      <li> gpudb::alter_datasource_false
 *                              </ul>
 *                              The default value is
 *                              gpudb::alter_datasource_false.
 *                                      <li> gpudb::alter_datasource_use_https:
 *                              Use https to connect to datasource if true,
 *                              otherwise use http
 *                              <ul>
 *                                      <li> gpudb::alter_datasource_true
 *                                      <li> gpudb::alter_datasource_false
 *                              </ul>
 *                              The default value is
 *                              gpudb::alter_datasource_true.
 *                                      <li>
 *                              gpudb::alter_datasource_schema_name: Updates
 *                              the schema name.  If @a schema_name
 *                              doesn't exist, an error will be thrown. If @a
 *                              schema_name is empty, then the user's
 *                              default schema will be used.
 *                              </ul>
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterDatasourceResponse alterDatasource( const std::string& name,
                                         const std::map<std::string, std::string>& datasourceUpdatesMap,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Alters the properties of an existing <a
 * href="../../../concepts/data_sources/" target="_top">data source</a>
 * 
 * @param name  Name of the data source to be altered. Must be an existing data
 *              source.
 * @param datasourceUpdatesMap  Map containing the properties of the data
 *                              source to be updated. Error if empty.
 *                              <ul>
 *                                      <li> gpudb::alter_datasource_location:
 *                              Location of the remote storage in
 *                              'storage_provider_type://[storage_path[:storage_port]]'
 *                              format.
 *                              Supported storage provider types are
 *                              'azure','gcs','hdfs','kafka' and 's3'.
 *                                      <li> gpudb::alter_datasource_user_name:
 *                              Name of the remote system user; may be an empty
 *                              string
 *                                      <li> gpudb::alter_datasource_password:
 *                              Password for the remote system user; may be an
 *                              empty string
 *                                      <li>
 *                              gpudb::alter_datasource_skip_validation: Bypass
 *                              validation of connection to remote source.
 *                              <ul>
 *                                      <li> gpudb::alter_datasource_true
 *                                      <li> gpudb::alter_datasource_false
 *                              </ul>
 *                              The default value is
 *                              gpudb::alter_datasource_false.
 *                                      <li>
 *                              gpudb::alter_datasource_connection_timeout:
 *                              Timeout in seconds for connecting to this
 *                              storage provider
 *                                      <li>
 *                              gpudb::alter_datasource_wait_timeout: Timeout
 *                              in seconds for reading from this storage
 *                              provider
 *                                      <li>
 *                              gpudb::alter_datasource_credential: Name of the
 *                              Credential object to be used in data source
 *                                      <li>
 *                              gpudb::alter_datasource_s3_bucket_name: Name of
 *                              the Amazon S3 bucket to use as the data source
 *                                      <li> gpudb::alter_datasource_s3_region:
 *                              Name of the Amazon S3 region where the given
 *                              bucket is located
 *                                      <li>
 *                              gpudb::alter_datasource_s3_aws_role_arn: Amazon
 *                              IAM Role ARN which has required S3 permissions
 *                              that can be assumed for the given S3 IAM user
 *                                      <li>
 *                              gpudb::alter_datasource_s3_encryption_customer_algorithm:
 *                              Customer encryption algorithm used encrypting
 *                              data
 *                                      <li>
 *                              gpudb::alter_datasource_s3_encryption_customer_key:
 *                              Customer encryption key to encrypt or decrypt
 *                              data
 *                                      <li>
 *                              gpudb::alter_datasource_hdfs_kerberos_keytab:
 *                              Kerberos keytab file location for the given
 *                              HDFS user.  This may be a KIFS file.
 *                                      <li>
 *                              gpudb::alter_datasource_hdfs_delegation_token:
 *                              Delegation token for the given HDFS user
 *                                      <li>
 *                              gpudb::alter_datasource_hdfs_use_kerberos: Use
 *                              kerberos authentication for the given HDFS
 *                              cluster
 *                              <ul>
 *                                      <li> gpudb::alter_datasource_true
 *                                      <li> gpudb::alter_datasource_false
 *                              </ul>
 *                              The default value is
 *                              gpudb::alter_datasource_false.
 *                                      <li>
 *                              gpudb::alter_datasource_azure_storage_account_name:
 *                              Name of the Azure storage account to use as the
 *                              data source, this is valid only if tenant_id is
 *                              specified
 *                                      <li>
 *                              gpudb::alter_datasource_azure_container_name:
 *                              Name of the Azure storage container to use as
 *                              the data source
 *                                      <li>
 *                              gpudb::alter_datasource_azure_tenant_id: Active
 *                              Directory tenant ID (or directory ID)
 *                                      <li>
 *                              gpudb::alter_datasource_azure_sas_token: Shared
 *                              access signature token for Azure storage
 *                              account to use as the data source
 *                                      <li>
 *                              gpudb::alter_datasource_azure_oauth_token:
 *                              Oauth token to access given storage container
 *                                      <li>
 *                              gpudb::alter_datasource_gcs_bucket_name: Name
 *                              of the Google Cloud Storage bucket to use as
 *                              the data source
 *                                      <li>
 *                              gpudb::alter_datasource_gcs_project_id: Name of
 *                              the Google Cloud project to use as the data
 *                              source
 *                                      <li>
 *                              gpudb::alter_datasource_gcs_service_account_keys:
 *                              Google Cloud service account keys to use for
 *                              authenticating the data source
 *                                      <li> gpudb::alter_datasource_kafka_url:
 *                              The publicly-accessible full path URL to the
 *                              kafka broker, e.g.,
 *                              'http://172.123.45.67:9300'.
 *                                      <li>
 *                              gpudb::alter_datasource_kafka_topic_name: Name
 *                              of the Kafka topic to use as the data source
 *                                      <li>
 *                              gpudb::alter_datasource_jdbc_driver_jar_path:
 *                              JDBC driver jar file location.  This may be a
 *                              KIFS file.
 *                                      <li>
 *                              gpudb::alter_datasource_jdbc_driver_class_name:
 *                              Name of the JDBC driver class
 *                                      <li> gpudb::alter_datasource_anonymous:
 *                              Create an anonymous connection to the storage
 *                              provider--DEPRECATED: this is now the default.
 *                              Specify use_managed_credentials for
 *                              non-anonymous connection
 *                              <ul>
 *                                      <li> gpudb::alter_datasource_true
 *                                      <li> gpudb::alter_datasource_false
 *                              </ul>
 *                              The default value is
 *                              gpudb::alter_datasource_true.
 *                                      <li>
 *                              gpudb::alter_datasource_use_managed_credentials:
 *                              When no credentials are supplied, we use
 *                              anonymous access by default.  If this is set,
 *                              we will use cloud provider user settings.
 *                              <ul>
 *                                      <li> gpudb::alter_datasource_true
 *                                      <li> gpudb::alter_datasource_false
 *                              </ul>
 *                              The default value is
 *                              gpudb::alter_datasource_false.
 *                                      <li> gpudb::alter_datasource_use_https:
 *                              Use https to connect to datasource if true,
 *                              otherwise use http
 *                              <ul>
 *                                      <li> gpudb::alter_datasource_true
 *                                      <li> gpudb::alter_datasource_false
 *                              </ul>
 *                              The default value is
 *                              gpudb::alter_datasource_true.
 *                                      <li>
 *                              gpudb::alter_datasource_schema_name: Updates
 *                              the schema name.  If @a schema_name
 *                              doesn't exist, an error will be thrown. If @a
 *                              schema_name is empty, then the user's
 *                              default schema will be used.
 *                              </ul>
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterDatasourceResponse& alterDatasource( const std::string& name,
                                          const std::map<std::string, std::string>& datasourceUpdatesMap,
                                          const std::map<std::string, std::string>& options,
                                          AlterDatasourceResponse& response_ ) const;

/**
 * Alters an existing directory in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterDirectoryResponse alterDirectory( const AlterDirectoryRequest& request_ ) const;

/**
 * Alters an existing directory in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterDirectoryResponse& alterDirectory( const AlterDirectoryRequest& request_,
                                        AlterDirectoryResponse& response_ ) const;

/**
 * Alters an existing directory in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param directoryName  Name of the directory in KiFS to be altered.
 * @param directoryUpdatesMap  Map containing the properties of the directory
 *                             to be altered. Error if empty.
 *                             <ul>
 *                                     <li> gpudb::alter_directory_data_limit:
 *                             The maximum capacity, in bytes, to apply to the
 *                             directory. Set to -1 to indicate no upper limit.
 *                             </ul>
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterDirectoryResponse alterDirectory( const std::string& directoryName,
                                       const std::map<std::string, std::string>& directoryUpdatesMap,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Alters an existing directory in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param directoryName  Name of the directory in KiFS to be altered.
 * @param directoryUpdatesMap  Map containing the properties of the directory
 *                             to be altered. Error if empty.
 *                             <ul>
 *                                     <li> gpudb::alter_directory_data_limit:
 *                             The maximum capacity, in bytes, to apply to the
 *                             directory. Set to -1 to indicate no upper limit.
 *                             </ul>
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterDirectoryResponse& alterDirectory( const std::string& directoryName,
                                        const std::map<std::string, std::string>& directoryUpdatesMap,
                                        const std::map<std::string, std::string>& options,
                                        AlterDirectoryResponse& response_ ) const;

/**
 * Alters an existing environment which can be referenced by a <a
 * href="../../../concepts/udf/" target="_top">user-defined function</a> (UDF).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterEnvironmentResponse alterEnvironment( const AlterEnvironmentRequest& request_ ) const;

/**
 * Alters an existing environment which can be referenced by a <a
 * href="../../../concepts/udf/" target="_top">user-defined function</a> (UDF).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterEnvironmentResponse& alterEnvironment( const AlterEnvironmentRequest& request_,
                                            AlterEnvironmentResponse& response_ ) const;

/**
 * Alters an existing environment which can be referenced by a <a
 * href="../../../concepts/udf/" target="_top">user-defined function</a> (UDF).
 * 
 * @param environmentName  Name of the environment to be altered.
 * @param action  Modification operation to be applied
 *                <ul>
 *                        <li> gpudb::alter_environment_install_package:
 *                Install a python package from PyPI, an external data source
 *                or KiFS
 *                        <li> gpudb::alter_environment_install_requirements:
 *                Install packages from a requirements file
 *                        <li> gpudb::alter_environment_uninstall_package:
 *                Uninstall a python package.
 *                        <li> gpudb::alter_environment_uninstall_requirements:
 *                Uninstall packages from a requirements file
 *                        <li> gpudb::alter_environment_reset: Uninstalls all
 *                packages in the environment and resets it to the original
 *                state at time of creation
 *                        <li> gpudb::alter_environment_rebuild: Recreates the
 *                environment and re-installs all packages, upgrades the
 *                packages if necessary based on dependencies
 *                </ul>
 * @param value  The value of the modification, depending on @a action.  For
 *               example, if @a action is @a install_package, this would be the
 *               python package name.
 *               If @a action is @a install_requirements, this would be the
 *               path of a requirements file from which to install packages.
 *               If an external data source is specified in @a datasource_name,
 *               this can be the path to a wheel file or source archive.
 *               Alternatively, if installing from a file (wheel or source
 *               archive), the value may be a reference to a file in <a
 *               href="../../../tools/kifs/" target="_top">KiFS</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::alter_environment_datasource_name: Name
 *                 of an existing external data source from which packages
 *                 specified in @a value can be loaded
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterEnvironmentResponse alterEnvironment( const std::string& environmentName,
                                           const std::string& action,
                                           const std::string& value,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * Alters an existing environment which can be referenced by a <a
 * href="../../../concepts/udf/" target="_top">user-defined function</a> (UDF).
 * 
 * @param environmentName  Name of the environment to be altered.
 * @param action  Modification operation to be applied
 *                <ul>
 *                        <li> gpudb::alter_environment_install_package:
 *                Install a python package from PyPI, an external data source
 *                or KiFS
 *                        <li> gpudb::alter_environment_install_requirements:
 *                Install packages from a requirements file
 *                        <li> gpudb::alter_environment_uninstall_package:
 *                Uninstall a python package.
 *                        <li> gpudb::alter_environment_uninstall_requirements:
 *                Uninstall packages from a requirements file
 *                        <li> gpudb::alter_environment_reset: Uninstalls all
 *                packages in the environment and resets it to the original
 *                state at time of creation
 *                        <li> gpudb::alter_environment_rebuild: Recreates the
 *                environment and re-installs all packages, upgrades the
 *                packages if necessary based on dependencies
 *                </ul>
 * @param value  The value of the modification, depending on @a action.  For
 *               example, if @a action is @a install_package, this would be the
 *               python package name.
 *               If @a action is @a install_requirements, this would be the
 *               path of a requirements file from which to install packages.
 *               If an external data source is specified in @a datasource_name,
 *               this can be the path to a wheel file or source archive.
 *               Alternatively, if installing from a file (wheel or source
 *               archive), the value may be a reference to a file in <a
 *               href="../../../tools/kifs/" target="_top">KiFS</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::alter_environment_datasource_name: Name
 *                 of an existing external data source from which packages
 *                 specified in @a value can be loaded
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterEnvironmentResponse& alterEnvironment( const std::string& environmentName,
                                            const std::string& action,
                                            const std::string& value,
                                            const std::map<std::string, std::string>& options,
                                            AlterEnvironmentResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterGraphResponse alterGraph( const AlterGraphRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterGraphResponse& alterGraph( const AlterGraphRequest& request_,
                                AlterGraphResponse& response_ ) const;

/**
 * @private
 * 
 * @param graphName
 * @param action
 *                <ul>
 *                        <li> gpudb::alter_graph_add_table_monitor
 *                        <li> gpudb::alter_graph_reset_client
 *                        <li> gpudb::alter_graph_reset_server
 *                        <li> gpudb::alter_graph_cancel_task
 *                        <li> gpudb::alter_graph_alter_logger
 *                        <li> gpudb::alter_graph_delete_all
 *                        <li> gpudb::alter_graph_status
 *                        <li> gpudb::alter_graph_collect_graphs
 *                        <li> gpudb::alter_graph_restore_graphs
 *                </ul>
 * @param actionArg
 * @param options
 *                 <ul>
 *                         <li> gpudb::alter_graph_server_id
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterGraphResponse alterGraph( const std::string& graphName,
                               const std::string& action,
                               const std::string& actionArg,
                               const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param graphName
 * @param action
 *                <ul>
 *                        <li> gpudb::alter_graph_add_table_monitor
 *                        <li> gpudb::alter_graph_reset_client
 *                        <li> gpudb::alter_graph_reset_server
 *                        <li> gpudb::alter_graph_cancel_task
 *                        <li> gpudb::alter_graph_alter_logger
 *                        <li> gpudb::alter_graph_delete_all
 *                        <li> gpudb::alter_graph_status
 *                        <li> gpudb::alter_graph_collect_graphs
 *                        <li> gpudb::alter_graph_restore_graphs
 *                </ul>
 * @param actionArg
 * @param options
 *                 <ul>
 *                         <li> gpudb::alter_graph_server_id
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterGraphResponse& alterGraph( const std::string& graphName,
                                const std::string& action,
                                const std::string& actionArg,
                                const std::map<std::string, std::string>& options,
                                AlterGraphResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterModelResponse alterModel( const AlterModelRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterModelResponse& alterModel( const AlterModelRequest& request_,
                                AlterModelResponse& response_ ) const;

/**
 * @private
 * 
 * @param modelName
 * @param action
 *                <ul>
 *                        <li> gpudb::alter_model_container
 *                        <li> gpudb::alter_model_registry
 *                        <li> gpudb::alter_model_refresh
 *                        <li> gpudb::alter_model_stop_deployment
 *                </ul>
 * @param value
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterModelResponse alterModel( const std::string& modelName,
                               const std::string& action,
                               const std::string& value,
                               const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param modelName
 * @param action
 *                <ul>
 *                        <li> gpudb::alter_model_container
 *                        <li> gpudb::alter_model_registry
 *                        <li> gpudb::alter_model_refresh
 *                        <li> gpudb::alter_model_stop_deployment
 *                </ul>
 * @param value
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterModelResponse& alterModel( const std::string& modelName,
                                const std::string& action,
                                const std::string& value,
                                const std::map<std::string, std::string>& options,
                                AlterModelResponse& response_ ) const;

/**
 * Alters the properties of an exisiting resource group to facilitate resource
 * management.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterResourceGroupResponse alterResourceGroup( const AlterResourceGroupRequest& request_ ) const;

/**
 * Alters the properties of an exisiting resource group to facilitate resource
 * management.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterResourceGroupResponse& alterResourceGroup( const AlterResourceGroupRequest& request_,
                                                AlterResourceGroupResponse& response_ ) const;

/**
 * Alters the properties of an exisiting resource group to facilitate resource
 * management.
 * 
 * @param name  Name of the group to be altered. Must be an existing resource
 *              group name or an empty string when used inconjunction with the
 *              is_default_group option.
 * @param tierAttributes  Optional map containing tier names and their
 *                        respective attribute group limits.  The only valid
 *                        attribute limit that can be set is max_memory (in
 *                        bytes) for the VRAM & RAM tiers.
 *                        For instance, to set max VRAM capacity to 1GB and max
 *                        RAM capacity to 10GB, use:
 *                        {'VRAM':{'max_memory':'1000000000'},
 *                        'RAM':{'max_memory':'10000000000'}}
 *                        <ul>
 *                                <li> gpudb::alter_resource_group_max_memory:
 *                        Maximum amount of memory usable in the given tier at
 *                        one time for this group.
 *                        </ul>
 * @param ranking  If the resource group ranking is to be updated, this
 *                 indicates the relative ranking among existing resource
 *                 groups where this resource group will be moved; leave blank
 *                 if not changing the ranking.  When using @a before or @a
 *                 after, specify which resource group this one will be
 *                 inserted before or after in @a adjoiningResourceGroup.
 *                 <ul>
 *                         <li> gpudb::alter_resource_group_empty_string
 *                         <li> gpudb::alter_resource_group_first
 *                         <li> gpudb::alter_resource_group_last
 *                         <li> gpudb::alter_resource_group_before
 *                         <li> gpudb::alter_resource_group_after
 *                 </ul>
 *                 The default value is
 *                 gpudb::alter_resource_group_empty_string.
 * @param adjoiningResourceGroup  If @a ranking is @a before or @a after, this
 *                                field indicates the resource group before or
 *                                after which the current group will be placed;
 *                                otherwise, leave blank.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::alter_resource_group_max_cpu_concurrency: Maximum
 *                 number of simultaneous threads that will be used to execute
 *                 a request for this group.
 *                         <li> gpudb::alter_resource_group_max_data: Maximum
 *                 amount of cumulative ram usage regardless of tier status for
 *                 this group.
 *                         <li>
 *                 gpudb::alter_resource_group_max_scheduling_priority: Maximum
 *                 priority of a scheduled task for this group.
 *                         <li> gpudb::alter_resource_group_max_tier_priority:
 *                 Maximum priority of a tiered object for this group.
 *                         <li> gpudb::alter_resource_group_is_default_group:
 *                 If @a true, this request applies to the global default
 *                 resource group. It is an error for this field to be @a true
 *                 when the @a name field is also populated.
 *                 <ul>
 *                         <li> gpudb::alter_resource_group_true
 *                         <li> gpudb::alter_resource_group_false
 *                 </ul>
 *                 The default value is gpudb::alter_resource_group_false.
 *                         <li> gpudb::alter_resource_group_persist: If @a true
 *                 and a system-level change was requested, the system
 *                 configuration will be written to disk upon successful
 *                 application of this request. This will commit the changes
 *                 from this request and any additional in-memory
 *                 modifications.
 *                 <ul>
 *                         <li> gpudb::alter_resource_group_true
 *                         <li> gpudb::alter_resource_group_false
 *                 </ul>
 *                 The default value is gpudb::alter_resource_group_true.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterResourceGroupResponse alterResourceGroup( const std::string& name,
                                               const std::map<std::string, std::map<std::string, std::string> >& tierAttributes,
                                               const std::string& ranking,
                                               const std::string& adjoiningResourceGroup,
                                               const std::map<std::string, std::string>& options ) const;

/**
 * Alters the properties of an exisiting resource group to facilitate resource
 * management.
 * 
 * @param name  Name of the group to be altered. Must be an existing resource
 *              group name or an empty string when used inconjunction with the
 *              is_default_group option.
 * @param tierAttributes  Optional map containing tier names and their
 *                        respective attribute group limits.  The only valid
 *                        attribute limit that can be set is max_memory (in
 *                        bytes) for the VRAM & RAM tiers.
 *                        For instance, to set max VRAM capacity to 1GB and max
 *                        RAM capacity to 10GB, use:
 *                        {'VRAM':{'max_memory':'1000000000'},
 *                        'RAM':{'max_memory':'10000000000'}}
 *                        <ul>
 *                                <li> gpudb::alter_resource_group_max_memory:
 *                        Maximum amount of memory usable in the given tier at
 *                        one time for this group.
 *                        </ul>
 * @param ranking  If the resource group ranking is to be updated, this
 *                 indicates the relative ranking among existing resource
 *                 groups where this resource group will be moved; leave blank
 *                 if not changing the ranking.  When using @a before or @a
 *                 after, specify which resource group this one will be
 *                 inserted before or after in @a adjoiningResourceGroup.
 *                 <ul>
 *                         <li> gpudb::alter_resource_group_empty_string
 *                         <li> gpudb::alter_resource_group_first
 *                         <li> gpudb::alter_resource_group_last
 *                         <li> gpudb::alter_resource_group_before
 *                         <li> gpudb::alter_resource_group_after
 *                 </ul>
 *                 The default value is
 *                 gpudb::alter_resource_group_empty_string.
 * @param adjoiningResourceGroup  If @a ranking is @a before or @a after, this
 *                                field indicates the resource group before or
 *                                after which the current group will be placed;
 *                                otherwise, leave blank.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::alter_resource_group_max_cpu_concurrency: Maximum
 *                 number of simultaneous threads that will be used to execute
 *                 a request for this group.
 *                         <li> gpudb::alter_resource_group_max_data: Maximum
 *                 amount of cumulative ram usage regardless of tier status for
 *                 this group.
 *                         <li>
 *                 gpudb::alter_resource_group_max_scheduling_priority: Maximum
 *                 priority of a scheduled task for this group.
 *                         <li> gpudb::alter_resource_group_max_tier_priority:
 *                 Maximum priority of a tiered object for this group.
 *                         <li> gpudb::alter_resource_group_is_default_group:
 *                 If @a true, this request applies to the global default
 *                 resource group. It is an error for this field to be @a true
 *                 when the @a name field is also populated.
 *                 <ul>
 *                         <li> gpudb::alter_resource_group_true
 *                         <li> gpudb::alter_resource_group_false
 *                 </ul>
 *                 The default value is gpudb::alter_resource_group_false.
 *                         <li> gpudb::alter_resource_group_persist: If @a true
 *                 and a system-level change was requested, the system
 *                 configuration will be written to disk upon successful
 *                 application of this request. This will commit the changes
 *                 from this request and any additional in-memory
 *                 modifications.
 *                 <ul>
 *                         <li> gpudb::alter_resource_group_true
 *                         <li> gpudb::alter_resource_group_false
 *                 </ul>
 *                 The default value is gpudb::alter_resource_group_true.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterResourceGroupResponse& alterResourceGroup( const std::string& name,
                                                const std::map<std::string, std::map<std::string, std::string> >& tierAttributes,
                                                const std::string& ranking,
                                                const std::string& adjoiningResourceGroup,
                                                const std::map<std::string, std::string>& options,
                                                AlterResourceGroupResponse& response_ ) const;

/**
 * Alters a Role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterRoleResponse alterRole( const AlterRoleRequest& request_ ) const;

/**
 * Alters a Role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterRoleResponse& alterRole( const AlterRoleRequest& request_,
                              AlterRoleResponse& response_ ) const;

/**
 * Alters a Role.
 * 
 * @param name  Name of the role to be altered. Must be an existing role.
 * @param action  Modification operation to be applied to the role.
 *                <ul>
 *                        <li> gpudb::alter_role_set_resource_group: Sets the
 *                resource group for an internal role. The resource group must
 *                exist, otherwise, an empty string assigns the role to the
 *                default resource group.
 *                </ul>
 * @param value  The value of the modification, depending on @a action.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterRoleResponse alterRole( const std::string& name,
                             const std::string& action,
                             const std::string& value,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Alters a Role.
 * 
 * @param name  Name of the role to be altered. Must be an existing role.
 * @param action  Modification operation to be applied to the role.
 *                <ul>
 *                        <li> gpudb::alter_role_set_resource_group: Sets the
 *                resource group for an internal role. The resource group must
 *                exist, otherwise, an empty string assigns the role to the
 *                default resource group.
 *                </ul>
 * @param value  The value of the modification, depending on @a action.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterRoleResponse& alterRole( const std::string& name,
                              const std::string& action,
                              const std::string& value,
                              const std::map<std::string, std::string>& options,
                              AlterRoleResponse& response_ ) const;

/**
 * Used to change the name of a SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>, specified in @a schemaName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterSchemaResponse alterSchema( const AlterSchemaRequest& request_ ) const;

/**
 * Used to change the name of a SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>, specified in @a schemaName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterSchemaResponse& alterSchema( const AlterSchemaRequest& request_,
                                  AlterSchemaResponse& response_ ) const;

/**
 * Used to change the name of a SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>, specified in @a schemaName.
 * 
 * @param schemaName  Name of the schema to be altered.
 * @param action  Modification operation to be applied
 *                <ul>
 *                        <li> gpudb::alter_schema_rename_schema: Renames a
 *                schema to @a value. Has the same naming restrictions as <a
 *                href="../../../concepts/tables/" target="_top">tables</a>.
 *                </ul>
 * @param value  The value of the modification, depending on @a action.  For
 *               now the only value of @a action is @a rename_schema.  In this
 *               case the value is the new name of the schema.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterSchemaResponse alterSchema( const std::string& schemaName,
                                 const std::string& action,
                                 const std::string& value,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Used to change the name of a SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>, specified in @a schemaName.
 * 
 * @param schemaName  Name of the schema to be altered.
 * @param action  Modification operation to be applied
 *                <ul>
 *                        <li> gpudb::alter_schema_rename_schema: Renames a
 *                schema to @a value. Has the same naming restrictions as <a
 *                href="../../../concepts/tables/" target="_top">tables</a>.
 *                </ul>
 * @param value  The value of the modification, depending on @a action.  For
 *               now the only value of @a action is @a rename_schema.  In this
 *               case the value is the new name of the schema.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterSchemaResponse& alterSchema( const std::string& schemaName,
                                  const std::string& action,
                                  const std::string& value,
                                  const std::map<std::string, std::string>& options,
                                  AlterSchemaResponse& response_ ) const;

/**
 * The {@link
 * #alterSystemProperties(const AlterSystemPropertiesRequest&) const}
 * endpoint is primarily used to simplify the testing of the system and is not
 * expected to be used during normal execution.  Commands are given through the
 * @a propertyUpdatesMap whose keys are commands and values are strings
 * representing integer values (for example '8000') or boolean values ('true'
 * or 'false').
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterSystemPropertiesResponse alterSystemProperties( const AlterSystemPropertiesRequest& request_ ) const;

/**
 * The {@link
 * #alterSystemProperties(const AlterSystemPropertiesRequest&,AlterSystemPropertiesResponse&) const}
 * endpoint is primarily used to simplify the testing of the system and is not
 * expected to be used during normal execution.  Commands are given through the
 * @a propertyUpdatesMap whose keys are commands and values are strings
 * representing integer values (for example '8000') or boolean values ('true'
 * or 'false').
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterSystemPropertiesResponse& alterSystemProperties( const AlterSystemPropertiesRequest& request_,
                                                      AlterSystemPropertiesResponse& response_ ) const;

/**
 * The {@link
 * #alterSystemProperties(const std::map<std::string, std::string>&,const std::map<std::string, std::string>&) const}
 * endpoint is primarily used to simplify the testing of the system and is not
 * expected to be used during normal execution.  Commands are given through the
 * @a propertyUpdatesMap whose keys are commands and values are strings
 * representing integer values (for example '8000') or boolean values ('true'
 * or 'false').
 * 
 * @param propertyUpdatesMap  Map containing the properties of the system to be
 *                            updated. Error if empty.
 *                            <ul>
 *                                    <li>
 *                            gpudb::alter_system_properties_sm_omp_threads:
 *                            Set the number of OpenMP threads that will be
 *                            used to service filter & aggregation requests to
 *                            the specified integer value.
 *                                    <li>
 *                            gpudb::alter_system_properties_kernel_omp_threads:
 *                            Set the number of kernel OpenMP threads to the
 *                            specified integer value.
 *                                    <li>
 *                            gpudb::alter_system_properties_concurrent_kernel_execution:
 *                            Enables concurrent kernel execution if the value
 *                            is @a true and disables it if the value is @a
 *                            false.
 *                            <ul>
 *                                    <li> gpudb::alter_system_properties_true
 *                                    <li> gpudb::alter_system_properties_false
 *                            </ul>
 *                                    <li>
 *                            gpudb::alter_system_properties_subtask_concurrency_limit:
 *                            Sets the maximum number of simultaneous threads
 *                            allocated to a given request, on each rank. Note
 *                            that thread allocation may also be limted by
 *                            resource group limits and/or system load.
 *                                    <li>
 *                            gpudb::alter_system_properties_chunk_size: Sets
 *                            the number of records per chunk to be used for
 *                            all new tables.
 *                                    <li>
 *                            gpudb::alter_system_properties_evict_columns:
 *                            Attempts to evict columns from memory to the
 *                            persistent store.  Value string is a semicolon
 *                            separated list of entries, each entry being a
 *                            table name optionally followed by a comma and a
 *                            comma separated list of column names to attempt
 *                            to evict.  An empty value string will attempt to
 *                            evict all tables and columns.
 *                                    <li>
 *                            gpudb::alter_system_properties_execution_mode:
 *                            Sets the execution_mode for kernel executions to
 *                            the specified string value. Possible values are
 *                            host, device, default (engine decides) or an
 *                            integer value that indicates max chunk size to
 *                            exec on host
 *                                    <li>
 *                            gpudb::alter_system_properties_external_files_directory:
 *                            Sets the root directory path where external table
 *                            data files are accessed from.  Path must exist on
 *                            the head node
 *                                    <li>
 *                            gpudb::alter_system_properties_flush_to_disk:
 *                            Flushes any changes to any tables to the
 *                            persistent store.  These changes include updates
 *                            to the vector store, object store, and text
 *                            search store, Value string is ignored
 *                                    <li>
 *                            gpudb::alter_system_properties_clear_cache:
 *                            Clears cached results.  Useful to allow repeated
 *                            timing of endpoints.  Value string is the name of
 *                            the table for which to clear the cached results,
 *                            or an empty string to clear the cached results
 *                            for all tables.
 *                                    <li>
 *                            gpudb::alter_system_properties_communicator_test:
 *                            Invoke the communicator test and report timing
 *                            results. Value string is a semicolon separated
 *                            list of [key]=[value] expressions.  Expressions
 *                            are: num_transactions=[num] where num is the
 *                            number of request reply transactions to invoke
 *                            per test; message_size=[bytes] where bytes is the
 *                            size in bytes of the messages to send;
 *                            check_values=[enabled] where if enabled is true
 *                            the value of the messages received are verified.
 *                                    <li>
 *                            gpudb::alter_system_properties_network_speed:
 *                            Invoke the network speed test and report timing
 *                            results. Value string is a semicolon-separated
 *                            list of [key]=[value] expressions.  Valid
 *                            expressions are: seconds=[time] where time is the
 *                            time in seconds to run the test;
 *                            data_size=[bytes] where bytes is the size in
 *                            bytes of the block to be transferred;
 *                            threads=[number of threads];
 *                            to_ranks=[space-separated list of ranks] where
 *                            the list of ranks is the ranks that rank 0 will
 *                            send data to and get data from. If to_ranks is
 *                            unspecified then all worker ranks are used.
 *                                    <li>
 *                            gpudb::alter_system_properties_request_timeout:
 *                            Number of minutes after which filtering (e.g.,
 *                            /filter) and aggregating (e.g.,
 *                            /aggregate/groupby) queries will timeout.  The
 *                            default value is '20'.
 *                                    <li>
 *                            gpudb::alter_system_properties_max_get_records_size:
 *                            The maximum number of records the database will
 *                            serve for a given data retrieval call.  The
 *                            default value is '20000'.
 *                                    <li>
 *                            gpudb::alter_system_properties_max_grbc_batch_size:
 *                            <DEVELOPER>
 *                                    <li>
 *                            gpudb::alter_system_properties_enable_audit:
 *                            Enable or disable auditing.
 *                                    <li>
 *                            gpudb::alter_system_properties_audit_headers:
 *                            Enable or disable auditing of request headers.
 *                                    <li>
 *                            gpudb::alter_system_properties_audit_body: Enable
 *                            or disable auditing of request bodies.
 *                                    <li>
 *                            gpudb::alter_system_properties_audit_data: Enable
 *                            or disable auditing of request data.
 *                                    <li>
 *                            gpudb::alter_system_properties_audit_response:
 *                            Enable or disable auditing of response
 *                            information.
 *                                    <li>
 *                            gpudb::alter_system_properties_shadow_agg_size:
 *                            Size of the shadow aggregate chunk cache in
 *                            bytes.  The default value is '10000000'.
 *                                    <li>
 *                            gpudb::alter_system_properties_shadow_filter_size:
 *                            Size of the shadow filter chunk cache in bytes.
 *                            The default value is '10000000'.
 *                                    <li>
 *                            gpudb::alter_system_properties_synchronous_compression:
 *                            compress vector on set_compression (instead of
 *                            waiting for background thread).  The default
 *                            value is 'false'.
 *                                    <li>
 *                            gpudb::alter_system_properties_enable_overlapped_equi_join:
 *                            Enable overlapped-equi-join filter.  The default
 *                            value is 'true'.
 *                                    <li>
 *                            gpudb::alter_system_properties_kafka_batch_size:
 *                            Maximum number of records to be ingested in a
 *                            single batch.  The default value is '1000'.
 *                                    <li>
 *                            gpudb::alter_system_properties_kafka_poll_timeout:
 *                            Maximum time (milliseconds) for each poll to get
 *                            records from kafka.  The default value is '0'.
 *                                    <li>
 *                            gpudb::alter_system_properties_kafka_wait_time:
 *                            Maximum time (seconds) to buffer records received
 *                            from kafka before ingestion.  The default value
 *                            is '30'.
 *                                    <li>
 *                            gpudb::alter_system_properties_egress_parquet_compression:
 *                            Parquet file compression type
 *                            <ul>
 *                                    <li>
 *                            gpudb::alter_system_properties_uncompressed
 *                                    <li>
 *                            gpudb::alter_system_properties_snappy
 *                                    <li> gpudb::alter_system_properties_gzip
 *                            </ul>
 *                            The default value is
 *                            gpudb::alter_system_properties_snappy.
 *                                    <li>
 *                            gpudb::alter_system_properties_egress_single_file_max_size:
 *                            Max file size (in MB) to allow saving to a single
 *                            file. May be overridden by target limitations.
 *                            The default value is '100'.
 *                                    <li>
 *                            gpudb::alter_system_properties_max_concurrent_kernels:
 *                            Sets the max_concurrent_kernels value of the
 *                            conf.
 *                                    <li>
 *                            gpudb::alter_system_properties_tcs_per_tom: Sets
 *                            the tcs_per_tom value of the conf.
 *                                    <li>
 *                            gpudb::alter_system_properties_tps_per_tom: Sets
 *                            the tps_per_tom value of the conf.
 *                                    <li>
 *                            gpudb::alter_system_properties_ai_api_provider:
 *                            AI API provider type
 *                                    <li>
 *                            gpudb::alter_system_properties_ai_api_url: AI API
 *                            URL
 *                                    <li>
 *                            gpudb::alter_system_properties_ai_api_key: AI API
 *                            key
 *                                    <li>
 *                            gpudb::alter_system_properties_ai_api_connection_timeout:
 *                            AI API connection timeout in seconds
 *                                    <li>
 *                            gpudb::alter_system_properties_postgres_proxy_idle_connection_timeout:
 *                            Idle connection timeout in seconds
 *                                    <li>
 *                            gpudb::alter_system_properties_postgres_proxy_keep_alive:
 *                            Enable  postgres proxy keep alive.  The default
 *                            value is 'false'.
 *                            </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::alter_system_properties_evict_to_cold:
 *                 If @a true and evict_columns is specified, the given objects
 *                 will be evicted to cold storage (if such a tier exists).
 *                 <ul>
 *                         <li> gpudb::alter_system_properties_true
 *                         <li> gpudb::alter_system_properties_false
 *                 </ul>
 *                         <li> gpudb::alter_system_properties_persist: If @a
 *                 true the system configuration will be written to disk upon
 *                 successful application of this request. This will commit the
 *                 changes from this request and any additional in-memory
 *                 modifications.
 *                 <ul>
 *                         <li> gpudb::alter_system_properties_true
 *                         <li> gpudb::alter_system_properties_false
 *                 </ul>
 *                 The default value is gpudb::alter_system_properties_true.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterSystemPropertiesResponse alterSystemProperties( const std::map<std::string, std::string>& propertyUpdatesMap,
                                                     const std::map<std::string, std::string>& options ) const;

/**
 * The {@link
 * #alterSystemProperties(const std::map<std::string, std::string>&,const std::map<std::string, std::string>&,AlterSystemPropertiesResponse&) const}
 * endpoint is primarily used to simplify the testing of the system and is not
 * expected to be used during normal execution.  Commands are given through the
 * @a propertyUpdatesMap whose keys are commands and values are strings
 * representing integer values (for example '8000') or boolean values ('true'
 * or 'false').
 * 
 * @param propertyUpdatesMap  Map containing the properties of the system to be
 *                            updated. Error if empty.
 *                            <ul>
 *                                    <li>
 *                            gpudb::alter_system_properties_sm_omp_threads:
 *                            Set the number of OpenMP threads that will be
 *                            used to service filter & aggregation requests to
 *                            the specified integer value.
 *                                    <li>
 *                            gpudb::alter_system_properties_kernel_omp_threads:
 *                            Set the number of kernel OpenMP threads to the
 *                            specified integer value.
 *                                    <li>
 *                            gpudb::alter_system_properties_concurrent_kernel_execution:
 *                            Enables concurrent kernel execution if the value
 *                            is @a true and disables it if the value is @a
 *                            false.
 *                            <ul>
 *                                    <li> gpudb::alter_system_properties_true
 *                                    <li> gpudb::alter_system_properties_false
 *                            </ul>
 *                                    <li>
 *                            gpudb::alter_system_properties_subtask_concurrency_limit:
 *                            Sets the maximum number of simultaneous threads
 *                            allocated to a given request, on each rank. Note
 *                            that thread allocation may also be limted by
 *                            resource group limits and/or system load.
 *                                    <li>
 *                            gpudb::alter_system_properties_chunk_size: Sets
 *                            the number of records per chunk to be used for
 *                            all new tables.
 *                                    <li>
 *                            gpudb::alter_system_properties_evict_columns:
 *                            Attempts to evict columns from memory to the
 *                            persistent store.  Value string is a semicolon
 *                            separated list of entries, each entry being a
 *                            table name optionally followed by a comma and a
 *                            comma separated list of column names to attempt
 *                            to evict.  An empty value string will attempt to
 *                            evict all tables and columns.
 *                                    <li>
 *                            gpudb::alter_system_properties_execution_mode:
 *                            Sets the execution_mode for kernel executions to
 *                            the specified string value. Possible values are
 *                            host, device, default (engine decides) or an
 *                            integer value that indicates max chunk size to
 *                            exec on host
 *                                    <li>
 *                            gpudb::alter_system_properties_external_files_directory:
 *                            Sets the root directory path where external table
 *                            data files are accessed from.  Path must exist on
 *                            the head node
 *                                    <li>
 *                            gpudb::alter_system_properties_flush_to_disk:
 *                            Flushes any changes to any tables to the
 *                            persistent store.  These changes include updates
 *                            to the vector store, object store, and text
 *                            search store, Value string is ignored
 *                                    <li>
 *                            gpudb::alter_system_properties_clear_cache:
 *                            Clears cached results.  Useful to allow repeated
 *                            timing of endpoints.  Value string is the name of
 *                            the table for which to clear the cached results,
 *                            or an empty string to clear the cached results
 *                            for all tables.
 *                                    <li>
 *                            gpudb::alter_system_properties_communicator_test:
 *                            Invoke the communicator test and report timing
 *                            results. Value string is a semicolon separated
 *                            list of [key]=[value] expressions.  Expressions
 *                            are: num_transactions=[num] where num is the
 *                            number of request reply transactions to invoke
 *                            per test; message_size=[bytes] where bytes is the
 *                            size in bytes of the messages to send;
 *                            check_values=[enabled] where if enabled is true
 *                            the value of the messages received are verified.
 *                                    <li>
 *                            gpudb::alter_system_properties_network_speed:
 *                            Invoke the network speed test and report timing
 *                            results. Value string is a semicolon-separated
 *                            list of [key]=[value] expressions.  Valid
 *                            expressions are: seconds=[time] where time is the
 *                            time in seconds to run the test;
 *                            data_size=[bytes] where bytes is the size in
 *                            bytes of the block to be transferred;
 *                            threads=[number of threads];
 *                            to_ranks=[space-separated list of ranks] where
 *                            the list of ranks is the ranks that rank 0 will
 *                            send data to and get data from. If to_ranks is
 *                            unspecified then all worker ranks are used.
 *                                    <li>
 *                            gpudb::alter_system_properties_request_timeout:
 *                            Number of minutes after which filtering (e.g.,
 *                            /filter) and aggregating (e.g.,
 *                            /aggregate/groupby) queries will timeout.  The
 *                            default value is '20'.
 *                                    <li>
 *                            gpudb::alter_system_properties_max_get_records_size:
 *                            The maximum number of records the database will
 *                            serve for a given data retrieval call.  The
 *                            default value is '20000'.
 *                                    <li>
 *                            gpudb::alter_system_properties_max_grbc_batch_size:
 *                            <DEVELOPER>
 *                                    <li>
 *                            gpudb::alter_system_properties_enable_audit:
 *                            Enable or disable auditing.
 *                                    <li>
 *                            gpudb::alter_system_properties_audit_headers:
 *                            Enable or disable auditing of request headers.
 *                                    <li>
 *                            gpudb::alter_system_properties_audit_body: Enable
 *                            or disable auditing of request bodies.
 *                                    <li>
 *                            gpudb::alter_system_properties_audit_data: Enable
 *                            or disable auditing of request data.
 *                                    <li>
 *                            gpudb::alter_system_properties_audit_response:
 *                            Enable or disable auditing of response
 *                            information.
 *                                    <li>
 *                            gpudb::alter_system_properties_shadow_agg_size:
 *                            Size of the shadow aggregate chunk cache in
 *                            bytes.  The default value is '10000000'.
 *                                    <li>
 *                            gpudb::alter_system_properties_shadow_filter_size:
 *                            Size of the shadow filter chunk cache in bytes.
 *                            The default value is '10000000'.
 *                                    <li>
 *                            gpudb::alter_system_properties_synchronous_compression:
 *                            compress vector on set_compression (instead of
 *                            waiting for background thread).  The default
 *                            value is 'false'.
 *                                    <li>
 *                            gpudb::alter_system_properties_enable_overlapped_equi_join:
 *                            Enable overlapped-equi-join filter.  The default
 *                            value is 'true'.
 *                                    <li>
 *                            gpudb::alter_system_properties_kafka_batch_size:
 *                            Maximum number of records to be ingested in a
 *                            single batch.  The default value is '1000'.
 *                                    <li>
 *                            gpudb::alter_system_properties_kafka_poll_timeout:
 *                            Maximum time (milliseconds) for each poll to get
 *                            records from kafka.  The default value is '0'.
 *                                    <li>
 *                            gpudb::alter_system_properties_kafka_wait_time:
 *                            Maximum time (seconds) to buffer records received
 *                            from kafka before ingestion.  The default value
 *                            is '30'.
 *                                    <li>
 *                            gpudb::alter_system_properties_egress_parquet_compression:
 *                            Parquet file compression type
 *                            <ul>
 *                                    <li>
 *                            gpudb::alter_system_properties_uncompressed
 *                                    <li>
 *                            gpudb::alter_system_properties_snappy
 *                                    <li> gpudb::alter_system_properties_gzip
 *                            </ul>
 *                            The default value is
 *                            gpudb::alter_system_properties_snappy.
 *                                    <li>
 *                            gpudb::alter_system_properties_egress_single_file_max_size:
 *                            Max file size (in MB) to allow saving to a single
 *                            file. May be overridden by target limitations.
 *                            The default value is '100'.
 *                                    <li>
 *                            gpudb::alter_system_properties_max_concurrent_kernels:
 *                            Sets the max_concurrent_kernels value of the
 *                            conf.
 *                                    <li>
 *                            gpudb::alter_system_properties_tcs_per_tom: Sets
 *                            the tcs_per_tom value of the conf.
 *                                    <li>
 *                            gpudb::alter_system_properties_tps_per_tom: Sets
 *                            the tps_per_tom value of the conf.
 *                                    <li>
 *                            gpudb::alter_system_properties_ai_api_provider:
 *                            AI API provider type
 *                                    <li>
 *                            gpudb::alter_system_properties_ai_api_url: AI API
 *                            URL
 *                                    <li>
 *                            gpudb::alter_system_properties_ai_api_key: AI API
 *                            key
 *                                    <li>
 *                            gpudb::alter_system_properties_ai_api_connection_timeout:
 *                            AI API connection timeout in seconds
 *                                    <li>
 *                            gpudb::alter_system_properties_postgres_proxy_idle_connection_timeout:
 *                            Idle connection timeout in seconds
 *                                    <li>
 *                            gpudb::alter_system_properties_postgres_proxy_keep_alive:
 *                            Enable  postgres proxy keep alive.  The default
 *                            value is 'false'.
 *                            </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::alter_system_properties_evict_to_cold:
 *                 If @a true and evict_columns is specified, the given objects
 *                 will be evicted to cold storage (if such a tier exists).
 *                 <ul>
 *                         <li> gpudb::alter_system_properties_true
 *                         <li> gpudb::alter_system_properties_false
 *                 </ul>
 *                         <li> gpudb::alter_system_properties_persist: If @a
 *                 true the system configuration will be written to disk upon
 *                 successful application of this request. This will commit the
 *                 changes from this request and any additional in-memory
 *                 modifications.
 *                 <ul>
 *                         <li> gpudb::alter_system_properties_true
 *                         <li> gpudb::alter_system_properties_false
 *                 </ul>
 *                 The default value is gpudb::alter_system_properties_true.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterSystemPropertiesResponse& alterSystemProperties( const std::map<std::string, std::string>& propertyUpdatesMap,
                                                      const std::map<std::string, std::string>& options,
                                                      AlterSystemPropertiesResponse& response_ ) const;

/**
 * Apply various modifications to a table or view.  The
 * available modifications include the following:
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../../concepts/types/" target="_top">type and properties</a>
 * modified, including whether it is
 * <a href="../../../concepts/dictionary_encoding/" target="_top">dictionary
 * encoded</a> or not.
 * <p>
 * External tables cannot be modified except for their refresh method.
 * <p>
 * Create or delete a <a href="../../../concepts/indexes/#column-index"
 * target="_top">column</a>,
 * <a href="../../../concepts/indexes/#chunk-skip-index" target="_top">chunk
 * skip</a>, or
 * <a href="../../../concepts/indexes/#geospatial-index"
 * target="_top">geospatial</a> index. This can speed up
 * certain operations when using expressions containing equality or relational
 * operators on indexed columns. This only applies to tables.
 * <p>
 * Create or delete a <a href="../../../concepts/tables/#foreign-key"
 * target="_top">foreign key</a>
 * on a particular column.
 * <p>
 * Manage a
 * <a href="../../../concepts/tables/#partitioning-by-range"
 * target="_top">range-partitioned</a> or a
 * <a href="../../../concepts/tables/#partitioning-by-list-manual"
 * target="_top">manual list-partitioned</a>
 * table's partitions.
 * <p>
 * Set (or reset) the <a href="../../../rm/concepts/#tier-strategies"
 * target="_top">tier strategy</a>
 * of a table or view.
 * <p>
 * Refresh and manage the refresh mode of a
 * <a href="../../../concepts/materialized_views/" target="_top">materialized
 * view</a> or an
 * <a href="../../../concepts/external_tables/" target="_top">external
 * table</a>.
 * <p>
 * Set the <a href="../../../concepts/ttl/" target="_top">time-to-live
 * (TTL)</a>. This can be applied
 * to tables or views.
 * <p>
 * Set the global access mode (i.e. locking) for a table. This setting trumps
 * any
 * role-based access controls that may be in place; e.g., a user with write
 * access
 * to a table marked read-only will not be able to insert records into it. The
 * mode
 * can be set to read-only, write-only, read/write, and no access.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableResponse alterTable( const AlterTableRequest& request_ ) const;

/**
 * Apply various modifications to a table or view.  The
 * available modifications include the following:
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../../concepts/types/" target="_top">type and properties</a>
 * modified, including whether it is
 * <a href="../../../concepts/dictionary_encoding/" target="_top">dictionary
 * encoded</a> or not.
 * <p>
 * External tables cannot be modified except for their refresh method.
 * <p>
 * Create or delete a <a href="../../../concepts/indexes/#column-index"
 * target="_top">column</a>,
 * <a href="../../../concepts/indexes/#chunk-skip-index" target="_top">chunk
 * skip</a>, or
 * <a href="../../../concepts/indexes/#geospatial-index"
 * target="_top">geospatial</a> index. This can speed up
 * certain operations when using expressions containing equality or relational
 * operators on indexed columns. This only applies to tables.
 * <p>
 * Create or delete a <a href="../../../concepts/tables/#foreign-key"
 * target="_top">foreign key</a>
 * on a particular column.
 * <p>
 * Manage a
 * <a href="../../../concepts/tables/#partitioning-by-range"
 * target="_top">range-partitioned</a> or a
 * <a href="../../../concepts/tables/#partitioning-by-list-manual"
 * target="_top">manual list-partitioned</a>
 * table's partitions.
 * <p>
 * Set (or reset) the <a href="../../../rm/concepts/#tier-strategies"
 * target="_top">tier strategy</a>
 * of a table or view.
 * <p>
 * Refresh and manage the refresh mode of a
 * <a href="../../../concepts/materialized_views/" target="_top">materialized
 * view</a> or an
 * <a href="../../../concepts/external_tables/" target="_top">external
 * table</a>.
 * <p>
 * Set the <a href="../../../concepts/ttl/" target="_top">time-to-live
 * (TTL)</a>. This can be applied
 * to tables or views.
 * <p>
 * Set the global access mode (i.e. locking) for a table. This setting trumps
 * any
 * role-based access controls that may be in place; e.g., a user with write
 * access
 * to a table marked read-only will not be able to insert records into it. The
 * mode
 * can be set to read-only, write-only, read/write, and no access.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableResponse& alterTable( const AlterTableRequest& request_,
                                AlterTableResponse& response_ ) const;

/**
 * Apply various modifications to a table or view.  The
 * available modifications include the following:
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../../concepts/types/" target="_top">type and properties</a>
 * modified, including whether it is
 * <a href="../../../concepts/dictionary_encoding/" target="_top">dictionary
 * encoded</a> or not.
 * <p>
 * External tables cannot be modified except for their refresh method.
 * <p>
 * Create or delete a <a href="../../../concepts/indexes/#column-index"
 * target="_top">column</a>,
 * <a href="../../../concepts/indexes/#chunk-skip-index" target="_top">chunk
 * skip</a>, or
 * <a href="../../../concepts/indexes/#geospatial-index"
 * target="_top">geospatial</a> index. This can speed up
 * certain operations when using expressions containing equality or relational
 * operators on indexed columns. This only applies to tables.
 * <p>
 * Create or delete a <a href="../../../concepts/tables/#foreign-key"
 * target="_top">foreign key</a>
 * on a particular column.
 * <p>
 * Manage a
 * <a href="../../../concepts/tables/#partitioning-by-range"
 * target="_top">range-partitioned</a> or a
 * <a href="../../../concepts/tables/#partitioning-by-list-manual"
 * target="_top">manual list-partitioned</a>
 * table's partitions.
 * <p>
 * Set (or reset) the <a href="../../../rm/concepts/#tier-strategies"
 * target="_top">tier strategy</a>
 * of a table or view.
 * <p>
 * Refresh and manage the refresh mode of a
 * <a href="../../../concepts/materialized_views/" target="_top">materialized
 * view</a> or an
 * <a href="../../../concepts/external_tables/" target="_top">external
 * table</a>.
 * <p>
 * Set the <a href="../../../concepts/ttl/" target="_top">time-to-live
 * (TTL)</a>. This can be applied
 * to tables or views.
 * <p>
 * Set the global access mode (i.e. locking) for a table. This setting trumps
 * any
 * role-based access controls that may be in place; e.g., a user with write
 * access
 * to a table marked read-only will not be able to insert records into it. The
 * mode
 * can be set to read-only, write-only, read/write, and no access.
 * 
 * @param tableName  Table on which the operation will be performed, in
 *                   [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 *                   Must be an existing table or view.
 * @param action  Modification operation to be applied
 *                <ul>
 *                        <li> gpudb::alter_table_allow_homogeneous_tables: No
 *                longer supported; action will be ignored.
 *                        <li> gpudb::alter_table_create_index: Creates a <a
 *                href="../../../concepts/indexes/#column-index"
 *                target="_top">column (attribute) index</a>,
 *                <a href="../../../concepts/indexes/#chunk-skip-index"
 *                target="_top">chunk skip index</a>, or
 *                <a href="../../../concepts/indexes/#geospatial-index"
 *                target="_top">geospatial index</a>
 *                (depending on the specified @a index_type), on the column
 *                name specified in @a value.
 *                If this column already has the specified index, an error will
 *                be returned.
 *                        <li> gpudb::alter_table_delete_index: Deletes a <a
 *                href="../../../concepts/indexes/#column-index"
 *                target="_top">column (attribute) index</a>,
 *                <a href="../../../concepts/indexes/#chunk-skip-index"
 *                target="_top">chunk skip index</a>, or
 *                <a href="../../../concepts/indexes/#geospatial-index"
 *                target="_top">geospatial index</a>
 *                (depending on the specified @a index_type), on the column
 *                name specified in @a value.
 *                If this column does not have the specified index, an error
 *                will be returned.
 *                        <li> gpudb::alter_table_move_to_collection:
 *                [DEPRECATED--please use @a move_to_schema and use
 *                /create/schema to create the schema if non-existent]  Moves a
 *                table or view into a schema named @a value.  If the schema
 *                provided is non-existent, it will be automatically created.
 *                        <li> gpudb::alter_table_move_to_schema: Moves a table
 *                or view into a schema named @a value.
 *                If the schema provided is nonexistent, an error will be
 *                thrown.
 *                If @a value is empty, then the table or view will be placed
 *                in the user's default schema.
 *                        <li> gpudb::alter_table_protected: No longer used.
 *                Previously set whether the given @a tableName should be
 *                protected or not. The @a value would have been either 'true'
 *                or 'false'.
 *                        <li> gpudb::alter_table_rename_table: Renames a table
 *                or view within its current schema to @a value. Has the same
 *                naming restrictions as <a href="../../../concepts/tables/"
 *                target="_top">tables</a>.
 *                        <li> gpudb::alter_table_ttl: Sets the <a
 *                href="../../../concepts/ttl/" target="_top">time-to-live</a>
 *                in minutes of the table or view specified in @a tableName.
 *                        <li> gpudb::alter_table_add_column: Adds the column
 *                specified in @a value to the table specified in @a tableName.
 *                Use @a column_type and @a column_properties in @a options
 *                to set the column's type and properties, respectively.
 *                        <li> gpudb::alter_table_change_column: Changes type
 *                and properties of the column specified in @a value.
 *                Use @a column_type and @a column_properties in @a options to
 *                set
 *                the column's type and properties, respectively. Note that
 *                primary key and/or shard key columns cannot be changed.
 *                All unchanging column properties must be listed for the
 *                change to take place, e.g., to add dictionary encoding to
 *                an existing 'char4' column, both 'char4' and 'dict' must be
 *                specified in the @a options map.
 *                        <li> gpudb::alter_table_set_column_compression: No
 *                longer supported; action will be ignored.
 *                        <li> gpudb::alter_table_delete_column: Deletes the
 *                column specified in @a value from the table specified in @a
 *                tableName.
 *                        <li> gpudb::alter_table_create_foreign_key: Creates a
 *                <a href="../../../concepts/tables/#foreign-key"
 *                target="_top">foreign key</a> specified in @a value using the
 *                format '(source_column_name [, ...]) references
 *                target_table_name(primary_key_column_name [, ...]) [as
 *                foreign_key_name]'.
 *                        <li> gpudb::alter_table_delete_foreign_key: Deletes a
 *                <a href="../../../concepts/tables/#foreign-key"
 *                target="_top">foreign key</a>.  The @a value should be the
 *                foreign_key_name specified when creating the key or the
 *                complete string used to define it.
 *                        <li> gpudb::alter_table_add_partition: Adds the
 *                partition specified in @a value, to either a <a
 *                href="../../../concepts/tables/#partitioning-by-range"
 *                target="_top">range-partitioned</a> or <a
 *                href="../../../concepts/tables/#partitioning-by-list-manual"
 *                target="_top">manual list-partitioned</a> table.
 *                        <li> gpudb::alter_table_remove_partition: Removes the
 *                partition specified in @a value (and relocates all of its
 *                data to the default partition) from either a <a
 *                href="../../../concepts/tables/#partitioning-by-range"
 *                target="_top">range-partitioned</a> or <a
 *                href="../../../concepts/tables/#partitioning-by-list-manual"
 *                target="_top">manual list-partitioned</a> table.
 *                        <li> gpudb::alter_table_delete_partition: Deletes the
 *                partition specified in @a value (and all of its data) from
 *                either a <a
 *                href="../../../concepts/tables/#partitioning-by-range"
 *                target="_top">range-partitioned</a> or <a
 *                href="../../../concepts/tables/#partitioning-by-list-manual"
 *                target="_top">manual list-partitioned</a> table.
 *                        <li> gpudb::alter_table_set_global_access_mode: Sets
 *                the global access mode (i.e. locking) for the table specified
 *                in @a tableName. Specify the access mode in @a value. Valid
 *                modes are 'no_access', 'read_only', 'write_only' and
 *                'read_write'.
 *                        <li> gpudb::alter_table_refresh: For a <a
 *                href="../../../concepts/materialized_views/"
 *                target="_top">materialized view</a>, replays all the table
 *                creation commands required to create the view.  For an <a
 *                href="../../../concepts/external_tables/"
 *                target="_top">external table</a>, reloads all data in the
 *                table from its associated source files or <a
 *                href="../../../concepts/data_sources/" target="_top">data
 *                source</a>.
 *                        <li> gpudb::alter_table_set_refresh_method: For a <a
 *                href="../../../concepts/materialized_views/"
 *                target="_top">materialized view</a>, sets the method by which
 *                the view is refreshed to the method specified in @a value -
 *                one of 'manual', 'periodic', or 'on_change'.  For an <a
 *                href="../../../concepts/external_tables/"
 *                target="_top">external table</a>, sets the method by which
 *                the table is refreshed to the method specified in @a value -
 *                either 'manual' or 'on_start'.
 *                        <li> gpudb::alter_table_set_refresh_start_time: Sets
 *                the time to start periodic refreshes of this <a
 *                href="../../../concepts/materialized_views/"
 *                target="_top">materialized view</a> to the datetime string
 *                specified in @a value with format 'YYYY-MM-DD HH:MM:SS'.
 *                Subsequent refreshes occur at the specified time + N * the
 *                refresh period.
 *                        <li> gpudb::alter_table_set_refresh_stop_time: Sets
 *                the time to stop periodic refreshes of this <a
 *                href="../../../concepts/materialized_views/"
 *                target="_top">materialized view</a> to the datetime string
 *                specified in @a value with format 'YYYY-MM-DD HH:MM:SS'.
 *                        <li> gpudb::alter_table_set_refresh_period: Sets the
 *                time interval in seconds at which to refresh this <a
 *                href="../../../concepts/materialized_views/"
 *                target="_top">materialized view</a> to the value specified in
 *                @a value.  Also, sets the refresh method to periodic if not
 *                already set.
 *                        <li> gpudb::alter_table_set_refresh_span: Sets the
 *                future time-offset(in seconds) for the view refresh to stop.
 *                        <li> gpudb::alter_table_set_refresh_execute_as: Sets
 *                the user name to refresh this <a
 *                href="../../../concepts/materialized_views/"
 *                target="_top">materialized view</a> to the value specified in
 *                @a value.
 *                        <li>
 *                gpudb::alter_table_remove_text_search_attributes: Removes <a
 *                href="../../../concepts/full_text_search/" target="_top">text
 *                search</a> attribute from all columns.
 *                        <li> gpudb::alter_table_remove_shard_keys: Removes
 *                the shard key property from all columns, so that the table
 *                will be considered randomly sharded.  The data is not moved.
 *                The @a value is ignored.
 *                        <li> gpudb::alter_table_set_strategy_definition: Sets
 *                the <a href="../../../rm/concepts/#tier-strategies"
 *                target="_top">tier strategy</a> for the table and its columns
 *                to the one specified in @a value, replacing the existing tier
 *                strategy in its entirety.
 *                        <li>
 *                gpudb::alter_table_cancel_datasource_subscription:
 *                Permanently unsubscribe a data source that is loading
 *                continuously as a stream. The data source can be Kafka / S3 /
 *                Azure.
 *                        <li>
 *                gpudb::alter_table_pause_datasource_subscription: Temporarily
 *                unsubscribe a data source that is loading continuously as a
 *                stream. The data source can be Kafka / S3 / Azure.
 *                        <li>
 *                gpudb::alter_table_resume_datasource_subscription:
 *                Resubscribe to a paused data source subscription. The data
 *                source can be Kafka / S3 / Azure.
 *                        <li> gpudb::alter_table_change_owner: Change the
 *                owner resource group of the table.
 *                </ul>
 * @param value  The value of the modification, depending on @a action.
 *               For example, if @a action is @a add_column, this would be the
 *               column name;
 *               while the column's definition would be covered by the @a
 *               column_type,
 *               @a column_properties, @a column_default_value,
 *               and @a add_column_expression in @a options.
 *               If @a action is @a ttl, it would be the number of minutes for
 *               the new TTL.
 *               If @a action is @a refresh, this field would be blank.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::alter_table_action
 *                         <li> gpudb::alter_table_column_name
 *                         <li> gpudb::alter_table_table_name
 *                         <li> gpudb::alter_table_column_default_value: When
 *                 adding a column, set a default value for existing records.
 *                 For nullable columns, the default value will be null,
 *                 regardless of data type.
 *                         <li> gpudb::alter_table_column_properties: When
 *                 adding or changing a column, set the column properties
 *                 (strings, separated by a comma: data, store_only,
 *                 text_search, char8, int8 etc).
 *                         <li> gpudb::alter_table_column_type: When adding or
 *                 changing a column, set the column type (strings, separated
 *                 by a comma: int, double, string, null etc).
 *                         <li> gpudb::alter_table_compression_type: No longer
 *                 supported; option will be ignored.
 *                 <ul>
 *                         <li> gpudb::alter_table_none
 *                         <li> gpudb::alter_table_snappy
 *                         <li> gpudb::alter_table_lz4
 *                         <li> gpudb::alter_table_lz4hc
 *                 </ul>
 *                 The default value is gpudb::alter_table_snappy.
 *                         <li> gpudb::alter_table_copy_values_from_column:
 *                 [DEPRECATED--please use @a add_column_expression instead.]
 *                         <li> gpudb::alter_table_rename_column: When changing
 *                 a column, specify new column name.
 *                         <li> gpudb::alter_table_validate_change_column: When
 *                 changing a column, validate the change before applying it
 *                 (or not).
 *                 <ul>
 *                         <li> gpudb::alter_table_true: Validate all values. A
 *                 value too large (or too long) for the new type will prevent
 *                 any change.
 *                         <li> gpudb::alter_table_false: When a value is too
 *                 large or long, it will be truncated.
 *                 </ul>
 *                 The default value is gpudb::alter_table_true.
 *                         <li> gpudb::alter_table_update_last_access_time:
 *                 Indicates whether the <a href="../../../concepts/ttl/"
 *                 target="_top">time-to-live</a> (TTL) expiration countdown
 *                 timer should be reset to the table's TTL.
 *                 <ul>
 *                         <li> gpudb::alter_table_true: Reset the expiration
 *                 countdown timer to the table's configured TTL.
 *                         <li> gpudb::alter_table_false: Don't reset the
 *                 timer; expiration countdown will continue from where it is,
 *                 as if the table had not been accessed.
 *                 </ul>
 *                 The default value is gpudb::alter_table_true.
 *                         <li> gpudb::alter_table_add_column_expression: When
 *                 adding a column, an optional expression to use for the new
 *                 column's values. Any valid expression may be used, including
 *                 one containing references to existing columns in the same
 *                 table.
 *                         <li> gpudb::alter_table_strategy_definition:
 *                 Optional parameter for specifying the <a
 *                 href="../../../rm/concepts/#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns when @a action is @a set_strategy_definition,
 *                 replacing the existing tier strategy in its entirety.
 *                         <li> gpudb::alter_table_index_type: Type of index to
 *                 create, when @a action is @a create_index,
 *                 or to delete, when @a action is @a delete_index.
 *                 <ul>
 *                         <li> gpudb::alter_table_column: Create or delete a
 *                 <a href="../../../concepts/indexes/#column-index"
 *                 target="_top">column (attribute) index</a>.
 *                         <li> gpudb::alter_table_chunk_skip: Create or delete
 *                 a <a href="../../../concepts/indexes/#chunk-skip-index"
 *                 target="_top">chunk skip index</a>.
 *                         <li> gpudb::alter_table_geospatial: Create or delete
 *                 a geospatial index
 *                 </ul>
 *                 The default value is gpudb::alter_table_column.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableResponse alterTable( const std::string& tableName,
                               const std::string& action,
                               const std::string& value,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Apply various modifications to a table or view.  The
 * available modifications include the following:
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../../concepts/types/" target="_top">type and properties</a>
 * modified, including whether it is
 * <a href="../../../concepts/dictionary_encoding/" target="_top">dictionary
 * encoded</a> or not.
 * <p>
 * External tables cannot be modified except for their refresh method.
 * <p>
 * Create or delete a <a href="../../../concepts/indexes/#column-index"
 * target="_top">column</a>,
 * <a href="../../../concepts/indexes/#chunk-skip-index" target="_top">chunk
 * skip</a>, or
 * <a href="../../../concepts/indexes/#geospatial-index"
 * target="_top">geospatial</a> index. This can speed up
 * certain operations when using expressions containing equality or relational
 * operators on indexed columns. This only applies to tables.
 * <p>
 * Create or delete a <a href="../../../concepts/tables/#foreign-key"
 * target="_top">foreign key</a>
 * on a particular column.
 * <p>
 * Manage a
 * <a href="../../../concepts/tables/#partitioning-by-range"
 * target="_top">range-partitioned</a> or a
 * <a href="../../../concepts/tables/#partitioning-by-list-manual"
 * target="_top">manual list-partitioned</a>
 * table's partitions.
 * <p>
 * Set (or reset) the <a href="../../../rm/concepts/#tier-strategies"
 * target="_top">tier strategy</a>
 * of a table or view.
 * <p>
 * Refresh and manage the refresh mode of a
 * <a href="../../../concepts/materialized_views/" target="_top">materialized
 * view</a> or an
 * <a href="../../../concepts/external_tables/" target="_top">external
 * table</a>.
 * <p>
 * Set the <a href="../../../concepts/ttl/" target="_top">time-to-live
 * (TTL)</a>. This can be applied
 * to tables or views.
 * <p>
 * Set the global access mode (i.e. locking) for a table. This setting trumps
 * any
 * role-based access controls that may be in place; e.g., a user with write
 * access
 * to a table marked read-only will not be able to insert records into it. The
 * mode
 * can be set to read-only, write-only, read/write, and no access.
 * 
 * @param tableName  Table on which the operation will be performed, in
 *                   [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 *                   Must be an existing table or view.
 * @param action  Modification operation to be applied
 *                <ul>
 *                        <li> gpudb::alter_table_allow_homogeneous_tables: No
 *                longer supported; action will be ignored.
 *                        <li> gpudb::alter_table_create_index: Creates a <a
 *                href="../../../concepts/indexes/#column-index"
 *                target="_top">column (attribute) index</a>,
 *                <a href="../../../concepts/indexes/#chunk-skip-index"
 *                target="_top">chunk skip index</a>, or
 *                <a href="../../../concepts/indexes/#geospatial-index"
 *                target="_top">geospatial index</a>
 *                (depending on the specified @a index_type), on the column
 *                name specified in @a value.
 *                If this column already has the specified index, an error will
 *                be returned.
 *                        <li> gpudb::alter_table_delete_index: Deletes a <a
 *                href="../../../concepts/indexes/#column-index"
 *                target="_top">column (attribute) index</a>,
 *                <a href="../../../concepts/indexes/#chunk-skip-index"
 *                target="_top">chunk skip index</a>, or
 *                <a href="../../../concepts/indexes/#geospatial-index"
 *                target="_top">geospatial index</a>
 *                (depending on the specified @a index_type), on the column
 *                name specified in @a value.
 *                If this column does not have the specified index, an error
 *                will be returned.
 *                        <li> gpudb::alter_table_move_to_collection:
 *                [DEPRECATED--please use @a move_to_schema and use
 *                /create/schema to create the schema if non-existent]  Moves a
 *                table or view into a schema named @a value.  If the schema
 *                provided is non-existent, it will be automatically created.
 *                        <li> gpudb::alter_table_move_to_schema: Moves a table
 *                or view into a schema named @a value.
 *                If the schema provided is nonexistent, an error will be
 *                thrown.
 *                If @a value is empty, then the table or view will be placed
 *                in the user's default schema.
 *                        <li> gpudb::alter_table_protected: No longer used.
 *                Previously set whether the given @a tableName should be
 *                protected or not. The @a value would have been either 'true'
 *                or 'false'.
 *                        <li> gpudb::alter_table_rename_table: Renames a table
 *                or view within its current schema to @a value. Has the same
 *                naming restrictions as <a href="../../../concepts/tables/"
 *                target="_top">tables</a>.
 *                        <li> gpudb::alter_table_ttl: Sets the <a
 *                href="../../../concepts/ttl/" target="_top">time-to-live</a>
 *                in minutes of the table or view specified in @a tableName.
 *                        <li> gpudb::alter_table_add_column: Adds the column
 *                specified in @a value to the table specified in @a tableName.
 *                Use @a column_type and @a column_properties in @a options
 *                to set the column's type and properties, respectively.
 *                        <li> gpudb::alter_table_change_column: Changes type
 *                and properties of the column specified in @a value.
 *                Use @a column_type and @a column_properties in @a options to
 *                set
 *                the column's type and properties, respectively. Note that
 *                primary key and/or shard key columns cannot be changed.
 *                All unchanging column properties must be listed for the
 *                change to take place, e.g., to add dictionary encoding to
 *                an existing 'char4' column, both 'char4' and 'dict' must be
 *                specified in the @a options map.
 *                        <li> gpudb::alter_table_set_column_compression: No
 *                longer supported; action will be ignored.
 *                        <li> gpudb::alter_table_delete_column: Deletes the
 *                column specified in @a value from the table specified in @a
 *                tableName.
 *                        <li> gpudb::alter_table_create_foreign_key: Creates a
 *                <a href="../../../concepts/tables/#foreign-key"
 *                target="_top">foreign key</a> specified in @a value using the
 *                format '(source_column_name [, ...]) references
 *                target_table_name(primary_key_column_name [, ...]) [as
 *                foreign_key_name]'.
 *                        <li> gpudb::alter_table_delete_foreign_key: Deletes a
 *                <a href="../../../concepts/tables/#foreign-key"
 *                target="_top">foreign key</a>.  The @a value should be the
 *                foreign_key_name specified when creating the key or the
 *                complete string used to define it.
 *                        <li> gpudb::alter_table_add_partition: Adds the
 *                partition specified in @a value, to either a <a
 *                href="../../../concepts/tables/#partitioning-by-range"
 *                target="_top">range-partitioned</a> or <a
 *                href="../../../concepts/tables/#partitioning-by-list-manual"
 *                target="_top">manual list-partitioned</a> table.
 *                        <li> gpudb::alter_table_remove_partition: Removes the
 *                partition specified in @a value (and relocates all of its
 *                data to the default partition) from either a <a
 *                href="../../../concepts/tables/#partitioning-by-range"
 *                target="_top">range-partitioned</a> or <a
 *                href="../../../concepts/tables/#partitioning-by-list-manual"
 *                target="_top">manual list-partitioned</a> table.
 *                        <li> gpudb::alter_table_delete_partition: Deletes the
 *                partition specified in @a value (and all of its data) from
 *                either a <a
 *                href="../../../concepts/tables/#partitioning-by-range"
 *                target="_top">range-partitioned</a> or <a
 *                href="../../../concepts/tables/#partitioning-by-list-manual"
 *                target="_top">manual list-partitioned</a> table.
 *                        <li> gpudb::alter_table_set_global_access_mode: Sets
 *                the global access mode (i.e. locking) for the table specified
 *                in @a tableName. Specify the access mode in @a value. Valid
 *                modes are 'no_access', 'read_only', 'write_only' and
 *                'read_write'.
 *                        <li> gpudb::alter_table_refresh: For a <a
 *                href="../../../concepts/materialized_views/"
 *                target="_top">materialized view</a>, replays all the table
 *                creation commands required to create the view.  For an <a
 *                href="../../../concepts/external_tables/"
 *                target="_top">external table</a>, reloads all data in the
 *                table from its associated source files or <a
 *                href="../../../concepts/data_sources/" target="_top">data
 *                source</a>.
 *                        <li> gpudb::alter_table_set_refresh_method: For a <a
 *                href="../../../concepts/materialized_views/"
 *                target="_top">materialized view</a>, sets the method by which
 *                the view is refreshed to the method specified in @a value -
 *                one of 'manual', 'periodic', or 'on_change'.  For an <a
 *                href="../../../concepts/external_tables/"
 *                target="_top">external table</a>, sets the method by which
 *                the table is refreshed to the method specified in @a value -
 *                either 'manual' or 'on_start'.
 *                        <li> gpudb::alter_table_set_refresh_start_time: Sets
 *                the time to start periodic refreshes of this <a
 *                href="../../../concepts/materialized_views/"
 *                target="_top">materialized view</a> to the datetime string
 *                specified in @a value with format 'YYYY-MM-DD HH:MM:SS'.
 *                Subsequent refreshes occur at the specified time + N * the
 *                refresh period.
 *                        <li> gpudb::alter_table_set_refresh_stop_time: Sets
 *                the time to stop periodic refreshes of this <a
 *                href="../../../concepts/materialized_views/"
 *                target="_top">materialized view</a> to the datetime string
 *                specified in @a value with format 'YYYY-MM-DD HH:MM:SS'.
 *                        <li> gpudb::alter_table_set_refresh_period: Sets the
 *                time interval in seconds at which to refresh this <a
 *                href="../../../concepts/materialized_views/"
 *                target="_top">materialized view</a> to the value specified in
 *                @a value.  Also, sets the refresh method to periodic if not
 *                already set.
 *                        <li> gpudb::alter_table_set_refresh_span: Sets the
 *                future time-offset(in seconds) for the view refresh to stop.
 *                        <li> gpudb::alter_table_set_refresh_execute_as: Sets
 *                the user name to refresh this <a
 *                href="../../../concepts/materialized_views/"
 *                target="_top">materialized view</a> to the value specified in
 *                @a value.
 *                        <li>
 *                gpudb::alter_table_remove_text_search_attributes: Removes <a
 *                href="../../../concepts/full_text_search/" target="_top">text
 *                search</a> attribute from all columns.
 *                        <li> gpudb::alter_table_remove_shard_keys: Removes
 *                the shard key property from all columns, so that the table
 *                will be considered randomly sharded.  The data is not moved.
 *                The @a value is ignored.
 *                        <li> gpudb::alter_table_set_strategy_definition: Sets
 *                the <a href="../../../rm/concepts/#tier-strategies"
 *                target="_top">tier strategy</a> for the table and its columns
 *                to the one specified in @a value, replacing the existing tier
 *                strategy in its entirety.
 *                        <li>
 *                gpudb::alter_table_cancel_datasource_subscription:
 *                Permanently unsubscribe a data source that is loading
 *                continuously as a stream. The data source can be Kafka / S3 /
 *                Azure.
 *                        <li>
 *                gpudb::alter_table_pause_datasource_subscription: Temporarily
 *                unsubscribe a data source that is loading continuously as a
 *                stream. The data source can be Kafka / S3 / Azure.
 *                        <li>
 *                gpudb::alter_table_resume_datasource_subscription:
 *                Resubscribe to a paused data source subscription. The data
 *                source can be Kafka / S3 / Azure.
 *                        <li> gpudb::alter_table_change_owner: Change the
 *                owner resource group of the table.
 *                </ul>
 * @param value  The value of the modification, depending on @a action.
 *               For example, if @a action is @a add_column, this would be the
 *               column name;
 *               while the column's definition would be covered by the @a
 *               column_type,
 *               @a column_properties, @a column_default_value,
 *               and @a add_column_expression in @a options.
 *               If @a action is @a ttl, it would be the number of minutes for
 *               the new TTL.
 *               If @a action is @a refresh, this field would be blank.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::alter_table_action
 *                         <li> gpudb::alter_table_column_name
 *                         <li> gpudb::alter_table_table_name
 *                         <li> gpudb::alter_table_column_default_value: When
 *                 adding a column, set a default value for existing records.
 *                 For nullable columns, the default value will be null,
 *                 regardless of data type.
 *                         <li> gpudb::alter_table_column_properties: When
 *                 adding or changing a column, set the column properties
 *                 (strings, separated by a comma: data, store_only,
 *                 text_search, char8, int8 etc).
 *                         <li> gpudb::alter_table_column_type: When adding or
 *                 changing a column, set the column type (strings, separated
 *                 by a comma: int, double, string, null etc).
 *                         <li> gpudb::alter_table_compression_type: No longer
 *                 supported; option will be ignored.
 *                 <ul>
 *                         <li> gpudb::alter_table_none
 *                         <li> gpudb::alter_table_snappy
 *                         <li> gpudb::alter_table_lz4
 *                         <li> gpudb::alter_table_lz4hc
 *                 </ul>
 *                 The default value is gpudb::alter_table_snappy.
 *                         <li> gpudb::alter_table_copy_values_from_column:
 *                 [DEPRECATED--please use @a add_column_expression instead.]
 *                         <li> gpudb::alter_table_rename_column: When changing
 *                 a column, specify new column name.
 *                         <li> gpudb::alter_table_validate_change_column: When
 *                 changing a column, validate the change before applying it
 *                 (or not).
 *                 <ul>
 *                         <li> gpudb::alter_table_true: Validate all values. A
 *                 value too large (or too long) for the new type will prevent
 *                 any change.
 *                         <li> gpudb::alter_table_false: When a value is too
 *                 large or long, it will be truncated.
 *                 </ul>
 *                 The default value is gpudb::alter_table_true.
 *                         <li> gpudb::alter_table_update_last_access_time:
 *                 Indicates whether the <a href="../../../concepts/ttl/"
 *                 target="_top">time-to-live</a> (TTL) expiration countdown
 *                 timer should be reset to the table's TTL.
 *                 <ul>
 *                         <li> gpudb::alter_table_true: Reset the expiration
 *                 countdown timer to the table's configured TTL.
 *                         <li> gpudb::alter_table_false: Don't reset the
 *                 timer; expiration countdown will continue from where it is,
 *                 as if the table had not been accessed.
 *                 </ul>
 *                 The default value is gpudb::alter_table_true.
 *                         <li> gpudb::alter_table_add_column_expression: When
 *                 adding a column, an optional expression to use for the new
 *                 column's values. Any valid expression may be used, including
 *                 one containing references to existing columns in the same
 *                 table.
 *                         <li> gpudb::alter_table_strategy_definition:
 *                 Optional parameter for specifying the <a
 *                 href="../../../rm/concepts/#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns when @a action is @a set_strategy_definition,
 *                 replacing the existing tier strategy in its entirety.
 *                         <li> gpudb::alter_table_index_type: Type of index to
 *                 create, when @a action is @a create_index,
 *                 or to delete, when @a action is @a delete_index.
 *                 <ul>
 *                         <li> gpudb::alter_table_column: Create or delete a
 *                 <a href="../../../concepts/indexes/#column-index"
 *                 target="_top">column (attribute) index</a>.
 *                         <li> gpudb::alter_table_chunk_skip: Create or delete
 *                 a <a href="../../../concepts/indexes/#chunk-skip-index"
 *                 target="_top">chunk skip index</a>.
 *                         <li> gpudb::alter_table_geospatial: Create or delete
 *                 a geospatial index
 *                 </ul>
 *                 The default value is gpudb::alter_table_column.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableResponse& alterTable( const std::string& tableName,
                                const std::string& action,
                                const std::string& value,
                                const std::map<std::string, std::string>& options,
                                AlterTableResponse& response_ ) const;

/**
 * Apply various modifications to columns in a table, view.  The available
 * modifications include the following:
 * <p>
 * Create or delete an <a href="../../../concepts/indexes/#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../../concepts/types/" target="_top">type and properties</a>
 * modified, including whether it is
 * <a href="../../../concepts/dictionary_encoding/" target="_top">dictionary
 * encoded</a> or not.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableColumnsResponse alterTableColumns( const AlterTableColumnsRequest& request_ ) const;

/**
 * Apply various modifications to columns in a table, view.  The available
 * modifications include the following:
 * <p>
 * Create or delete an <a href="../../../concepts/indexes/#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../../concepts/types/" target="_top">type and properties</a>
 * modified, including whether it is
 * <a href="../../../concepts/dictionary_encoding/" target="_top">dictionary
 * encoded</a> or not.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableColumnsResponse& alterTableColumns( const AlterTableColumnsRequest& request_,
                                              AlterTableColumnsResponse& response_ ) const;

/**
 * Apply various modifications to columns in a table, view.  The available
 * modifications include the following:
 * <p>
 * Create or delete an <a href="../../../concepts/indexes/#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../../concepts/types/" target="_top">type and properties</a>
 * modified, including whether it is
 * <a href="../../../concepts/dictionary_encoding/" target="_top">dictionary
 * encoded</a> or not.
 * 
 * @param tableName  Table on which the operation will be performed. Must be an
 *                   existing table or view, in [schema_name.]table_name
 *                   format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnAlterations  List of alter table add/delete/change column
 *                           requests - all for the same table. Each request is
 *                           a map that includes 'column_name', 'action' and
 *                           the options specific for the action. Note that the
 *                           same options as in alter table requests but in the
 *                           same map as the column name and the action. For
 *                           example:
 *                           [{'column_name':'col_1','action':'change_column','rename_column':'col_2'},{'column_name':'col_1','action':'add_column',
 *                           'type':'int','default_value':'1'}]
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableColumnsResponse alterTableColumns( const std::string& tableName,
                                             const std::vector<std::map<std::string, std::string> >& columnAlterations,
                                             const std::map<std::string, std::string>& options ) const;

/**
 * Apply various modifications to columns in a table, view.  The available
 * modifications include the following:
 * <p>
 * Create or delete an <a href="../../../concepts/indexes/#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../../concepts/types/" target="_top">type and properties</a>
 * modified, including whether it is
 * <a href="../../../concepts/dictionary_encoding/" target="_top">dictionary
 * encoded</a> or not.
 * 
 * @param tableName  Table on which the operation will be performed. Must be an
 *                   existing table or view, in [schema_name.]table_name
 *                   format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param columnAlterations  List of alter table add/delete/change column
 *                           requests - all for the same table. Each request is
 *                           a map that includes 'column_name', 'action' and
 *                           the options specific for the action. Note that the
 *                           same options as in alter table requests but in the
 *                           same map as the column name and the action. For
 *                           example:
 *                           [{'column_name':'col_1','action':'change_column','rename_column':'col_2'},{'column_name':'col_1','action':'add_column',
 *                           'type':'int','default_value':'1'}]
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableColumnsResponse& alterTableColumns( const std::string& tableName,
                                              const std::vector<std::map<std::string, std::string> >& columnAlterations,
                                              const std::map<std::string, std::string>& options,
                                              AlterTableColumnsResponse& response_ ) const;

/**
 * Updates (adds or changes) metadata for tables. The metadata key and
 * values must both be strings. This is an easy way to annotate whole tables
 * rather
 * than single records within tables.  Some examples of metadata are owner of
 * the
 * table, table creation timestamp etc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableMetadataResponse alterTableMetadata( const AlterTableMetadataRequest& request_ ) const;

/**
 * Updates (adds or changes) metadata for tables. The metadata key and
 * values must both be strings. This is an easy way to annotate whole tables
 * rather
 * than single records within tables.  Some examples of metadata are owner of
 * the
 * table, table creation timestamp etc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableMetadataResponse& alterTableMetadata( const AlterTableMetadataRequest& request_,
                                                AlterTableMetadataResponse& response_ ) const;

/**
 * Updates (adds or changes) metadata for tables. The metadata key and
 * values must both be strings. This is an easy way to annotate whole tables
 * rather
 * than single records within tables.  Some examples of metadata are owner of
 * the
 * table, table creation timestamp etc.
 * 
 * @param tableNames  Names of the tables whose metadata will be updated, in
 *                    [schema_name.]table_name format, using standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.  All specified
 *                    tables must exist, or an error will be returned.
 * @param metadataMap  A map which contains the metadata of the tables that are
 *                     to be updated. Note that only one map is provided for
 *                     all the tables; so the change will be applied to every
 *                     table. If the provided map is empty, then all existing
 *                     metadata for the table(s) will be cleared.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableMetadataResponse alterTableMetadata( const std::vector<std::string>& tableNames,
                                               const std::map<std::string, std::string>& metadataMap,
                                               const std::map<std::string, std::string>& options ) const;

/**
 * Updates (adds or changes) metadata for tables. The metadata key and
 * values must both be strings. This is an easy way to annotate whole tables
 * rather
 * than single records within tables.  Some examples of metadata are owner of
 * the
 * table, table creation timestamp etc.
 * 
 * @param tableNames  Names of the tables whose metadata will be updated, in
 *                    [schema_name.]table_name format, using standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.  All specified
 *                    tables must exist, or an error will be returned.
 * @param metadataMap  A map which contains the metadata of the tables that are
 *                     to be updated. Note that only one map is provided for
 *                     all the tables; so the change will be applied to every
 *                     table. If the provided map is empty, then all existing
 *                     metadata for the table(s) will be cleared.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableMetadataResponse& alterTableMetadata( const std::vector<std::string>& tableNames,
                                                const std::map<std::string, std::string>& metadataMap,
                                                const std::map<std::string, std::string>& options,
                                                AlterTableMetadataResponse& response_ ) const;

/**
 * Alters a table monitor previously created with {@link
 * #createTableMonitor(const CreateTableMonitorRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableMonitorResponse alterTableMonitor( const AlterTableMonitorRequest& request_ ) const;

/**
 * Alters a table monitor previously created with {@link
 * #createTableMonitor(const CreateTableMonitorRequest&,CreateTableMonitorResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableMonitorResponse& alterTableMonitor( const AlterTableMonitorRequest& request_,
                                              AlterTableMonitorResponse& response_ ) const;

/**
 * Alters a table monitor previously created with {@link
 * #createTableMonitor(const std::string&,const std::map<std::string, std::string>&) const}.
 * 
 * @param topicId  The topic ID returned by /create/tablemonitor.
 * @param monitorUpdatesMap  Map containing the properties of the table monitor
 *                           to be updated. Error if empty.
 *                           <ul>
 *                                   <li>
 *                           gpudb::alter_table_monitor_schema_name: Updates
 *                           the schema name.  If @a schema_name
 *                           doesn't exist, an error will be thrown. If @a
 *                           schema_name is empty, then the user's
 *                           default schema will be used.
 *                           </ul>
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableMonitorResponse alterTableMonitor( const std::string& topicId,
                                             const std::map<std::string, std::string>& monitorUpdatesMap,
                                             const std::map<std::string, std::string>& options ) const;

/**
 * Alters a table monitor previously created with {@link
 * #createTableMonitor(const std::string&,const std::map<std::string, std::string>&,CreateTableMonitorResponse&) const}.
 * 
 * @param topicId  The topic ID returned by /create/tablemonitor.
 * @param monitorUpdatesMap  Map containing the properties of the table monitor
 *                           to be updated. Error if empty.
 *                           <ul>
 *                                   <li>
 *                           gpudb::alter_table_monitor_schema_name: Updates
 *                           the schema name.  If @a schema_name
 *                           doesn't exist, an error will be thrown. If @a
 *                           schema_name is empty, then the user's
 *                           default schema will be used.
 *                           </ul>
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableMonitorResponse& alterTableMonitor( const std::string& topicId,
                                              const std::map<std::string, std::string>& monitorUpdatesMap,
                                              const std::map<std::string, std::string>& options,
                                              AlterTableMonitorResponse& response_ ) const;

/**
 * Alters properties of an exisiting
 * <a href="../../../rm/concepts/#storage-tiers" target="_top">tier</a> to
 * facilitate
 * <a href="../../../rm/concepts/" target="_top">resource management</a>.
 * <p>
 * To disable
 * <a href="../../../rm/concepts/#watermark-based-eviction"
 * target="_top">watermark-based eviction</a>,
 * set both @a high_watermark and
 * @a low_watermark to 100.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTierResponse alterTier( const AlterTierRequest& request_ ) const;

/**
 * Alters properties of an exisiting
 * <a href="../../../rm/concepts/#storage-tiers" target="_top">tier</a> to
 * facilitate
 * <a href="../../../rm/concepts/" target="_top">resource management</a>.
 * <p>
 * To disable
 * <a href="../../../rm/concepts/#watermark-based-eviction"
 * target="_top">watermark-based eviction</a>,
 * set both @a high_watermark and
 * @a low_watermark to 100.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTierResponse& alterTier( const AlterTierRequest& request_,
                              AlterTierResponse& response_ ) const;

/**
 * Alters properties of an exisiting
 * <a href="../../../rm/concepts/#storage-tiers" target="_top">tier</a> to
 * facilitate
 * <a href="../../../rm/concepts/" target="_top">resource management</a>.
 * <p>
 * To disable
 * <a href="../../../rm/concepts/#watermark-based-eviction"
 * target="_top">watermark-based eviction</a>,
 * set both @a high_watermark and
 * @a low_watermark to 100.
 * 
 * @param name  Name of the tier to be altered. Must be an existing tier group
 *              name.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::alter_tier_capacity: Maximum size in
 *                 bytes this tier may hold at once.
 *                         <li> gpudb::alter_tier_high_watermark: Threshold of
 *                 usage of this tier's resource that once exceeded, will
 *                 trigger watermark-based eviction from this tier.
 *                         <li> gpudb::alter_tier_low_watermark: Threshold of
 *                 resource usage that once fallen below after crossing the @a
 *                 high_watermark, will cease watermark-based eviction from
 *                 this tier.
 *                         <li> gpudb::alter_tier_wait_timeout: Timeout in
 *                 seconds for reading from or writing to this resource.
 *                 Applies to cold storage tiers only.
 *                         <li> gpudb::alter_tier_persist: If @a true the
 *                 system configuration will be written to disk upon successful
 *                 application of this request. This will commit the changes
 *                 from this request and any additional in-memory
 *                 modifications.
 *                 <ul>
 *                         <li> gpudb::alter_tier_true
 *                         <li> gpudb::alter_tier_false
 *                 </ul>
 *                 The default value is gpudb::alter_tier_true.
 *                         <li> gpudb::alter_tier_rank: Apply the requested
 *                 change only to a specific rank.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTierResponse alterTier( const std::string& name,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Alters properties of an exisiting
 * <a href="../../../rm/concepts/#storage-tiers" target="_top">tier</a> to
 * facilitate
 * <a href="../../../rm/concepts/" target="_top">resource management</a>.
 * <p>
 * To disable
 * <a href="../../../rm/concepts/#watermark-based-eviction"
 * target="_top">watermark-based eviction</a>,
 * set both @a high_watermark and
 * @a low_watermark to 100.
 * 
 * @param name  Name of the tier to be altered. Must be an existing tier group
 *              name.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::alter_tier_capacity: Maximum size in
 *                 bytes this tier may hold at once.
 *                         <li> gpudb::alter_tier_high_watermark: Threshold of
 *                 usage of this tier's resource that once exceeded, will
 *                 trigger watermark-based eviction from this tier.
 *                         <li> gpudb::alter_tier_low_watermark: Threshold of
 *                 resource usage that once fallen below after crossing the @a
 *                 high_watermark, will cease watermark-based eviction from
 *                 this tier.
 *                         <li> gpudb::alter_tier_wait_timeout: Timeout in
 *                 seconds for reading from or writing to this resource.
 *                 Applies to cold storage tiers only.
 *                         <li> gpudb::alter_tier_persist: If @a true the
 *                 system configuration will be written to disk upon successful
 *                 application of this request. This will commit the changes
 *                 from this request and any additional in-memory
 *                 modifications.
 *                 <ul>
 *                         <li> gpudb::alter_tier_true
 *                         <li> gpudb::alter_tier_false
 *                 </ul>
 *                 The default value is gpudb::alter_tier_true.
 *                         <li> gpudb::alter_tier_rank: Apply the requested
 *                 change only to a specific rank.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTierResponse& alterTier( const std::string& name,
                              const std::map<std::string, std::string>& options,
                              AlterTierResponse& response_ ) const;

/**
 * Alters a user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterUserResponse alterUser( const AlterUserRequest& request_ ) const;

/**
 * Alters a user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterUserResponse& alterUser( const AlterUserRequest& request_,
                              AlterUserResponse& response_ ) const;

/**
 * Alters a user.
 * 
 * @param name  Name of the user to be altered. Must be an existing user.
 * @param action  Modification operation to be applied to the user.
 *                <ul>
 *                        <li> gpudb::alter_user_set_password: Sets the
 *                password of the user. The user must be an internal user.
 *                        <li> gpudb::alter_user_set_resource_group: Sets the
 *                resource group for an internal user. The resource group must
 *                exist, otherwise, an empty string assigns the user to the
 *                default resource group.
 *                        <li> gpudb::alter_user_set_default_schema: Set the
 *                default_schema for an internal user. An empty string means
 *                the user will have no default schema.
 *                </ul>
 * @param value  The value of the modification, depending on @a action.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterUserResponse alterUser( const std::string& name,
                             const std::string& action,
                             const std::string& value,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Alters a user.
 * 
 * @param name  Name of the user to be altered. Must be an existing user.
 * @param action  Modification operation to be applied to the user.
 *                <ul>
 *                        <li> gpudb::alter_user_set_password: Sets the
 *                password of the user. The user must be an internal user.
 *                        <li> gpudb::alter_user_set_resource_group: Sets the
 *                resource group for an internal user. The resource group must
 *                exist, otherwise, an empty string assigns the user to the
 *                default resource group.
 *                        <li> gpudb::alter_user_set_default_schema: Set the
 *                default_schema for an internal user. An empty string means
 *                the user will have no default schema.
 *                </ul>
 * @param value  The value of the modification, depending on @a action.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterUserResponse& alterUser( const std::string& name,
                              const std::string& action,
                              const std::string& value,
                              const std::map<std::string, std::string>& options,
                              AlterUserResponse& response_ ) const;

/**
 * Alters a video.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterVideoResponse alterVideo( const AlterVideoRequest& request_ ) const;

/**
 * Alters a video.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterVideoResponse& alterVideo( const AlterVideoRequest& request_,
                                AlterVideoResponse& response_ ) const;

/**
 * Alters a video.
 * 
 * @param path  Fully-qualified <a href="../../../tools/kifs/"
 *              target="_top">KiFS</a> path to the video to be altered.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::alter_video_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 video.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterVideoResponse alterVideo( const std::string& path,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Alters a video.
 * 
 * @param path  Fully-qualified <a href="../../../tools/kifs/"
 *              target="_top">KiFS</a> path to the video to be altered.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::alter_video_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 video.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterVideoResponse& alterVideo( const std::string& path,
                                const std::map<std::string, std::string>& options,
                                AlterVideoResponse& response_ ) const;

/**
 * Append (or insert) all records from a source table
 * (specified by @a sourceTableName) to a particular target table
 * (specified by @a tableName). The field map
 * (specified by @a fieldMap) holds the user specified map of target table
 * column names with their mapped source column names.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AppendRecordsResponse appendRecords( const AppendRecordsRequest& request_ ) const;

/**
 * Append (or insert) all records from a source table
 * (specified by @a sourceTableName) to a particular target table
 * (specified by @a tableName). The field map
 * (specified by @a fieldMap) holds the user specified map of target table
 * column names with their mapped source column names.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AppendRecordsResponse& appendRecords( const AppendRecordsRequest& request_,
                                      AppendRecordsResponse& response_ ) const;

/**
 * Append (or insert) all records from a source table
 * (specified by @a sourceTableName) to a particular target table
 * (specified by @a tableName). The field map
 * (specified by @a fieldMap) holds the user specified map of target table
 * column names with their mapped source column names.
 * 
 * @param tableName  The table name for the records to be appended, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param sourceTableName  The source table name to get records from, in
 *                         [schema_name.]table_name format, using standard <a
 *                         href="../../../concepts/tables/#table-name-resolution"
 *                         target="_top">name resolution rules</a>.  Must be an
 *                         existing table name.
 * @param fieldMap  Contains the mapping of column names from the target table
 *                  (specified by @a tableName) as the keys, and corresponding
 *                  column names or expressions (e.g., 'col_name+1') from the
 *                  source table (specified by @a sourceTableName). Must be
 *                  existing column names in source table and target table, and
 *                  their types must be matched. For details on using
 *                  expressions, see <a href="../../../concepts/expressions/"
 *                  target="_top">Expressions</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::append_records_offset: A positive
 *                 integer indicating the number of initial results to skip
 *                 from @a sourceTableName. Default is 0. The minimum allowed
 *                 value is 0. The maximum allowed value is MAX_INT.  The
 *                 default value is '0'.
 *                         <li> gpudb::append_records_limit: A positive integer
 *                 indicating the maximum number of results to be returned from
 *                 @a sourceTableName. Or END_OF_SET (-9999) to indicate that
 *                 the max number of results should be returned.  The default
 *                 value is '-9999'.
 *                         <li> gpudb::append_records_expression: Optional
 *                 filter expression to apply to the @a sourceTableName.  The
 *                 default value is ''.
 *                         <li> gpudb::append_records_order_by: Comma-separated
 *                 list of the columns to be sorted by from source table
 *                 (specified by @a sourceTableName), e.g., 'timestamp asc, x
 *                 desc'. The @a order_by columns do not have to be present in
 *                 @a fieldMap.  The default value is ''.
 *                         <li> gpudb::append_records_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting source
 *                 table
 *                 records (specified by @a sourceTableName) into a target
 *                 table
 *                 (specified by @a tableName) with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>. If
 *                 set to @a true, any existing table record with
 *                 primary key values that match those of a source table record
 *                 being inserted will be replaced by that
 *                 new record (the new data will be "upserted"). If set to
 *                 @a false, any existing table record with primary
 *                 key values that match those of a source table record being
 *                 inserted will remain unchanged, while the
 *                 source record will be rejected and an error handled as
 *                 determined by
 *                 @a ignore_existing_pk.  If the specified table does not have
 *                 a primary key,
 *                 then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::append_records_true: Upsert new records
 *                 when primary keys match existing records
 *                         <li> gpudb::append_records_false: Reject new records
 *                 when primary keys match existing records
 *                 </ul>
 *                 The default value is gpudb::append_records_false.
 *                         <li> gpudb::append_records_ignore_existing_pk:
 *                 Specifies the record collision error-suppression policy for
 *                 inserting source table records (specified by @a
 *                 sourceTableName) into a target table
 *                 (specified by @a tableName) with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only
 *                 used when not in upsert mode (upsert mode is disabled when
 *                 @a update_on_existing_pk is
 *                 @a false).  If set to
 *                 @a true, any source table record being inserted that
 *                 is rejected for having primary key values that match those
 *                 of an existing target table record will
 *                 be ignored with no error generated.  If @a false,
 *                 the rejection of any source table record for having primary
 *                 key values matching an existing target
 *                 table record will result in an error being raised.  If the
 *                 specified table does not have a primary
 *                 key or if upsert mode is in effect (@a update_on_existing_pk
 *                 is
 *                 @a true), then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::append_records_true: Ignore source table
 *                 records whose primary key values collide with those of
 *                 target table records
 *                         <li> gpudb::append_records_false: Raise an error for
 *                 any source table record whose primary key values collide
 *                 with those of a target table record
 *                 </ul>
 *                 The default value is gpudb::append_records_false.
 *                         <li> gpudb::append_records_truncate_strings: If set
 *                 to @a true, it allows inserting longer strings into smaller
 *                 charN string columns by truncating the longer strings to
 *                 fit.
 *                 <ul>
 *                         <li> gpudb::append_records_true
 *                         <li> gpudb::append_records_false
 *                 </ul>
 *                 The default value is gpudb::append_records_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AppendRecordsResponse appendRecords( const std::string& tableName,
                                     const std::string& sourceTableName,
                                     const std::map<std::string, std::string>& fieldMap,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Append (or insert) all records from a source table
 * (specified by @a sourceTableName) to a particular target table
 * (specified by @a tableName). The field map
 * (specified by @a fieldMap) holds the user specified map of target table
 * column names with their mapped source column names.
 * 
 * @param tableName  The table name for the records to be appended, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param sourceTableName  The source table name to get records from, in
 *                         [schema_name.]table_name format, using standard <a
 *                         href="../../../concepts/tables/#table-name-resolution"
 *                         target="_top">name resolution rules</a>.  Must be an
 *                         existing table name.
 * @param fieldMap  Contains the mapping of column names from the target table
 *                  (specified by @a tableName) as the keys, and corresponding
 *                  column names or expressions (e.g., 'col_name+1') from the
 *                  source table (specified by @a sourceTableName). Must be
 *                  existing column names in source table and target table, and
 *                  their types must be matched. For details on using
 *                  expressions, see <a href="../../../concepts/expressions/"
 *                  target="_top">Expressions</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::append_records_offset: A positive
 *                 integer indicating the number of initial results to skip
 *                 from @a sourceTableName. Default is 0. The minimum allowed
 *                 value is 0. The maximum allowed value is MAX_INT.  The
 *                 default value is '0'.
 *                         <li> gpudb::append_records_limit: A positive integer
 *                 indicating the maximum number of results to be returned from
 *                 @a sourceTableName. Or END_OF_SET (-9999) to indicate that
 *                 the max number of results should be returned.  The default
 *                 value is '-9999'.
 *                         <li> gpudb::append_records_expression: Optional
 *                 filter expression to apply to the @a sourceTableName.  The
 *                 default value is ''.
 *                         <li> gpudb::append_records_order_by: Comma-separated
 *                 list of the columns to be sorted by from source table
 *                 (specified by @a sourceTableName), e.g., 'timestamp asc, x
 *                 desc'. The @a order_by columns do not have to be present in
 *                 @a fieldMap.  The default value is ''.
 *                         <li> gpudb::append_records_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting source
 *                 table
 *                 records (specified by @a sourceTableName) into a target
 *                 table
 *                 (specified by @a tableName) with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>. If
 *                 set to @a true, any existing table record with
 *                 primary key values that match those of a source table record
 *                 being inserted will be replaced by that
 *                 new record (the new data will be "upserted"). If set to
 *                 @a false, any existing table record with primary
 *                 key values that match those of a source table record being
 *                 inserted will remain unchanged, while the
 *                 source record will be rejected and an error handled as
 *                 determined by
 *                 @a ignore_existing_pk.  If the specified table does not have
 *                 a primary key,
 *                 then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::append_records_true: Upsert new records
 *                 when primary keys match existing records
 *                         <li> gpudb::append_records_false: Reject new records
 *                 when primary keys match existing records
 *                 </ul>
 *                 The default value is gpudb::append_records_false.
 *                         <li> gpudb::append_records_ignore_existing_pk:
 *                 Specifies the record collision error-suppression policy for
 *                 inserting source table records (specified by @a
 *                 sourceTableName) into a target table
 *                 (specified by @a tableName) with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only
 *                 used when not in upsert mode (upsert mode is disabled when
 *                 @a update_on_existing_pk is
 *                 @a false).  If set to
 *                 @a true, any source table record being inserted that
 *                 is rejected for having primary key values that match those
 *                 of an existing target table record will
 *                 be ignored with no error generated.  If @a false,
 *                 the rejection of any source table record for having primary
 *                 key values matching an existing target
 *                 table record will result in an error being raised.  If the
 *                 specified table does not have a primary
 *                 key or if upsert mode is in effect (@a update_on_existing_pk
 *                 is
 *                 @a true), then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::append_records_true: Ignore source table
 *                 records whose primary key values collide with those of
 *                 target table records
 *                         <li> gpudb::append_records_false: Raise an error for
 *                 any source table record whose primary key values collide
 *                 with those of a target table record
 *                 </ul>
 *                 The default value is gpudb::append_records_false.
 *                         <li> gpudb::append_records_truncate_strings: If set
 *                 to @a true, it allows inserting longer strings into smaller
 *                 charN string columns by truncating the longer strings to
 *                 fit.
 *                 <ul>
 *                         <li> gpudb::append_records_true
 *                         <li> gpudb::append_records_false
 *                 </ul>
 *                 The default value is gpudb::append_records_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AppendRecordsResponse& appendRecords( const std::string& tableName,
                                      const std::string& sourceTableName,
                                      const std::map<std::string, std::string>& fieldMap,
                                      const std::map<std::string, std::string>& options,
                                      AppendRecordsResponse& response_ ) const;

/**
 * Clears statistics (cardinality, mean value, etc.) for a column in a
 * specified table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearStatisticsResponse clearStatistics( const ClearStatisticsRequest& request_ ) const;

/**
 * Clears statistics (cardinality, mean value, etc.) for a column in a
 * specified table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearStatisticsResponse& clearStatistics( const ClearStatisticsRequest& request_,
                                          ClearStatisticsResponse& response_ ) const;

/**
 * Clears statistics (cardinality, mean value, etc.) for a column in a
 * specified table.
 * 
 * @param tableName  Name of a table, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>. Must be an
 *                   existing table.
 * @param columnName  Name of the column in @a tableName for which to clear
 *                    statistics. The column must be from an existing table. An
 *                    empty string clears statistics for all columns in the
 *                    table.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearStatisticsResponse clearStatistics( const std::string& tableName,
                                         const std::string& columnName,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Clears statistics (cardinality, mean value, etc.) for a column in a
 * specified table.
 * 
 * @param tableName  Name of a table, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>. Must be an
 *                   existing table.
 * @param columnName  Name of the column in @a tableName for which to clear
 *                    statistics. The column must be from an existing table. An
 *                    empty string clears statistics for all columns in the
 *                    table.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearStatisticsResponse& clearStatistics( const std::string& tableName,
                                          const std::string& columnName,
                                          const std::map<std::string, std::string>& options,
                                          ClearStatisticsResponse& response_ ) const;

/**
 * Clears (drops) one or all tables in the database cluster. The
 * operation is synchronous meaning that the table will be cleared before the
 * function returns. The response payload returns the status of the operation
 * along
 * with the name of the table that was cleared.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableResponse clearTable( const ClearTableRequest& request_ ) const;

/**
 * Clears (drops) one or all tables in the database cluster. The
 * operation is synchronous meaning that the table will be cleared before the
 * function returns. The response payload returns the status of the operation
 * along
 * with the name of the table that was cleared.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableResponse& clearTable( const ClearTableRequest& request_,
                                ClearTableResponse& response_ ) const;

/**
 * Clears (drops) one or all tables in the database cluster. The
 * operation is synchronous meaning that the table will be cleared before the
 * function returns. The response payload returns the status of the operation
 * along
 * with the name of the table that was cleared.
 * 
 * @param tableName  Name of the table to be cleared, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>. Must be an
 *                   existing table. Empty string clears all available tables,
 *                   though this behavior is be prevented by default via
 *                   gpudb.conf parameter 'disable_clear_all'.
 * @param authorization  No longer used. User can pass an empty string.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::clear_table_no_error_if_not_exists: If
 *                 @a true and if the table specified in @a tableName does not
 *                 exist no error is returned. If @a false and if the table
 *                 specified in @a tableName does not exist then an error is
 *                 returned.
 *                 <ul>
 *                         <li> gpudb::clear_table_true
 *                         <li> gpudb::clear_table_false
 *                 </ul>
 *                 The default value is gpudb::clear_table_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableResponse clearTable( const std::string& tableName,
                               const std::string& authorization,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Clears (drops) one or all tables in the database cluster. The
 * operation is synchronous meaning that the table will be cleared before the
 * function returns. The response payload returns the status of the operation
 * along
 * with the name of the table that was cleared.
 * 
 * @param tableName  Name of the table to be cleared, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>. Must be an
 *                   existing table. Empty string clears all available tables,
 *                   though this behavior is be prevented by default via
 *                   gpudb.conf parameter 'disable_clear_all'.
 * @param authorization  No longer used. User can pass an empty string.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::clear_table_no_error_if_not_exists: If
 *                 @a true and if the table specified in @a tableName does not
 *                 exist no error is returned. If @a false and if the table
 *                 specified in @a tableName does not exist then an error is
 *                 returned.
 *                 <ul>
 *                         <li> gpudb::clear_table_true
 *                         <li> gpudb::clear_table_false
 *                 </ul>
 *                 The default value is gpudb::clear_table_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableResponse& clearTable( const std::string& tableName,
                                const std::string& authorization,
                                const std::map<std::string, std::string>& options,
                                ClearTableResponse& response_ ) const;

/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const CreateTableMonitorRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableMonitorResponse clearTableMonitor( const ClearTableMonitorRequest& request_ ) const;

/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const CreateTableMonitorRequest&,CreateTableMonitorResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableMonitorResponse& clearTableMonitor( const ClearTableMonitorRequest& request_,
                                              ClearTableMonitorResponse& response_ ) const;

/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const std::string&,const std::map<std::string, std::string>&) const}.
 * 
 * @param topicId  The topic ID returned by /create/tablemonitor.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::clear_table_monitor_keep_autogenerated_sink: If @a
 *                 true, the auto-generated <a
 *                 href="../../../concepts/data_sinks/"
 *                 target="_top">datasink</a> associated with this monitor, if
 *                 there is one, will be retained for further use. If @a false,
 *                 then the auto-generated sink will be dropped if there are no
 *                 other monitors referencing it.
 *                 <ul>
 *                         <li> gpudb::clear_table_monitor_true
 *                         <li> gpudb::clear_table_monitor_false
 *                 </ul>
 *                 The default value is gpudb::clear_table_monitor_false.
 *                         <li>
 *                 gpudb::clear_table_monitor_clear_all_references: If @a true,
 *                 all references that share the same @a topicId will be
 *                 cleared.
 *                 <ul>
 *                         <li> gpudb::clear_table_monitor_true
 *                         <li> gpudb::clear_table_monitor_false
 *                 </ul>
 *                 The default value is gpudb::clear_table_monitor_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableMonitorResponse clearTableMonitor( const std::string& topicId,
                                             const std::map<std::string, std::string>& options ) const;

/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const std::string&,const std::map<std::string, std::string>&,CreateTableMonitorResponse&) const}.
 * 
 * @param topicId  The topic ID returned by /create/tablemonitor.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::clear_table_monitor_keep_autogenerated_sink: If @a
 *                 true, the auto-generated <a
 *                 href="../../../concepts/data_sinks/"
 *                 target="_top">datasink</a> associated with this monitor, if
 *                 there is one, will be retained for further use. If @a false,
 *                 then the auto-generated sink will be dropped if there are no
 *                 other monitors referencing it.
 *                 <ul>
 *                         <li> gpudb::clear_table_monitor_true
 *                         <li> gpudb::clear_table_monitor_false
 *                 </ul>
 *                 The default value is gpudb::clear_table_monitor_false.
 *                         <li>
 *                 gpudb::clear_table_monitor_clear_all_references: If @a true,
 *                 all references that share the same @a topicId will be
 *                 cleared.
 *                 <ul>
 *                         <li> gpudb::clear_table_monitor_true
 *                         <li> gpudb::clear_table_monitor_false
 *                 </ul>
 *                 The default value is gpudb::clear_table_monitor_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableMonitorResponse& clearTableMonitor( const std::string& topicId,
                                              const std::map<std::string, std::string>& options,
                                              ClearTableMonitorResponse& response_ ) const;

/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTriggerResponse clearTrigger( const ClearTriggerRequest& request_ ) const;

/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTriggerResponse& clearTrigger( const ClearTriggerRequest& request_,
                                    ClearTriggerResponse& response_ ) const;

/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param triggerId  ID for the trigger to be deactivated.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTriggerResponse clearTrigger( const std::string& triggerId,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param triggerId  ID for the trigger to be deactivated.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTriggerResponse& clearTrigger( const std::string& triggerId,
                                    const std::map<std::string, std::string>& options,
                                    ClearTriggerResponse& response_ ) const;

/**
 * Collect statistics for a column(s) in a specified table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CollectStatisticsResponse collectStatistics( const CollectStatisticsRequest& request_ ) const;

/**
 * Collect statistics for a column(s) in a specified table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CollectStatisticsResponse& collectStatistics( const CollectStatisticsRequest& request_,
                                              CollectStatisticsResponse& response_ ) const;

/**
 * Collect statistics for a column(s) in a specified table.
 * 
 * @param tableName  Name of a table, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param columnNames  List of one or more column names in @a tableName for
 *                     which to collect statistics (cardinality, mean value,
 *                     etc.).
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CollectStatisticsResponse collectStatistics( const std::string& tableName,
                                             const std::vector<std::string>& columnNames,
                                             const std::map<std::string, std::string>& options ) const;

/**
 * Collect statistics for a column(s) in a specified table.
 * 
 * @param tableName  Name of a table, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param columnNames  List of one or more column names in @a tableName for
 *                     which to collect statistics (cardinality, mean value,
 *                     etc.).
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CollectStatisticsResponse& collectStatistics( const std::string& tableName,
                                              const std::vector<std::string>& columnNames,
                                              const std::map<std::string, std::string>& options,
                                              CollectStatisticsResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateContainerRegistryResponse createContainerRegistry( const CreateContainerRegistryRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateContainerRegistryResponse& createContainerRegistry( const CreateContainerRegistryRequest& request_,
                                                          CreateContainerRegistryResponse& response_ ) const;

/**
 * @private
 * 
 * @param registryName
 * @param uri
 * @param credential
 * @param options
 *                 <ul>
 *                         <li> gpudb::create_container_registry_user_name:
 *                 The default value is ''.
 *                         <li> gpudb::create_container_registry_password:
 *                 The default value is ''.
 *                         <li> gpudb::create_container_registry_email:   The
 *                 default value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateContainerRegistryResponse createContainerRegistry( const std::string& registryName,
                                                         const std::string& uri,
                                                         const std::string& credential,
                                                         const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param registryName
 * @param uri
 * @param credential
 * @param options
 *                 <ul>
 *                         <li> gpudb::create_container_registry_user_name:
 *                 The default value is ''.
 *                         <li> gpudb::create_container_registry_password:
 *                 The default value is ''.
 *                         <li> gpudb::create_container_registry_email:   The
 *                 default value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateContainerRegistryResponse& createContainerRegistry( const std::string& registryName,
                                                          const std::string& uri,
                                                          const std::string& credential,
                                                          const std::map<std::string, std::string>& options,
                                                          CreateContainerRegistryResponse& response_ ) const;

/**
 * Create a new <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateCredentialResponse createCredential( const CreateCredentialRequest& request_ ) const;

/**
 * Create a new <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateCredentialResponse& createCredential( const CreateCredentialRequest& request_,
                                            CreateCredentialResponse& response_ ) const;

/**
 * Create a new <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 * 
 * @param credentialName  Name of the credential to be created. Must contain
 *                        only letters, digits, and underscores, and cannot
 *                        begin with a digit. Must not match an existing
 *                        credential name.
 * @param type  Type of the credential to be created.
 *              <ul>
 *                      <li> gpudb::create_credential_aws_access_key
 *                      <li> gpudb::create_credential_aws_iam_role
 *                      <li> gpudb::create_credential_azure_ad
 *                      <li> gpudb::create_credential_azure_oauth
 *                      <li> gpudb::create_credential_azure_sas
 *                      <li> gpudb::create_credential_azure_storage_key
 *                      <li> gpudb::create_credential_docker
 *                      <li> gpudb::create_credential_gcs_service_account_id
 *                      <li> gpudb::create_credential_gcs_service_account_keys
 *                      <li> gpudb::create_credential_hdfs
 *                      <li> gpudb::create_credential_jdbc
 *                      <li> gpudb::create_credential_kafka
 *                      <li> gpudb::create_credential_confluent
 *              </ul>
 * @param identity  User of the credential to be created.
 * @param secret  Password of the credential to be created.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateCredentialResponse createCredential( const std::string& credentialName,
                                           const std::string& type,
                                           const std::string& identity,
                                           const std::string& secret,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * Create a new <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 * 
 * @param credentialName  Name of the credential to be created. Must contain
 *                        only letters, digits, and underscores, and cannot
 *                        begin with a digit. Must not match an existing
 *                        credential name.
 * @param type  Type of the credential to be created.
 *              <ul>
 *                      <li> gpudb::create_credential_aws_access_key
 *                      <li> gpudb::create_credential_aws_iam_role
 *                      <li> gpudb::create_credential_azure_ad
 *                      <li> gpudb::create_credential_azure_oauth
 *                      <li> gpudb::create_credential_azure_sas
 *                      <li> gpudb::create_credential_azure_storage_key
 *                      <li> gpudb::create_credential_docker
 *                      <li> gpudb::create_credential_gcs_service_account_id
 *                      <li> gpudb::create_credential_gcs_service_account_keys
 *                      <li> gpudb::create_credential_hdfs
 *                      <li> gpudb::create_credential_jdbc
 *                      <li> gpudb::create_credential_kafka
 *                      <li> gpudb::create_credential_confluent
 *              </ul>
 * @param identity  User of the credential to be created.
 * @param secret  Password of the credential to be created.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateCredentialResponse& createCredential( const std::string& credentialName,
                                            const std::string& type,
                                            const std::string& identity,
                                            const std::string& secret,
                                            const std::map<std::string, std::string>& options,
                                            CreateCredentialResponse& response_ ) const;

/**
 * Creates a <a href="../../../concepts/data_sinks/" target="_top">data
 * sink</a>, which contains the
 * destination information for a data sink that is external to the database.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateDatasinkResponse createDatasink( const CreateDatasinkRequest& request_ ) const;

/**
 * Creates a <a href="../../../concepts/data_sinks/" target="_top">data
 * sink</a>, which contains the
 * destination information for a data sink that is external to the database.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateDatasinkResponse& createDatasink( const CreateDatasinkRequest& request_,
                                        CreateDatasinkResponse& response_ ) const;

/**
 * Creates a <a href="../../../concepts/data_sinks/" target="_top">data
 * sink</a>, which contains the
 * destination information for a data sink that is external to the database.
 * 
 * @param name  Name of the data sink to be created.
 * @param destination  Destination for the output data in format
 *                     'storage_provider_type://path[:port]'.
 *                     Supported storage provider types are 'azure', 'gcs',
 *                     'hdfs', 'http', 'https', 'jdbc', 'kafka' and 's3'.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_datasink_connection_timeout:
 *                 Timeout in seconds for connecting to this data sink
 *                         <li> gpudb::create_datasink_wait_timeout: Timeout in
 *                 seconds for waiting for a response from this data sink
 *                         <li> gpudb::create_datasink_credential: Name of the
 *                 <a href="../../../concepts/credentials/"
 *                 target="_top">credential</a> object to be used in this data
 *                 sink
 *                         <li> gpudb::create_datasink_s3_bucket_name: Name of
 *                 the Amazon S3 bucket to use as the data sink
 *                         <li> gpudb::create_datasink_s3_region: Name of the
 *                 Amazon S3 region where the given bucket is located
 *                         <li>
 *                 gpudb::create_datasink_s3_use_virtual_addressing: When true
 *                 (default), the requests URI should be specified in
 *                 virtual-hosted-style format where the bucket name is part of
 *                 the domain name in the URL.
 *                 Otherwise set to false to use path-style URI for requests.
 *                 <ul>
 *                         <li> gpudb::create_datasink_true
 *                         <li> gpudb::create_datasink_false
 *                 </ul>
 *                 The default value is gpudb::create_datasink_true.
 *                         <li> gpudb::create_datasink_s3_aws_role_arn: Amazon
 *                 IAM Role ARN which has required S3 permissions that can be
 *                 assumed for the given S3 IAM user
 *                         <li>
 *                 gpudb::create_datasink_s3_encryption_customer_algorithm:
 *                 Customer encryption algorithm used encrypting data
 *                         <li>
 *                 gpudb::create_datasink_s3_encryption_customer_key: Customer
 *                 encryption key to encrypt or decrypt data
 *                         <li> gpudb::create_datasink_s3_encryption_type:
 *                 Server side encryption type
 *                         <li> gpudb::create_datasink_s3_kms_key_id: KMS key
 *                         <li> gpudb::create_datasink_hdfs_kerberos_keytab:
 *                 Kerberos keytab file location for the given HDFS user.  This
 *                 may be a KIFS file.
 *                         <li> gpudb::create_datasink_hdfs_delegation_token:
 *                 Delegation token for the given HDFS user
 *                         <li> gpudb::create_datasink_hdfs_use_kerberos: Use
 *                 kerberos authentication for the given HDFS cluster
 *                 <ul>
 *                         <li> gpudb::create_datasink_true
 *                         <li> gpudb::create_datasink_false
 *                 </ul>
 *                 The default value is gpudb::create_datasink_false.
 *                         <li>
 *                 gpudb::create_datasink_azure_storage_account_name: Name of
 *                 the Azure storage account to use as the data sink, this is
 *                 valid only if tenant_id is specified
 *                         <li> gpudb::create_datasink_azure_container_name:
 *                 Name of the Azure storage container to use as the data sink
 *                         <li> gpudb::create_datasink_azure_tenant_id: Active
 *                 Directory tenant ID (or directory ID)
 *                         <li> gpudb::create_datasink_azure_sas_token: Shared
 *                 access signature token for Azure storage account to use as
 *                 the data sink
 *                         <li> gpudb::create_datasink_azure_oauth_token: Oauth
 *                 token to access given storage container
 *                         <li> gpudb::create_datasink_gcs_bucket_name: Name of
 *                 the Google Cloud Storage bucket to use as the data sink
 *                         <li> gpudb::create_datasink_gcs_project_id: Name of
 *                 the Google Cloud project to use as the data sink
 *                         <li>
 *                 gpudb::create_datasink_gcs_service_account_keys: Google
 *                 Cloud service account keys to use for authenticating the
 *                 data sink
 *                         <li> gpudb::create_datasink_jdbc_driver_jar_path:
 *                 JDBC driver jar file location
 *                         <li> gpudb::create_datasink_jdbc_driver_class_name:
 *                 Name of the JDBC driver class
 *                         <li> gpudb::create_datasink_kafka_topic_name: Name
 *                 of the Kafka topic to publish to if @a destination is a
 *                 Kafka broker
 *                         <li> gpudb::create_datasink_max_batch_size: Maximum
 *                 number of records per notification message.  The default
 *                 value is '1'.
 *                         <li> gpudb::create_datasink_max_message_size:
 *                 Maximum size in bytes of each notification message.  The
 *                 default value is '1000000'.
 *                         <li> gpudb::create_datasink_json_format: The desired
 *                 format of JSON encoded notifications message.
 *                 If @a nested, records are returned as an array. Otherwise,
 *                 only a single record per messages is returned.
 *                 <ul>
 *                         <li> gpudb::create_datasink_flat
 *                         <li> gpudb::create_datasink_nested
 *                 </ul>
 *                 The default value is gpudb::create_datasink_flat.
 *                         <li> gpudb::create_datasink_use_managed_credentials:
 *                 When no credentials are supplied, we use anonymous access by
 *                 default.  If this is set, we will use cloud provider user
 *                 settings.
 *                 <ul>
 *                         <li> gpudb::create_datasink_true
 *                         <li> gpudb::create_datasink_false
 *                 </ul>
 *                 The default value is gpudb::create_datasink_false.
 *                         <li> gpudb::create_datasink_use_https: Use https to
 *                 connect to datasink if true, otherwise use http
 *                 <ul>
 *                         <li> gpudb::create_datasink_true
 *                         <li> gpudb::create_datasink_false
 *                 </ul>
 *                 The default value is gpudb::create_datasink_true.
 *                         <li> gpudb::create_datasink_skip_validation: Bypass
 *                 validation of connection to this data sink.
 *                 <ul>
 *                         <li> gpudb::create_datasink_true
 *                         <li> gpudb::create_datasink_false
 *                 </ul>
 *                 The default value is gpudb::create_datasink_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateDatasinkResponse createDatasink( const std::string& name,
                                       const std::string& destination,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Creates a <a href="../../../concepts/data_sinks/" target="_top">data
 * sink</a>, which contains the
 * destination information for a data sink that is external to the database.
 * 
 * @param name  Name of the data sink to be created.
 * @param destination  Destination for the output data in format
 *                     'storage_provider_type://path[:port]'.
 *                     Supported storage provider types are 'azure', 'gcs',
 *                     'hdfs', 'http', 'https', 'jdbc', 'kafka' and 's3'.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_datasink_connection_timeout:
 *                 Timeout in seconds for connecting to this data sink
 *                         <li> gpudb::create_datasink_wait_timeout: Timeout in
 *                 seconds for waiting for a response from this data sink
 *                         <li> gpudb::create_datasink_credential: Name of the
 *                 <a href="../../../concepts/credentials/"
 *                 target="_top">credential</a> object to be used in this data
 *                 sink
 *                         <li> gpudb::create_datasink_s3_bucket_name: Name of
 *                 the Amazon S3 bucket to use as the data sink
 *                         <li> gpudb::create_datasink_s3_region: Name of the
 *                 Amazon S3 region where the given bucket is located
 *                         <li>
 *                 gpudb::create_datasink_s3_use_virtual_addressing: When true
 *                 (default), the requests URI should be specified in
 *                 virtual-hosted-style format where the bucket name is part of
 *                 the domain name in the URL.
 *                 Otherwise set to false to use path-style URI for requests.
 *                 <ul>
 *                         <li> gpudb::create_datasink_true
 *                         <li> gpudb::create_datasink_false
 *                 </ul>
 *                 The default value is gpudb::create_datasink_true.
 *                         <li> gpudb::create_datasink_s3_aws_role_arn: Amazon
 *                 IAM Role ARN which has required S3 permissions that can be
 *                 assumed for the given S3 IAM user
 *                         <li>
 *                 gpudb::create_datasink_s3_encryption_customer_algorithm:
 *                 Customer encryption algorithm used encrypting data
 *                         <li>
 *                 gpudb::create_datasink_s3_encryption_customer_key: Customer
 *                 encryption key to encrypt or decrypt data
 *                         <li> gpudb::create_datasink_s3_encryption_type:
 *                 Server side encryption type
 *                         <li> gpudb::create_datasink_s3_kms_key_id: KMS key
 *                         <li> gpudb::create_datasink_hdfs_kerberos_keytab:
 *                 Kerberos keytab file location for the given HDFS user.  This
 *                 may be a KIFS file.
 *                         <li> gpudb::create_datasink_hdfs_delegation_token:
 *                 Delegation token for the given HDFS user
 *                         <li> gpudb::create_datasink_hdfs_use_kerberos: Use
 *                 kerberos authentication for the given HDFS cluster
 *                 <ul>
 *                         <li> gpudb::create_datasink_true
 *                         <li> gpudb::create_datasink_false
 *                 </ul>
 *                 The default value is gpudb::create_datasink_false.
 *                         <li>
 *                 gpudb::create_datasink_azure_storage_account_name: Name of
 *                 the Azure storage account to use as the data sink, this is
 *                 valid only if tenant_id is specified
 *                         <li> gpudb::create_datasink_azure_container_name:
 *                 Name of the Azure storage container to use as the data sink
 *                         <li> gpudb::create_datasink_azure_tenant_id: Active
 *                 Directory tenant ID (or directory ID)
 *                         <li> gpudb::create_datasink_azure_sas_token: Shared
 *                 access signature token for Azure storage account to use as
 *                 the data sink
 *                         <li> gpudb::create_datasink_azure_oauth_token: Oauth
 *                 token to access given storage container
 *                         <li> gpudb::create_datasink_gcs_bucket_name: Name of
 *                 the Google Cloud Storage bucket to use as the data sink
 *                         <li> gpudb::create_datasink_gcs_project_id: Name of
 *                 the Google Cloud project to use as the data sink
 *                         <li>
 *                 gpudb::create_datasink_gcs_service_account_keys: Google
 *                 Cloud service account keys to use for authenticating the
 *                 data sink
 *                         <li> gpudb::create_datasink_jdbc_driver_jar_path:
 *                 JDBC driver jar file location
 *                         <li> gpudb::create_datasink_jdbc_driver_class_name:
 *                 Name of the JDBC driver class
 *                         <li> gpudb::create_datasink_kafka_topic_name: Name
 *                 of the Kafka topic to publish to if @a destination is a
 *                 Kafka broker
 *                         <li> gpudb::create_datasink_max_batch_size: Maximum
 *                 number of records per notification message.  The default
 *                 value is '1'.
 *                         <li> gpudb::create_datasink_max_message_size:
 *                 Maximum size in bytes of each notification message.  The
 *                 default value is '1000000'.
 *                         <li> gpudb::create_datasink_json_format: The desired
 *                 format of JSON encoded notifications message.
 *                 If @a nested, records are returned as an array. Otherwise,
 *                 only a single record per messages is returned.
 *                 <ul>
 *                         <li> gpudb::create_datasink_flat
 *                         <li> gpudb::create_datasink_nested
 *                 </ul>
 *                 The default value is gpudb::create_datasink_flat.
 *                         <li> gpudb::create_datasink_use_managed_credentials:
 *                 When no credentials are supplied, we use anonymous access by
 *                 default.  If this is set, we will use cloud provider user
 *                 settings.
 *                 <ul>
 *                         <li> gpudb::create_datasink_true
 *                         <li> gpudb::create_datasink_false
 *                 </ul>
 *                 The default value is gpudb::create_datasink_false.
 *                         <li> gpudb::create_datasink_use_https: Use https to
 *                 connect to datasink if true, otherwise use http
 *                 <ul>
 *                         <li> gpudb::create_datasink_true
 *                         <li> gpudb::create_datasink_false
 *                 </ul>
 *                 The default value is gpudb::create_datasink_true.
 *                         <li> gpudb::create_datasink_skip_validation: Bypass
 *                 validation of connection to this data sink.
 *                 <ul>
 *                         <li> gpudb::create_datasink_true
 *                         <li> gpudb::create_datasink_false
 *                 </ul>
 *                 The default value is gpudb::create_datasink_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateDatasinkResponse& createDatasink( const std::string& name,
                                        const std::string& destination,
                                        const std::map<std::string, std::string>& options,
                                        CreateDatasinkResponse& response_ ) const;

/**
 * Creates a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a>, which contains the
 * location and connection information for a data store that is external to the
 * database.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateDatasourceResponse createDatasource( const CreateDatasourceRequest& request_ ) const;

/**
 * Creates a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a>, which contains the
 * location and connection information for a data store that is external to the
 * database.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateDatasourceResponse& createDatasource( const CreateDatasourceRequest& request_,
                                            CreateDatasourceResponse& response_ ) const;

/**
 * Creates a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a>, which contains the
 * location and connection information for a data store that is external to the
 * database.
 * 
 * @param name  Name of the data source to be created.
 * @param location  Location of the remote storage in
 *                  'storage_provider_type://[storage_path[:storage_port]]'
 *                  format.
 *                  Supported storage provider types are
 *                  'azure','gcs','hdfs','jdbc','kafka', 'confluent' and 's3'.
 * @param userName  Name of the remote system user; may be an empty string
 * @param password  Password for the remote system user; may be an empty string
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_datasource_skip_validation:
 *                 Bypass validation of connection to remote source.
 *                 <ul>
 *                         <li> gpudb::create_datasource_true
 *                         <li> gpudb::create_datasource_false
 *                 </ul>
 *                 The default value is gpudb::create_datasource_false.
 *                         <li> gpudb::create_datasource_connection_timeout:
 *                 Timeout in seconds for connecting to this storage provider
 *                         <li> gpudb::create_datasource_wait_timeout: Timeout
 *                 in seconds for reading from this storage provider
 *                         <li> gpudb::create_datasource_credential: Name of
 *                 the Credential object to be used in data source
 *                         <li> gpudb::create_datasource_s3_bucket_name: Name
 *                 of the Amazon S3 bucket to use as the data source
 *                         <li> gpudb::create_datasource_s3_region: Name of the
 *                 Amazon S3 region where the given bucket is located
 *                         <li>
 *                 gpudb::create_datasource_s3_use_virtual_addressing: When
 *                 true (default), the requests URI should be specified in
 *                 virtual-hosted-style format where the bucket name is part of
 *                 the domain name in the URL.
 *                 Otherwise set to false to use path-style URI for requests.
 *                 <ul>
 *                         <li> gpudb::create_datasource_true
 *                         <li> gpudb::create_datasource_false
 *                 </ul>
 *                 The default value is gpudb::create_datasource_true.
 *                         <li> gpudb::create_datasource_s3_aws_role_arn:
 *                 Amazon IAM Role ARN which has required S3 permissions that
 *                 can be assumed for the given S3 IAM user
 *                         <li>
 *                 gpudb::create_datasource_s3_encryption_customer_algorithm:
 *                 Customer encryption algorithm used encrypting data
 *                         <li>
 *                 gpudb::create_datasource_s3_encryption_customer_key:
 *                 Customer encryption key to encrypt or decrypt data
 *                         <li> gpudb::create_datasource_hdfs_kerberos_keytab:
 *                 Kerberos keytab file location for the given HDFS user.  This
 *                 may be a KIFS file.
 *                         <li> gpudb::create_datasource_hdfs_delegation_token:
 *                 Delegation token for the given HDFS user
 *                         <li> gpudb::create_datasource_hdfs_use_kerberos: Use
 *                 kerberos authentication for the given HDFS cluster
 *                 <ul>
 *                         <li> gpudb::create_datasource_true
 *                         <li> gpudb::create_datasource_false
 *                 </ul>
 *                 The default value is gpudb::create_datasource_false.
 *                         <li>
 *                 gpudb::create_datasource_azure_storage_account_name: Name of
 *                 the Azure storage account to use as the data source, this is
 *                 valid only if tenant_id is specified
 *                         <li> gpudb::create_datasource_azure_container_name:
 *                 Name of the Azure storage container to use as the data
 *                 source
 *                         <li> gpudb::create_datasource_azure_tenant_id:
 *                 Active Directory tenant ID (or directory ID)
 *                         <li> gpudb::create_datasource_azure_sas_token:
 *                 Shared access signature token for Azure storage account to
 *                 use as the data source
 *                         <li> gpudb::create_datasource_azure_oauth_token:
 *                 Oauth token to access given storage container
 *                         <li> gpudb::create_datasource_gcs_bucket_name: Name
 *                 of the Google Cloud Storage bucket to use as the data source
 *                         <li> gpudb::create_datasource_gcs_project_id: Name
 *                 of the Google Cloud project to use as the data source
 *                         <li>
 *                 gpudb::create_datasource_gcs_service_account_keys: Google
 *                 Cloud service account keys to use for authenticating the
 *                 data source
 *                         <li> gpudb::create_datasource_is_stream: To load
 *                 from Azure/GCS/S3 as a stream continuously.
 *                 <ul>
 *                         <li> gpudb::create_datasource_true
 *                         <li> gpudb::create_datasource_false
 *                 </ul>
 *                 The default value is gpudb::create_datasource_false.
 *                         <li> gpudb::create_datasource_kafka_topic_name: Name
 *                 of the Kafka topic to use as the data source
 *                         <li> gpudb::create_datasource_jdbc_driver_jar_path:
 *                 JDBC driver jar file location.  This may be a KIFS file.
 *                         <li>
 *                 gpudb::create_datasource_jdbc_driver_class_name: Name of the
 *                 JDBC driver class
 *                         <li> gpudb::create_datasource_anonymous: Use
 *                 anonymous connection to storage provider--DEPRECATED: this
 *                 is now the default.  Specify use_managed_credentials for
 *                 non-anonymous connection.
 *                 <ul>
 *                         <li> gpudb::create_datasource_true
 *                         <li> gpudb::create_datasource_false
 *                 </ul>
 *                 The default value is gpudb::create_datasource_true.
 *                         <li>
 *                 gpudb::create_datasource_use_managed_credentials: When no
 *                 credentials are supplied, we use anonymous access by
 *                 default.  If this is set, we will use cloud provider user
 *                 settings.
 *                 <ul>
 *                         <li> gpudb::create_datasource_true
 *                         <li> gpudb::create_datasource_false
 *                 </ul>
 *                 The default value is gpudb::create_datasource_false.
 *                         <li> gpudb::create_datasource_use_https: Use https
 *                 to connect to datasource if true, otherwise use http
 *                 <ul>
 *                         <li> gpudb::create_datasource_true
 *                         <li> gpudb::create_datasource_false
 *                 </ul>
 *                 The default value is gpudb::create_datasource_true.
 *                         <li>
 *                 gpudb::create_datasource_schema_registry_location: Location
 *                 of Confluent Schema registry in
 *                 '[storage_path[:storage_port]]' format.
 *                         <li>
 *                 gpudb::create_datasource_schema_registry_credential:
 *                 Confluent Schema registry Credential object name.
 *                         <li> gpudb::create_datasource_schema_registry_port:
 *                 Confluent Schema registry port (optional).
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateDatasourceResponse createDatasource( const std::string& name,
                                           const std::string& location,
                                           const std::string& userName,
                                           const std::string& password,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * Creates a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a>, which contains the
 * location and connection information for a data store that is external to the
 * database.
 * 
 * @param name  Name of the data source to be created.
 * @param location  Location of the remote storage in
 *                  'storage_provider_type://[storage_path[:storage_port]]'
 *                  format.
 *                  Supported storage provider types are
 *                  'azure','gcs','hdfs','jdbc','kafka', 'confluent' and 's3'.
 * @param userName  Name of the remote system user; may be an empty string
 * @param password  Password for the remote system user; may be an empty string
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_datasource_skip_validation:
 *                 Bypass validation of connection to remote source.
 *                 <ul>
 *                         <li> gpudb::create_datasource_true
 *                         <li> gpudb::create_datasource_false
 *                 </ul>
 *                 The default value is gpudb::create_datasource_false.
 *                         <li> gpudb::create_datasource_connection_timeout:
 *                 Timeout in seconds for connecting to this storage provider
 *                         <li> gpudb::create_datasource_wait_timeout: Timeout
 *                 in seconds for reading from this storage provider
 *                         <li> gpudb::create_datasource_credential: Name of
 *                 the Credential object to be used in data source
 *                         <li> gpudb::create_datasource_s3_bucket_name: Name
 *                 of the Amazon S3 bucket to use as the data source
 *                         <li> gpudb::create_datasource_s3_region: Name of the
 *                 Amazon S3 region where the given bucket is located
 *                         <li>
 *                 gpudb::create_datasource_s3_use_virtual_addressing: When
 *                 true (default), the requests URI should be specified in
 *                 virtual-hosted-style format where the bucket name is part of
 *                 the domain name in the URL.
 *                 Otherwise set to false to use path-style URI for requests.
 *                 <ul>
 *                         <li> gpudb::create_datasource_true
 *                         <li> gpudb::create_datasource_false
 *                 </ul>
 *                 The default value is gpudb::create_datasource_true.
 *                         <li> gpudb::create_datasource_s3_aws_role_arn:
 *                 Amazon IAM Role ARN which has required S3 permissions that
 *                 can be assumed for the given S3 IAM user
 *                         <li>
 *                 gpudb::create_datasource_s3_encryption_customer_algorithm:
 *                 Customer encryption algorithm used encrypting data
 *                         <li>
 *                 gpudb::create_datasource_s3_encryption_customer_key:
 *                 Customer encryption key to encrypt or decrypt data
 *                         <li> gpudb::create_datasource_hdfs_kerberos_keytab:
 *                 Kerberos keytab file location for the given HDFS user.  This
 *                 may be a KIFS file.
 *                         <li> gpudb::create_datasource_hdfs_delegation_token:
 *                 Delegation token for the given HDFS user
 *                         <li> gpudb::create_datasource_hdfs_use_kerberos: Use
 *                 kerberos authentication for the given HDFS cluster
 *                 <ul>
 *                         <li> gpudb::create_datasource_true
 *                         <li> gpudb::create_datasource_false
 *                 </ul>
 *                 The default value is gpudb::create_datasource_false.
 *                         <li>
 *                 gpudb::create_datasource_azure_storage_account_name: Name of
 *                 the Azure storage account to use as the data source, this is
 *                 valid only if tenant_id is specified
 *                         <li> gpudb::create_datasource_azure_container_name:
 *                 Name of the Azure storage container to use as the data
 *                 source
 *                         <li> gpudb::create_datasource_azure_tenant_id:
 *                 Active Directory tenant ID (or directory ID)
 *                         <li> gpudb::create_datasource_azure_sas_token:
 *                 Shared access signature token for Azure storage account to
 *                 use as the data source
 *                         <li> gpudb::create_datasource_azure_oauth_token:
 *                 Oauth token to access given storage container
 *                         <li> gpudb::create_datasource_gcs_bucket_name: Name
 *                 of the Google Cloud Storage bucket to use as the data source
 *                         <li> gpudb::create_datasource_gcs_project_id: Name
 *                 of the Google Cloud project to use as the data source
 *                         <li>
 *                 gpudb::create_datasource_gcs_service_account_keys: Google
 *                 Cloud service account keys to use for authenticating the
 *                 data source
 *                         <li> gpudb::create_datasource_is_stream: To load
 *                 from Azure/GCS/S3 as a stream continuously.
 *                 <ul>
 *                         <li> gpudb::create_datasource_true
 *                         <li> gpudb::create_datasource_false
 *                 </ul>
 *                 The default value is gpudb::create_datasource_false.
 *                         <li> gpudb::create_datasource_kafka_topic_name: Name
 *                 of the Kafka topic to use as the data source
 *                         <li> gpudb::create_datasource_jdbc_driver_jar_path:
 *                 JDBC driver jar file location.  This may be a KIFS file.
 *                         <li>
 *                 gpudb::create_datasource_jdbc_driver_class_name: Name of the
 *                 JDBC driver class
 *                         <li> gpudb::create_datasource_anonymous: Use
 *                 anonymous connection to storage provider--DEPRECATED: this
 *                 is now the default.  Specify use_managed_credentials for
 *                 non-anonymous connection.
 *                 <ul>
 *                         <li> gpudb::create_datasource_true
 *                         <li> gpudb::create_datasource_false
 *                 </ul>
 *                 The default value is gpudb::create_datasource_true.
 *                         <li>
 *                 gpudb::create_datasource_use_managed_credentials: When no
 *                 credentials are supplied, we use anonymous access by
 *                 default.  If this is set, we will use cloud provider user
 *                 settings.
 *                 <ul>
 *                         <li> gpudb::create_datasource_true
 *                         <li> gpudb::create_datasource_false
 *                 </ul>
 *                 The default value is gpudb::create_datasource_false.
 *                         <li> gpudb::create_datasource_use_https: Use https
 *                 to connect to datasource if true, otherwise use http
 *                 <ul>
 *                         <li> gpudb::create_datasource_true
 *                         <li> gpudb::create_datasource_false
 *                 </ul>
 *                 The default value is gpudb::create_datasource_true.
 *                         <li>
 *                 gpudb::create_datasource_schema_registry_location: Location
 *                 of Confluent Schema registry in
 *                 '[storage_path[:storage_port]]' format.
 *                         <li>
 *                 gpudb::create_datasource_schema_registry_credential:
 *                 Confluent Schema registry Credential object name.
 *                         <li> gpudb::create_datasource_schema_registry_port:
 *                 Confluent Schema registry port (optional).
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateDatasourceResponse& createDatasource( const std::string& name,
                                            const std::string& location,
                                            const std::string& userName,
                                            const std::string& password,
                                            const std::map<std::string, std::string>& options,
                                            CreateDatasourceResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateDeltaTableResponse createDeltaTable( const CreateDeltaTableRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateDeltaTableResponse& createDeltaTable( const CreateDeltaTableRequest& request_,
                                            CreateDeltaTableResponse& response_ ) const;

/**
 * @private
 * 
 * @param deltaTableName
 * @param tableName
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateDeltaTableResponse createDeltaTable( const std::string& deltaTableName,
                                           const std::string& tableName,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param deltaTableName
 * @param tableName
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateDeltaTableResponse& createDeltaTable( const std::string& deltaTableName,
                                            const std::string& tableName,
                                            const std::map<std::string, std::string>& options,
                                            CreateDeltaTableResponse& response_ ) const;

/**
 * Creates a new directory in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. The new
 * directory serves as a location in which the user can upload files using
 * {@link #uploadFiles(const UploadFilesRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateDirectoryResponse createDirectory( const CreateDirectoryRequest& request_ ) const;

/**
 * Creates a new directory in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. The new
 * directory serves as a location in which the user can upload files using
 * {@link
 * #uploadFiles(const UploadFilesRequest&,UploadFilesResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateDirectoryResponse& createDirectory( const CreateDirectoryRequest& request_,
                                          CreateDirectoryResponse& response_ ) const;

/**
 * Creates a new directory in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. The new
 * directory serves as a location in which the user can upload files using
 * {@link
 * #uploadFiles(const std::vector<std::string>&,const std::vector<std::vector<uint8_t> >&,const std::map<std::string, std::string>&) const}.
 * 
 * @param directoryName  Name of the directory in KiFS to be created.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_directory_create_home_directory:
 *                 When set, a home directory is created for the user name
 *                 provided in the value. The @a directoryName must be an empty
 *                 string in this case. The user must exist.
 *                         <li> gpudb::create_directory_data_limit: The maximum
 *                 capacity, in bytes, to apply to the created directory. Set
 *                 to -1 to indicate no upper limit. If empty, the system
 *                 default limit is applied.
 *                         <li> gpudb::create_directory_no_error_if_exists: If
 *                 @a true, does not return an error if the directory already
 *                 exists
 *                 <ul>
 *                         <li> gpudb::create_directory_true
 *                         <li> gpudb::create_directory_false
 *                 </ul>
 *                 The default value is gpudb::create_directory_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateDirectoryResponse createDirectory( const std::string& directoryName,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Creates a new directory in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. The new
 * directory serves as a location in which the user can upload files using
 * {@link
 * #uploadFiles(const std::vector<std::string>&,const std::vector<std::vector<uint8_t> >&,const std::map<std::string, std::string>&,UploadFilesResponse&) const}.
 * 
 * @param directoryName  Name of the directory in KiFS to be created.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_directory_create_home_directory:
 *                 When set, a home directory is created for the user name
 *                 provided in the value. The @a directoryName must be an empty
 *                 string in this case. The user must exist.
 *                         <li> gpudb::create_directory_data_limit: The maximum
 *                 capacity, in bytes, to apply to the created directory. Set
 *                 to -1 to indicate no upper limit. If empty, the system
 *                 default limit is applied.
 *                         <li> gpudb::create_directory_no_error_if_exists: If
 *                 @a true, does not return an error if the directory already
 *                 exists
 *                 <ul>
 *                         <li> gpudb::create_directory_true
 *                         <li> gpudb::create_directory_false
 *                 </ul>
 *                 The default value is gpudb::create_directory_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateDirectoryResponse& createDirectory( const std::string& directoryName,
                                          const std::map<std::string, std::string>& options,
                                          CreateDirectoryResponse& response_ ) const;

/**
 * Creates a new environment which can be used by <a
 * href="../../../concepts/udf/" target="_top">user-defined functions</a>
 * (UDF).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateEnvironmentResponse createEnvironment( const CreateEnvironmentRequest& request_ ) const;

/**
 * Creates a new environment which can be used by <a
 * href="../../../concepts/udf/" target="_top">user-defined functions</a>
 * (UDF).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateEnvironmentResponse& createEnvironment( const CreateEnvironmentRequest& request_,
                                              CreateEnvironmentResponse& response_ ) const;

/**
 * Creates a new environment which can be used by <a
 * href="../../../concepts/udf/" target="_top">user-defined functions</a>
 * (UDF).
 * 
 * @param environmentName  Name of the environment to be created.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateEnvironmentResponse createEnvironment( const std::string& environmentName,
                                             const std::map<std::string, std::string>& options ) const;

/**
 * Creates a new environment which can be used by <a
 * href="../../../concepts/udf/" target="_top">user-defined functions</a>
 * (UDF).
 * 
 * @param environmentName  Name of the environment to be created.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateEnvironmentResponse& createEnvironment( const std::string& environmentName,
                                              const std::map<std::string, std::string>& options,
                                              CreateEnvironmentResponse& response_ ) const;

/**
 * Creates a new graph network using given nodes, edges, weights, and
 * restrictions.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some <a href="../../../guide-tags/graph/" target="_top">graph
 * examples</a> before
 * using this endpoint.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateGraphResponse createGraph( const CreateGraphRequest& request_ ) const;

/**
 * Creates a new graph network using given nodes, edges, weights, and
 * restrictions.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some <a href="../../../guide-tags/graph/" target="_top">graph
 * examples</a> before
 * using this endpoint.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateGraphResponse& createGraph( const CreateGraphRequest& request_,
                                  CreateGraphResponse& response_ ) const;

/**
 * Creates a new graph network using given nodes, edges, weights, and
 * restrictions.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some <a href="../../../guide-tags/graph/" target="_top">graph
 * examples</a> before
 * using this endpoint.
 * 
 * @param graphName  Name of the graph resource to generate.
 * @param directedGraph  If set to @a true, the graph will be directed. If set
 *                       to @a false, the graph will not be directed. Consult
 *                       <a
 *                       href="../../../graph_solver/network_graph_solver/#directed-graphs"
 *                       target="_top">Directed Graphs</a> for more details.
 *                       <ul>
 *                               <li> gpudb::create_graph_true
 *                               <li> gpudb::create_graph_false
 *                       </ul>
 *                       The default value is gpudb::create_graph_true.
 * @param nodes  Nodes represent fundamental topological units of a graph.
 *               Nodes must be specified using
 *               <a
 *               href="../../../graph_solver/network_graph_solver/#identifiers"
 *               target="_top">identifiers</a>;
 *               identifiers are grouped as
 *               <a
 *               href="../../../graph_solver/network_graph_solver/#id-combos"
 *               target="_top">combinations</a>.
 *               Identifiers can be used with existing column names, e.g.,
 *               'table.column AS NODE_ID', expressions, e.g.,
 *               'ST_MAKEPOINT(column1, column2) AS NODE_WKTPOINT', or constant
 *               values, e.g.,
 *               '{9, 10, 11} AS NODE_ID'.
 *               If using constant values in an identifier combination, the
 *               number of values
 *               specified must match across the combination.
 * @param edges  Edges represent the required fundamental topological unit of
 *               a graph that typically connect nodes. Edges must be specified
 *               using
 *               <a
 *               href="../../../graph_solver/network_graph_solver/#identifiers"
 *               target="_top">identifiers</a>;
 *               identifiers are grouped as
 *               <a
 *               href="../../../graph_solver/network_graph_solver/#id-combos"
 *               target="_top">combinations</a>.
 *               Identifiers can be used with existing column names, e.g.,
 *               'table.column AS EDGE_ID', expressions, e.g.,
 *               'SUBSTR(column, 1, 6) AS EDGE_NODE1_NAME', or constant values,
 *               e.g.,
 *               "{'family', 'coworker'} AS EDGE_LABEL".
 *               If using constant values in an identifier combination, the
 *               number of values
 *               specified must match across the combination.
 * @param weights  Weights represent a method of informing the graph solver of
 *                 the cost of including a given edge in a solution. Weights
 *                 must be specified
 *                 using
 *                 <a
 *                 href="../../../graph_solver/network_graph_solver/#identifiers"
 *                 target="_top">identifiers</a>;
 *                 identifiers are grouped as
 *                 <a
 *                 href="../../../graph_solver/network_graph_solver/#id-combos"
 *                 target="_top">combinations</a>.
 *                 Identifiers can be used with existing column names, e.g.,
 *                 'table.column AS WEIGHTS_EDGE_ID', expressions, e.g.,
 *                 'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED', or constant
 *                 values, e.g.,
 *                 '{4, 15} AS WEIGHTS_VALUESPECIFIED'.
 *                 If using constant values in an identifier combination, the
 *                 number of values specified
 *                 must match across the combination.
 * @param restrictions  Restrictions represent a method of informing the graph
 *                      solver which edges and/or nodes should be ignored for
 *                      the solution. Restrictions
 *                      must be specified using
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#identifiers"
 *                      target="_top">identifiers</a>;
 *                      identifiers are grouped as
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#id-combos"
 *                      target="_top">combinations</a>.
 *                      Identifiers can be used with existing column names,
 *                      e.g.,
 *                      'table.column AS RESTRICTIONS_EDGE_ID', expressions,
 *                      e.g.,
 *                      'column/2 AS RESTRICTIONS_VALUECOMPARED', or constant
 *                      values, e.g.,
 *                      '{0, 0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'.
 *                      If using constant values in an identifier combination,
 *                      the number of values
 *                      specified must match across the combination.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_graph_merge_tolerance: If node
 *                 geospatial positions are input (e.g., WKTPOINT, X, Y),
 *                 determines the minimum separation allowed between unique
 *                 nodes. If nodes are within the tolerance of each other, they
 *                 will be merged as a single node.  The default value is
 *                 '1.0E-5'.
 *                         <li> gpudb::create_graph_recreate: If set to @a true
 *                 and the graph (using @a graphName) already exists, the graph
 *                 is deleted and recreated.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_save_persist: If set to @a
 *                 true, the graph will be saved in the persist directory (see
 *                 the <a href="../../../config/#config-main-persistence"
 *                 target="_top">config reference</a> for more information). If
 *                 set to @a false, the graph will be removed when the graph
 *                 server is shutdown.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_add_table_monitor: Adds a
 *                 table monitor to every table used in the creation of the
 *                 graph; this table monitor will trigger the graph to update
 *                 dynamically upon inserts to the source table(s). Note that
 *                 upon database restart, if @a save_persist is also set to @a
 *                 true, the graph will be fully reconstructed and the table
 *                 monitors will be reattached. For more details on table
 *                 monitors, see /create/tablemonitor.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_graph_table: If specified,
 *                 the created graph is also created as a table with the given
 *                 name, in [schema_name.]table_name format, using standard <a
 *                 href="../../../concepts/tables/#table-name-resolution"
 *                 target="_top">name resolution rules</a> and meeting <a
 *                 href="../../../concepts/tables/#table-naming-criteria"
 *                 target="_top">table naming criteria</a>.  The table will
 *                 have the following identifier columns: 'EDGE_ID',
 *                 'EDGE_NODE1_ID', 'EDGE_NODE2_ID'. If left blank, no table is
 *                 created.  The default value is ''.
 *                         <li> gpudb::create_graph_add_turns: Adds dummy
 *                 'pillowed' edges around intersection nodes where there are
 *                 more than three edges so that additional weight penalties
 *                 can be imposed by the solve endpoints. (increases the total
 *                 number of edges).
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_is_partitioned:
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_server_id: Indicates which
 *                 graph server(s) to send the request to. Default is to send
 *                 to the server with the most available memory.
 *                         <li> gpudb::create_graph_use_rtree: Use an range
 *                 tree structure to accelerate and improve the accuracy of
 *                 snapping, especially to edges.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_true.
 *                         <li> gpudb::create_graph_label_delimiter: If
 *                 provided the label string will be split according to this
 *                 delimiter and each sub-string will be applied as a separate
 *                 label onto the specified edge.  The default value is ''.
 *                         <li> gpudb::create_graph_allow_multiple_edges:
 *                 Multigraph choice; allowing multiple edges with the same
 *                 node pairs if set to true, otherwise, new edges with
 *                 existing same node pairs will not be inserted.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_true.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateGraphResponse createGraph( const std::string& graphName,
                                 const bool directedGraph,
                                 const std::vector<std::string>& nodes,
                                 const std::vector<std::string>& edges,
                                 const std::vector<std::string>& weights,
                                 const std::vector<std::string>& restrictions,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Creates a new graph network using given nodes, edges, weights, and
 * restrictions.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some <a href="../../../guide-tags/graph/" target="_top">graph
 * examples</a> before
 * using this endpoint.
 * 
 * @param graphName  Name of the graph resource to generate.
 * @param directedGraph  If set to @a true, the graph will be directed. If set
 *                       to @a false, the graph will not be directed. Consult
 *                       <a
 *                       href="../../../graph_solver/network_graph_solver/#directed-graphs"
 *                       target="_top">Directed Graphs</a> for more details.
 *                       <ul>
 *                               <li> gpudb::create_graph_true
 *                               <li> gpudb::create_graph_false
 *                       </ul>
 *                       The default value is gpudb::create_graph_true.
 * @param nodes  Nodes represent fundamental topological units of a graph.
 *               Nodes must be specified using
 *               <a
 *               href="../../../graph_solver/network_graph_solver/#identifiers"
 *               target="_top">identifiers</a>;
 *               identifiers are grouped as
 *               <a
 *               href="../../../graph_solver/network_graph_solver/#id-combos"
 *               target="_top">combinations</a>.
 *               Identifiers can be used with existing column names, e.g.,
 *               'table.column AS NODE_ID', expressions, e.g.,
 *               'ST_MAKEPOINT(column1, column2) AS NODE_WKTPOINT', or constant
 *               values, e.g.,
 *               '{9, 10, 11} AS NODE_ID'.
 *               If using constant values in an identifier combination, the
 *               number of values
 *               specified must match across the combination.
 * @param edges  Edges represent the required fundamental topological unit of
 *               a graph that typically connect nodes. Edges must be specified
 *               using
 *               <a
 *               href="../../../graph_solver/network_graph_solver/#identifiers"
 *               target="_top">identifiers</a>;
 *               identifiers are grouped as
 *               <a
 *               href="../../../graph_solver/network_graph_solver/#id-combos"
 *               target="_top">combinations</a>.
 *               Identifiers can be used with existing column names, e.g.,
 *               'table.column AS EDGE_ID', expressions, e.g.,
 *               'SUBSTR(column, 1, 6) AS EDGE_NODE1_NAME', or constant values,
 *               e.g.,
 *               "{'family', 'coworker'} AS EDGE_LABEL".
 *               If using constant values in an identifier combination, the
 *               number of values
 *               specified must match across the combination.
 * @param weights  Weights represent a method of informing the graph solver of
 *                 the cost of including a given edge in a solution. Weights
 *                 must be specified
 *                 using
 *                 <a
 *                 href="../../../graph_solver/network_graph_solver/#identifiers"
 *                 target="_top">identifiers</a>;
 *                 identifiers are grouped as
 *                 <a
 *                 href="../../../graph_solver/network_graph_solver/#id-combos"
 *                 target="_top">combinations</a>.
 *                 Identifiers can be used with existing column names, e.g.,
 *                 'table.column AS WEIGHTS_EDGE_ID', expressions, e.g.,
 *                 'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED', or constant
 *                 values, e.g.,
 *                 '{4, 15} AS WEIGHTS_VALUESPECIFIED'.
 *                 If using constant values in an identifier combination, the
 *                 number of values specified
 *                 must match across the combination.
 * @param restrictions  Restrictions represent a method of informing the graph
 *                      solver which edges and/or nodes should be ignored for
 *                      the solution. Restrictions
 *                      must be specified using
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#identifiers"
 *                      target="_top">identifiers</a>;
 *                      identifiers are grouped as
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#id-combos"
 *                      target="_top">combinations</a>.
 *                      Identifiers can be used with existing column names,
 *                      e.g.,
 *                      'table.column AS RESTRICTIONS_EDGE_ID', expressions,
 *                      e.g.,
 *                      'column/2 AS RESTRICTIONS_VALUECOMPARED', or constant
 *                      values, e.g.,
 *                      '{0, 0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'.
 *                      If using constant values in an identifier combination,
 *                      the number of values
 *                      specified must match across the combination.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_graph_merge_tolerance: If node
 *                 geospatial positions are input (e.g., WKTPOINT, X, Y),
 *                 determines the minimum separation allowed between unique
 *                 nodes. If nodes are within the tolerance of each other, they
 *                 will be merged as a single node.  The default value is
 *                 '1.0E-5'.
 *                         <li> gpudb::create_graph_recreate: If set to @a true
 *                 and the graph (using @a graphName) already exists, the graph
 *                 is deleted and recreated.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_save_persist: If set to @a
 *                 true, the graph will be saved in the persist directory (see
 *                 the <a href="../../../config/#config-main-persistence"
 *                 target="_top">config reference</a> for more information). If
 *                 set to @a false, the graph will be removed when the graph
 *                 server is shutdown.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_add_table_monitor: Adds a
 *                 table monitor to every table used in the creation of the
 *                 graph; this table monitor will trigger the graph to update
 *                 dynamically upon inserts to the source table(s). Note that
 *                 upon database restart, if @a save_persist is also set to @a
 *                 true, the graph will be fully reconstructed and the table
 *                 monitors will be reattached. For more details on table
 *                 monitors, see /create/tablemonitor.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_graph_table: If specified,
 *                 the created graph is also created as a table with the given
 *                 name, in [schema_name.]table_name format, using standard <a
 *                 href="../../../concepts/tables/#table-name-resolution"
 *                 target="_top">name resolution rules</a> and meeting <a
 *                 href="../../../concepts/tables/#table-naming-criteria"
 *                 target="_top">table naming criteria</a>.  The table will
 *                 have the following identifier columns: 'EDGE_ID',
 *                 'EDGE_NODE1_ID', 'EDGE_NODE2_ID'. If left blank, no table is
 *                 created.  The default value is ''.
 *                         <li> gpudb::create_graph_add_turns: Adds dummy
 *                 'pillowed' edges around intersection nodes where there are
 *                 more than three edges so that additional weight penalties
 *                 can be imposed by the solve endpoints. (increases the total
 *                 number of edges).
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_is_partitioned:
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_server_id: Indicates which
 *                 graph server(s) to send the request to. Default is to send
 *                 to the server with the most available memory.
 *                         <li> gpudb::create_graph_use_rtree: Use an range
 *                 tree structure to accelerate and improve the accuracy of
 *                 snapping, especially to edges.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_true.
 *                         <li> gpudb::create_graph_label_delimiter: If
 *                 provided the label string will be split according to this
 *                 delimiter and each sub-string will be applied as a separate
 *                 label onto the specified edge.  The default value is ''.
 *                         <li> gpudb::create_graph_allow_multiple_edges:
 *                 Multigraph choice; allowing multiple edges with the same
 *                 node pairs if set to true, otherwise, new edges with
 *                 existing same node pairs will not be inserted.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_true.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateGraphResponse& createGraph( const std::string& graphName,
                                  const bool directedGraph,
                                  const std::vector<std::string>& nodes,
                                  const std::vector<std::string>& edges,
                                  const std::vector<std::string>& weights,
                                  const std::vector<std::string>& restrictions,
                                  const std::map<std::string, std::string>& options,
                                  CreateGraphResponse& response_ ) const;

/**
 * Create a job which will run asynchronously. The response returns a job ID,
 * which can be used to query the status and result of the job. The status and
 * the result of the job upon completion can be requested by {@link
 * #getJob(const GetJobRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateJobResponse createJob( const CreateJobRequest& request_ ) const;

/**
 * Create a job which will run asynchronously. The response returns a job ID,
 * which can be used to query the status and result of the job. The status and
 * the result of the job upon completion can be requested by {@link
 * #getJob(const GetJobRequest&,GetJobResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateJobResponse& createJob( const CreateJobRequest& request_,
                              CreateJobResponse& response_ ) const;

/**
 * Create a job which will run asynchronously. The response returns a job ID,
 * which can be used to query the status and result of the job. The status and
 * the result of the job upon completion can be requested by {@link
 * #getJob(const int64_t,const std::map<std::string, std::string>&) const}.
 * 
 * @param endpoint  Indicates which endpoint to execute, e.g. '/alter/table'.
 * @param requestEncoding  The encoding of the request payload for the job.
 *                         <ul>
 *                                 <li> gpudb::create_job_binary
 *                                 <li> gpudb::create_job_json
 *                                 <li> gpudb::create_job_snappy
 *                         </ul>
 *                         The default value is gpudb::create_job_binary.
 * @param data  Binary-encoded payload for the job to be run asynchronously.
 *              The payload must contain the relevant input parameters for the
 *              endpoint indicated in @a endpoint.  Please see the
 *              documentation for the appropriate endpoint to see what values
 *              must (or can) be specified.  If this parameter is used, then @a
 *              requestEncoding must be @a binary or @a snappy.
 * @param dataStr  JSON-encoded payload for the job to be run asynchronously.
 *                 The payload must contain the relevant input parameters for
 *                 the endpoint indicated in @a endpoint.  Please see the
 *                 documentation for the appropriate endpoint to see what
 *                 values must (or can) be specified.  If this parameter is
 *                 used, then @a requestEncoding must be @a json.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_job_remove_job_on_complete:
 *                 <ul>
 *                         <li> gpudb::create_job_true
 *                         <li> gpudb::create_job_false
 *                 </ul>
 *                         <li> gpudb::create_job_job_tag: Tag to use for
 *                 submitted job. The same tag could be used on backup cluster
 *                 to retrieve response for the job. Tags can use letter,
 *                 numbers, '_' and '-'
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateJobResponse createJob( const std::string& endpoint,
                             const std::string& requestEncoding,
                             const std::vector<uint8_t>& data,
                             const std::string& dataStr,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Create a job which will run asynchronously. The response returns a job ID,
 * which can be used to query the status and result of the job. The status and
 * the result of the job upon completion can be requested by {@link
 * #getJob(const int64_t,const std::map<std::string, std::string>&,GetJobResponse&) const}.
 * 
 * @param endpoint  Indicates which endpoint to execute, e.g. '/alter/table'.
 * @param requestEncoding  The encoding of the request payload for the job.
 *                         <ul>
 *                                 <li> gpudb::create_job_binary
 *                                 <li> gpudb::create_job_json
 *                                 <li> gpudb::create_job_snappy
 *                         </ul>
 *                         The default value is gpudb::create_job_binary.
 * @param data  Binary-encoded payload for the job to be run asynchronously.
 *              The payload must contain the relevant input parameters for the
 *              endpoint indicated in @a endpoint.  Please see the
 *              documentation for the appropriate endpoint to see what values
 *              must (or can) be specified.  If this parameter is used, then @a
 *              requestEncoding must be @a binary or @a snappy.
 * @param dataStr  JSON-encoded payload for the job to be run asynchronously.
 *                 The payload must contain the relevant input parameters for
 *                 the endpoint indicated in @a endpoint.  Please see the
 *                 documentation for the appropriate endpoint to see what
 *                 values must (or can) be specified.  If this parameter is
 *                 used, then @a requestEncoding must be @a json.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_job_remove_job_on_complete:
 *                 <ul>
 *                         <li> gpudb::create_job_true
 *                         <li> gpudb::create_job_false
 *                 </ul>
 *                         <li> gpudb::create_job_job_tag: Tag to use for
 *                 submitted job. The same tag could be used on backup cluster
 *                 to retrieve response for the job. Tags can use letter,
 *                 numbers, '_' and '-'
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateJobResponse& createJob( const std::string& endpoint,
                              const std::string& requestEncoding,
                              const std::vector<uint8_t>& data,
                              const std::string& dataStr,
                              const std::map<std::string, std::string>& options,
                              CreateJobResponse& response_ ) const;

/**
 * Creates a table that is the result of a SQL JOIN.
 * <p>
 * For join details and examples see: <a href="../../../concepts/joins/"
 * target="_top">Joins</a>.  For limitations, see <a
 * href="../../../concepts/joins/#limitations-cautions" target="_top">Join
 * Limitations and Cautions</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateJoinTableResponse createJoinTable( const CreateJoinTableRequest& request_ ) const;

/**
 * Creates a table that is the result of a SQL JOIN.
 * <p>
 * For join details and examples see: <a href="../../../concepts/joins/"
 * target="_top">Joins</a>.  For limitations, see <a
 * href="../../../concepts/joins/#limitations-cautions" target="_top">Join
 * Limitations and Cautions</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateJoinTableResponse& createJoinTable( const CreateJoinTableRequest& request_,
                                          CreateJoinTableResponse& response_ ) const;

/**
 * Creates a table that is the result of a SQL JOIN.
 * <p>
 * For join details and examples see: <a href="../../../concepts/joins/"
 * target="_top">Joins</a>.  For limitations, see <a
 * href="../../../concepts/joins/#limitations-cautions" target="_top">Join
 * Limitations and Cautions</a>.
 * 
 * @param joinTableName  Name of the join table to be created, in
 *                       [schema_name.]table_name format, using standard <a
 *                       href="../../../concepts/tables/#table-name-resolution"
 *                       target="_top">name resolution rules</a> and meeting <a
 *                       href="../../../concepts/tables/#table-naming-criteria"
 *                       target="_top">table naming criteria</a>.
 * @param tableNames  The list of table names composing the join, each in
 *                    [schema_name.]table_name format, using standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.  Corresponds to
 *                    a SQL statement FROM clause.
 * @param columnNames  List of member table columns or column expressions to be
 *                     included in the join. Columns can be prefixed with
 *                     'table_id.column_name', where 'table_id' is the table
 *                     name or alias.  Columns can be aliased via the syntax
 *                     'column_name as alias'. Wild cards '*' can be used to
 *                     include all columns across member tables or 'table_id.*'
 *                     for all of a single table's columns.  Columns and column
 *                     expressions composing the join must be uniquely named or
 *                     aliased--therefore, the '*' wild card cannot be used if
 *                     column names aren't unique across all tables.
 * @param expressions  An optional list of expressions to combine and filter
 *                     the joined tables.  Corresponds to a SQL statement WHERE
 *                     clause. For details see: <a
 *                     href="../../../concepts/expressions/"
 *                     target="_top">expressions</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_join_table_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a joinTableName.
 *                 This is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_join_table_name.
 *                 <ul>
 *                         <li> gpudb::create_join_table_true
 *                         <li> gpudb::create_join_table_false
 *                 </ul>
 *                 The default value is gpudb::create_join_table_false.
 *                         <li> gpudb::create_join_table_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 join as part of @a joinTableName and use /create/schema to
 *                 create the schema if non-existent]  Name of a schema for the
 *                 join. If the schema is non-existent, it will be
 *                 automatically created.  The default value is ''.
 *                         <li> gpudb::create_join_table_max_query_dimensions:
 *                 No longer used.
 *                         <li> gpudb::create_join_table_optimize_lookups: Use
 *                 more memory to speed up the joining of tables.
 *                 <ul>
 *                         <li> gpudb::create_join_table_true
 *                         <li> gpudb::create_join_table_false
 *                 </ul>
 *                 The default value is gpudb::create_join_table_false.
 *                         <li> gpudb::create_join_table_strategy_definition:
 *                 The <a href="../../../rm/concepts/#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns.
 *                         <li> gpudb::create_join_table_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 join table specified in @a joinTableName.
 *                         <li> gpudb::create_join_table_view_id: view this
 *                 projection is part of.  The default value is ''.
 *                         <li> gpudb::create_join_table_no_count: Return a
 *                 count of 0 for the join table for logging and for
 *                 /show/table; optimization needed for large overlapped
 *                 equi-join stencils.  The default value is 'false'.
 *                         <li> gpudb::create_join_table_chunk_size: Maximum
 *                 number of records per joined-chunk for this table. Defaults
 *                 to the gpudb.conf file chunk size
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateJoinTableResponse createJoinTable( const std::string& joinTableName,
                                         const std::vector<std::string>& tableNames,
                                         const std::vector<std::string>& columnNames,
                                         const std::vector<std::string>& expressions,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Creates a table that is the result of a SQL JOIN.
 * <p>
 * For join details and examples see: <a href="../../../concepts/joins/"
 * target="_top">Joins</a>.  For limitations, see <a
 * href="../../../concepts/joins/#limitations-cautions" target="_top">Join
 * Limitations and Cautions</a>.
 * 
 * @param joinTableName  Name of the join table to be created, in
 *                       [schema_name.]table_name format, using standard <a
 *                       href="../../../concepts/tables/#table-name-resolution"
 *                       target="_top">name resolution rules</a> and meeting <a
 *                       href="../../../concepts/tables/#table-naming-criteria"
 *                       target="_top">table naming criteria</a>.
 * @param tableNames  The list of table names composing the join, each in
 *                    [schema_name.]table_name format, using standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.  Corresponds to
 *                    a SQL statement FROM clause.
 * @param columnNames  List of member table columns or column expressions to be
 *                     included in the join. Columns can be prefixed with
 *                     'table_id.column_name', where 'table_id' is the table
 *                     name or alias.  Columns can be aliased via the syntax
 *                     'column_name as alias'. Wild cards '*' can be used to
 *                     include all columns across member tables or 'table_id.*'
 *                     for all of a single table's columns.  Columns and column
 *                     expressions composing the join must be uniquely named or
 *                     aliased--therefore, the '*' wild card cannot be used if
 *                     column names aren't unique across all tables.
 * @param expressions  An optional list of expressions to combine and filter
 *                     the joined tables.  Corresponds to a SQL statement WHERE
 *                     clause. For details see: <a
 *                     href="../../../concepts/expressions/"
 *                     target="_top">expressions</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_join_table_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a joinTableName.
 *                 This is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_join_table_name.
 *                 <ul>
 *                         <li> gpudb::create_join_table_true
 *                         <li> gpudb::create_join_table_false
 *                 </ul>
 *                 The default value is gpudb::create_join_table_false.
 *                         <li> gpudb::create_join_table_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 join as part of @a joinTableName and use /create/schema to
 *                 create the schema if non-existent]  Name of a schema for the
 *                 join. If the schema is non-existent, it will be
 *                 automatically created.  The default value is ''.
 *                         <li> gpudb::create_join_table_max_query_dimensions:
 *                 No longer used.
 *                         <li> gpudb::create_join_table_optimize_lookups: Use
 *                 more memory to speed up the joining of tables.
 *                 <ul>
 *                         <li> gpudb::create_join_table_true
 *                         <li> gpudb::create_join_table_false
 *                 </ul>
 *                 The default value is gpudb::create_join_table_false.
 *                         <li> gpudb::create_join_table_strategy_definition:
 *                 The <a href="../../../rm/concepts/#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns.
 *                         <li> gpudb::create_join_table_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 join table specified in @a joinTableName.
 *                         <li> gpudb::create_join_table_view_id: view this
 *                 projection is part of.  The default value is ''.
 *                         <li> gpudb::create_join_table_no_count: Return a
 *                 count of 0 for the join table for logging and for
 *                 /show/table; optimization needed for large overlapped
 *                 equi-join stencils.  The default value is 'false'.
 *                         <li> gpudb::create_join_table_chunk_size: Maximum
 *                 number of records per joined-chunk for this table. Defaults
 *                 to the gpudb.conf file chunk size
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateJoinTableResponse& createJoinTable( const std::string& joinTableName,
                                          const std::vector<std::string>& tableNames,
                                          const std::vector<std::string>& columnNames,
                                          const std::vector<std::string>& expressions,
                                          const std::map<std::string, std::string>& options,
                                          CreateJoinTableResponse& response_ ) const;

/**
 * Initiates the process of creating a materialized view, reserving the
 * view's name to prevent other views or tables from being created with that
 * name.
 * <p>
 * For materialized view details and examples, see
 * <a href="../../../concepts/materialized_views/" target="_top">Materialized
 * Views</a>.
 * <p>
 * The response contains @a viewId, which is used to tag each subsequent
 * operation (projection, union, aggregation, filter, or join) that will
 * compose
 * the view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateMaterializedViewResponse createMaterializedView( const CreateMaterializedViewRequest& request_ ) const;

/**
 * Initiates the process of creating a materialized view, reserving the
 * view's name to prevent other views or tables from being created with that
 * name.
 * <p>
 * For materialized view details and examples, see
 * <a href="../../../concepts/materialized_views/" target="_top">Materialized
 * Views</a>.
 * <p>
 * The response contains @a viewId, which is used to tag each subsequent
 * operation (projection, union, aggregation, filter, or join) that will
 * compose
 * the view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateMaterializedViewResponse& createMaterializedView( const CreateMaterializedViewRequest& request_,
                                                        CreateMaterializedViewResponse& response_ ) const;

/**
 * Initiates the process of creating a materialized view, reserving the
 * view's name to prevent other views or tables from being created with that
 * name.
 * <p>
 * For materialized view details and examples, see
 * <a href="../../../concepts/materialized_views/" target="_top">Materialized
 * Views</a>.
 * <p>
 * The response contains @a viewId, which is used to tag each subsequent
 * operation (projection, union, aggregation, filter, or join) that will
 * compose
 * the view.
 * 
 * @param tableName  Name of the table to be created that is the top-level
 *                   table of the materialized view, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a> and meeting <a
 *                   href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::create_materialized_view_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 materialized view as part of @a tableName and use
 *                 /create/schema to create the schema if non-existent]  Name
 *                 of a schema which is to contain the newly created view. If
 *                 the schema provided is non-existent, it will be
 *                 automatically created.
 *                         <li> gpudb::create_materialized_view_execute_as:
 *                 User name to use to run the refresh job
 *                         <li> gpudb::create_materialized_view_persist: If @a
 *                 true, then the materialized view specified in @a tableName
 *                 will be persisted and will not expire unless a @a ttl is
 *                 specified.   If @a false, then the materialized view will be
 *                 an in-memory table and will expire unless a @a ttl is
 *                 specified otherwise.
 *                 <ul>
 *                         <li> gpudb::create_materialized_view_true
 *                         <li> gpudb::create_materialized_view_false
 *                 </ul>
 *                 The default value is gpudb::create_materialized_view_false.
 *                         <li> gpudb::create_materialized_view_refresh_span:
 *                 Sets the future time-offset(in seconds) at which periodic
 *                 refresh stops
 *                         <li>
 *                 gpudb::create_materialized_view_refresh_stop_time: When @a
 *                 refresh_method is @a periodic, specifies the time at which a
 *                 periodic refresh is stopped.  Value is a datetime string
 *                 with format 'YYYY-MM-DD HH:MM:SS'.
 *                         <li> gpudb::create_materialized_view_refresh_method:
 *                 Method by which the join can be refreshed when the data in
 *                 underlying member tables have changed.
 *                 <ul>
 *                         <li> gpudb::create_materialized_view_manual: Refresh
 *                 only occurs when manually requested by calling /alter/table
 *                 with an 'action' of 'refresh'
 *                         <li> gpudb::create_materialized_view_on_query:
 *                 Refresh any time the view is queried.
 *                         <li> gpudb::create_materialized_view_on_change: If
 *                 possible, incrementally refresh (refresh just those records
 *                 added) whenever an insert, update, delete or refresh of
 *                 input table is done.  A full refresh is done if an
 *                 incremental refresh is not possible.
 *                         <li> gpudb::create_materialized_view_periodic:
 *                 Refresh table periodically at rate specified by @a
 *                 refresh_period
 *                 </ul>
 *                 The default value is gpudb::create_materialized_view_manual.
 *                         <li> gpudb::create_materialized_view_refresh_period:
 *                 When @a refresh_method is @a periodic, specifies the period
 *                 in seconds at which refresh occurs
 *                         <li>
 *                 gpudb::create_materialized_view_refresh_start_time: When @a
 *                 refresh_method is @a periodic, specifies the first time at
 *                 which a refresh is to be done.  Value is a datetime string
 *                 with format 'YYYY-MM-DD HH:MM:SS'.
 *                         <li> gpudb::create_materialized_view_ttl: Sets the
 *                 <a href="../../../concepts/ttl/" target="_top">TTL</a> of
 *                 the table specified in @a tableName.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateMaterializedViewResponse createMaterializedView( const std::string& tableName,
                                                       const std::map<std::string, std::string>& options ) const;

/**
 * Initiates the process of creating a materialized view, reserving the
 * view's name to prevent other views or tables from being created with that
 * name.
 * <p>
 * For materialized view details and examples, see
 * <a href="../../../concepts/materialized_views/" target="_top">Materialized
 * Views</a>.
 * <p>
 * The response contains @a viewId, which is used to tag each subsequent
 * operation (projection, union, aggregation, filter, or join) that will
 * compose
 * the view.
 * 
 * @param tableName  Name of the table to be created that is the top-level
 *                   table of the materialized view, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a> and meeting <a
 *                   href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::create_materialized_view_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 materialized view as part of @a tableName and use
 *                 /create/schema to create the schema if non-existent]  Name
 *                 of a schema which is to contain the newly created view. If
 *                 the schema provided is non-existent, it will be
 *                 automatically created.
 *                         <li> gpudb::create_materialized_view_execute_as:
 *                 User name to use to run the refresh job
 *                         <li> gpudb::create_materialized_view_persist: If @a
 *                 true, then the materialized view specified in @a tableName
 *                 will be persisted and will not expire unless a @a ttl is
 *                 specified.   If @a false, then the materialized view will be
 *                 an in-memory table and will expire unless a @a ttl is
 *                 specified otherwise.
 *                 <ul>
 *                         <li> gpudb::create_materialized_view_true
 *                         <li> gpudb::create_materialized_view_false
 *                 </ul>
 *                 The default value is gpudb::create_materialized_view_false.
 *                         <li> gpudb::create_materialized_view_refresh_span:
 *                 Sets the future time-offset(in seconds) at which periodic
 *                 refresh stops
 *                         <li>
 *                 gpudb::create_materialized_view_refresh_stop_time: When @a
 *                 refresh_method is @a periodic, specifies the time at which a
 *                 periodic refresh is stopped.  Value is a datetime string
 *                 with format 'YYYY-MM-DD HH:MM:SS'.
 *                         <li> gpudb::create_materialized_view_refresh_method:
 *                 Method by which the join can be refreshed when the data in
 *                 underlying member tables have changed.
 *                 <ul>
 *                         <li> gpudb::create_materialized_view_manual: Refresh
 *                 only occurs when manually requested by calling /alter/table
 *                 with an 'action' of 'refresh'
 *                         <li> gpudb::create_materialized_view_on_query:
 *                 Refresh any time the view is queried.
 *                         <li> gpudb::create_materialized_view_on_change: If
 *                 possible, incrementally refresh (refresh just those records
 *                 added) whenever an insert, update, delete or refresh of
 *                 input table is done.  A full refresh is done if an
 *                 incremental refresh is not possible.
 *                         <li> gpudb::create_materialized_view_periodic:
 *                 Refresh table periodically at rate specified by @a
 *                 refresh_period
 *                 </ul>
 *                 The default value is gpudb::create_materialized_view_manual.
 *                         <li> gpudb::create_materialized_view_refresh_period:
 *                 When @a refresh_method is @a periodic, specifies the period
 *                 in seconds at which refresh occurs
 *                         <li>
 *                 gpudb::create_materialized_view_refresh_start_time: When @a
 *                 refresh_method is @a periodic, specifies the first time at
 *                 which a refresh is to be done.  Value is a datetime string
 *                 with format 'YYYY-MM-DD HH:MM:SS'.
 *                         <li> gpudb::create_materialized_view_ttl: Sets the
 *                 <a href="../../../concepts/ttl/" target="_top">TTL</a> of
 *                 the table specified in @a tableName.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateMaterializedViewResponse& createMaterializedView( const std::string& tableName,
                                                        const std::map<std::string, std::string>& options,
                                                        CreateMaterializedViewResponse& response_ ) const;

/**
 * Creates an instance (proc) of the
 * <a href="../../../concepts/udf/" target="_top">user-defined functions</a>
 * (UDF) specified by the
 * given command, options, and files, and makes it available for execution.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateProcResponse createProc( const CreateProcRequest& request_ ) const;

/**
 * Creates an instance (proc) of the
 * <a href="../../../concepts/udf/" target="_top">user-defined functions</a>
 * (UDF) specified by the
 * given command, options, and files, and makes it available for execution.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateProcResponse& createProc( const CreateProcRequest& request_,
                                CreateProcResponse& response_ ) const;

/**
 * Creates an instance (proc) of the
 * <a href="../../../concepts/udf/" target="_top">user-defined functions</a>
 * (UDF) specified by the
 * given command, options, and files, and makes it available for execution.
 * 
 * @param procName  Name of the proc to be created. Must not be the name of a
 *                  currently existing proc.
 * @param executionMode  The execution mode of the proc.
 *                       <ul>
 *                               <li> gpudb::create_proc_distributed: Input
 *                       table data will be divided into data
 *                       segments that are distributed across all nodes in the
 *                       cluster, and the proc
 *                       command will be invoked once per data segment in
 *                       parallel. Output table data
 *                       from each invocation will be saved to the same node as
 *                       the corresponding input
 *                       data.
 *                               <li> gpudb::create_proc_nondistributed: The
 *                       proc command will be invoked only once per
 *                       execution, and will not have direct access to any
 *                       tables named as input or
 *                       output table parameters in the call to /execute/proc.
 *                       It will,
 *                       however, be able to access the database using native
 *                       API calls.
 *                       </ul>
 *                       The default value is gpudb::create_proc_distributed.
 * @param files  A map of the files that make up the proc. The keys of the
 *               map are file names, and the values are the binary contents of
 *               the files. The
 *               file names may include subdirectory names (e.g. 'subdir/file')
 *               but must not
 *               resolve to a directory above the root for the proc.
 *               Files may be loaded from existing files in KiFS. Those file
 *               names should be
 *               prefixed with the uri kifs:// and the values in the map should
 *               be empty
 * @param command  The command (excluding arguments) that will be invoked when
 *                 the proc is executed. It will be invoked from the directory
 *                 containing the proc
 *                 @a files and may be any command that can be resolved from
 *                 that directory.
 *                 It need not refer to a file actually in that directory; for
 *                 example, it could be
 *                 'java' if the proc is a Java application; however, any
 *                 necessary external
 *                 programs must be preinstalled on every database node. If the
 *                 command refers to a
 *                 file in that directory, it must be preceded with './' as per
 *                 Linux convention.
 *                 If not specified, and exactly one file is provided in @a
 *                 files, that file
 *                 will be invoked.
 * @param args  An array of command-line arguments that will be passed to @a
 *              command when the proc is executed.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_proc_max_concurrency_per_node:
 *                 The maximum number of concurrent instances of the proc that
 *                 will be executed per node. 0 allows unlimited concurrency.
 *                 The default value is '0'.
 *                         <li> gpudb::create_proc_set_environment: A python
 *                 environment to use when executing the proc. Must be an
 *                 existing environment, else an error will be returned.  The
 *                 default value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateProcResponse createProc( const std::string& procName,
                               const std::string& executionMode,
                               const std::map<std::string, std::vector<uint8_t> >& files,
                               const std::string& command,
                               const std::vector<std::string>& args,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Creates an instance (proc) of the
 * <a href="../../../concepts/udf/" target="_top">user-defined functions</a>
 * (UDF) specified by the
 * given command, options, and files, and makes it available for execution.
 * 
 * @param procName  Name of the proc to be created. Must not be the name of a
 *                  currently existing proc.
 * @param executionMode  The execution mode of the proc.
 *                       <ul>
 *                               <li> gpudb::create_proc_distributed: Input
 *                       table data will be divided into data
 *                       segments that are distributed across all nodes in the
 *                       cluster, and the proc
 *                       command will be invoked once per data segment in
 *                       parallel. Output table data
 *                       from each invocation will be saved to the same node as
 *                       the corresponding input
 *                       data.
 *                               <li> gpudb::create_proc_nondistributed: The
 *                       proc command will be invoked only once per
 *                       execution, and will not have direct access to any
 *                       tables named as input or
 *                       output table parameters in the call to /execute/proc.
 *                       It will,
 *                       however, be able to access the database using native
 *                       API calls.
 *                       </ul>
 *                       The default value is gpudb::create_proc_distributed.
 * @param files  A map of the files that make up the proc. The keys of the
 *               map are file names, and the values are the binary contents of
 *               the files. The
 *               file names may include subdirectory names (e.g. 'subdir/file')
 *               but must not
 *               resolve to a directory above the root for the proc.
 *               Files may be loaded from existing files in KiFS. Those file
 *               names should be
 *               prefixed with the uri kifs:// and the values in the map should
 *               be empty
 * @param command  The command (excluding arguments) that will be invoked when
 *                 the proc is executed. It will be invoked from the directory
 *                 containing the proc
 *                 @a files and may be any command that can be resolved from
 *                 that directory.
 *                 It need not refer to a file actually in that directory; for
 *                 example, it could be
 *                 'java' if the proc is a Java application; however, any
 *                 necessary external
 *                 programs must be preinstalled on every database node. If the
 *                 command refers to a
 *                 file in that directory, it must be preceded with './' as per
 *                 Linux convention.
 *                 If not specified, and exactly one file is provided in @a
 *                 files, that file
 *                 will be invoked.
 * @param args  An array of command-line arguments that will be passed to @a
 *              command when the proc is executed.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_proc_max_concurrency_per_node:
 *                 The maximum number of concurrent instances of the proc that
 *                 will be executed per node. 0 allows unlimited concurrency.
 *                 The default value is '0'.
 *                         <li> gpudb::create_proc_set_environment: A python
 *                 environment to use when executing the proc. Must be an
 *                 existing environment, else an error will be returned.  The
 *                 default value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateProcResponse& createProc( const std::string& procName,
                                const std::string& executionMode,
                                const std::map<std::string, std::vector<uint8_t> >& files,
                                const std::string& command,
                                const std::vector<std::string>& args,
                                const std::map<std::string, std::string>& options,
                                CreateProcResponse& response_ ) const;

/**
 * Creates a new <a href="../../../concepts/projections/"
 * target="_top">projection</a> of
 * an existing table. A projection represents a subset of the columns
 * (potentially
 * including derived columns) of a table.
 * <p>
 * For projection details and examples, see
 * <a href="../../../concepts/projections/" target="_top">Projections</a>.  For
 * limitations, see
 * <a href="../../../concepts/projections/#limitations-and-cautions"
 * target="_top">Projection Limitations and Cautions</a>.
 * <p>
 * <a href="../../../concepts/window/" target="_top">Window functions</a>,
 * which can perform
 * operations like moving averages, are available through this endpoint as well
 * as
 * {@link #getRecordsByColumnRaw(const GetRecordsByColumnRequest&) const}.
 * <p>
 * A projection can be created with a different
 * <a href="../../../concepts/tables/#shard-keys" target="_top">shard key</a>
 * than the source table.
 * By specifying @a shard_key, the projection will be sharded
 * according to the specified columns, regardless of how the source table is
 * sharded.  The source table can even be unsharded or replicated.
 * <p>
 * If @a tableName is empty, selection is performed against a single-row
 * virtual table.  This can be useful in executing temporal
 * (<a href="../../../concepts/expressions/#date-time-functions"
 * target="_top">NOW()</a>), identity
 * (<a href="../../../concepts/expressions/#user-security-functions"
 * target="_top">USER()</a>), or
 * constant-based functions
 * (<a href="../../../concepts/expressions/#scalar-functions"
 * target="_top">GEODIST(-77.11, 38.88, -71.06, 42.36)</a>).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateProjectionResponse createProjection( const CreateProjectionRequest& request_ ) const;

/**
 * Creates a new <a href="../../../concepts/projections/"
 * target="_top">projection</a> of
 * an existing table. A projection represents a subset of the columns
 * (potentially
 * including derived columns) of a table.
 * <p>
 * For projection details and examples, see
 * <a href="../../../concepts/projections/" target="_top">Projections</a>.  For
 * limitations, see
 * <a href="../../../concepts/projections/#limitations-and-cautions"
 * target="_top">Projection Limitations and Cautions</a>.
 * <p>
 * <a href="../../../concepts/window/" target="_top">Window functions</a>,
 * which can perform
 * operations like moving averages, are available through this endpoint as well
 * as
 * {@link
 * #getRecordsByColumnRaw(const GetRecordsByColumnRequest&,RawGetRecordsByColumnResponse&) const}.
 * <p>
 * A projection can be created with a different
 * <a href="../../../concepts/tables/#shard-keys" target="_top">shard key</a>
 * than the source table.
 * By specifying @a shard_key, the projection will be sharded
 * according to the specified columns, regardless of how the source table is
 * sharded.  The source table can even be unsharded or replicated.
 * <p>
 * If @a tableName is empty, selection is performed against a single-row
 * virtual table.  This can be useful in executing temporal
 * (<a href="../../../concepts/expressions/#date-time-functions"
 * target="_top">NOW()</a>), identity
 * (<a href="../../../concepts/expressions/#user-security-functions"
 * target="_top">USER()</a>), or
 * constant-based functions
 * (<a href="../../../concepts/expressions/#scalar-functions"
 * target="_top">GEODIST(-77.11, 38.88, -71.06, 42.36)</a>).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateProjectionResponse& createProjection( const CreateProjectionRequest& request_,
                                            CreateProjectionResponse& response_ ) const;

/**
 * Creates a new <a href="../../../concepts/projections/"
 * target="_top">projection</a> of
 * an existing table. A projection represents a subset of the columns
 * (potentially
 * including derived columns) of a table.
 * <p>
 * For projection details and examples, see
 * <a href="../../../concepts/projections/" target="_top">Projections</a>.  For
 * limitations, see
 * <a href="../../../concepts/projections/#limitations-and-cautions"
 * target="_top">Projection Limitations and Cautions</a>.
 * <p>
 * <a href="../../../concepts/window/" target="_top">Window functions</a>,
 * which can perform
 * operations like moving averages, are available through this endpoint as well
 * as
 * {@link #getRecordsByColumnRaw(const GetRecordsByColumnRequest&) const}.
 * <p>
 * A projection can be created with a different
 * <a href="../../../concepts/tables/#shard-keys" target="_top">shard key</a>
 * than the source table.
 * By specifying @a shard_key, the projection will be sharded
 * according to the specified columns, regardless of how the source table is
 * sharded.  The source table can even be unsharded or replicated.
 * <p>
 * If @a tableName is empty, selection is performed against a single-row
 * virtual table.  This can be useful in executing temporal
 * (<a href="../../../concepts/expressions/#date-time-functions"
 * target="_top">NOW()</a>), identity
 * (<a href="../../../concepts/expressions/#user-security-functions"
 * target="_top">USER()</a>), or
 * constant-based functions
 * (<a href="../../../concepts/expressions/#scalar-functions"
 * target="_top">GEODIST(-77.11, 38.88, -71.06, 42.36)</a>).
 * 
 * @param tableName  Name of the existing table on which the projection is to
 *                   be applied, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  An empty table
 *                   name creates a projection from a single-row virtual table,
 *                   where columns specified should be constants or constant
 *                   expressions.
 * @param projectionName  Name of the projection to be created, in
 *                        [schema_name.]table_name format, using standard <a
 *                        href="../../../concepts/tables/#table-name-resolution"
 *                        target="_top">name resolution rules</a> and meeting
 *                        <a
 *                        href="../../../concepts/tables/#table-naming-criteria"
 *                        target="_top">table naming criteria</a>.
 * @param columnNames  List of columns from @a tableName to be included in the
 *                     projection. Can include derived columns. Can be
 *                     specified as aliased via the syntax 'column_name as
 *                     alias'.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_projection_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a projectionName.
 *                 If @a persist is @a false (or unspecified), then this is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_projection_name.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li> gpudb::create_projection_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 projection as part of @a projectionName and use
 *                 /create/schema to create the schema if non-existent]  Name
 *                 of a schema for the projection. If the schema is
 *                 non-existent, it will be automatically created.  The default
 *                 value is ''.
 *                         <li> gpudb::create_projection_expression: An
 *                 optional filter <a href="../../../concepts/expressions/"
 *                 target="_top">expression</a> to be applied to the source
 *                 table prior to the projection.  The default value is ''.
 *                         <li> gpudb::create_projection_is_replicated: If @a
 *                 true then the projection will be replicated even if the
 *                 source table is not.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li> gpudb::create_projection_offset: The number of
 *                 initial results to skip (this can be useful for paging
 *                 through the results).  The default value is '0'.
 *                         <li> gpudb::create_projection_limit: The number of
 *                 records to keep.  The default value is '-9999'.
 *                         <li> gpudb::create_projection_order_by:
 *                 Comma-separated list of the columns to be sorted by; e.g.
 *                 'timestamp asc, x desc'.  The columns specified must be
 *                 present in @a columnNames.  If any alias is given for any
 *                 column name, the alias must be used, rather than the
 *                 original column name.  The default value is ''.
 *                         <li> gpudb::create_projection_chunk_size: Indicates
 *                 the number of records per chunk to be used for this
 *                 projection.
 *                         <li> gpudb::create_projection_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the projection.  The columns specified must be present in
 *                 @a columnNames.  If any alias is given for any column name,
 *                 the alias must be used, rather than the original column
 *                 name.
 *                         <li> gpudb::create_projection_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 projection specified in @a projectionName.
 *                         <li> gpudb::create_projection_shard_key:
 *                 Comma-separated list of the columns to be sharded on; e.g.
 *                 'column1, column2'.  The columns specified must be present
 *                 in @a columnNames.  If any alias is given for any column
 *                 name, the alias must be used, rather than the original
 *                 column name.  The default value is ''.
 *                         <li> gpudb::create_projection_persist: If @a true,
 *                 then the projection specified in @a projectionName will be
 *                 persisted and will not expire unless a @a ttl is specified.
 *                 If @a false, then the projection will be an in-memory table
 *                 and will expire unless a @a ttl is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li>
 *                 gpudb::create_projection_preserve_dict_encoding: If @a true,
 *                 then columns that were dict encoded in the source table will
 *                 be dict encoded in the projection.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_true.
 *                         <li> gpudb::create_projection_retain_partitions:
 *                 Determines whether the created projection will retain the
 *                 partitioning scheme from the source table.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li> gpudb::create_projection_partition_type: <a
 *                 href="../../../concepts/tables/#partitioning"
 *                 target="_top">Partitioning</a> scheme to use.
 *                 <ul>
 *                         <li> gpudb::create_projection_RANGE: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-range"
 *                 target="_top">range partitioning</a>.
 *                         <li> gpudb::create_projection_INTERVAL: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-interval"
 *                 target="_top">interval partitioning</a>.
 *                         <li> gpudb::create_projection_LIST: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-list"
 *                 target="_top">list partitioning</a>.
 *                         <li> gpudb::create_projection_HASH: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-hash"
 *                 target="_top">hash partitioning</a>.
 *                         <li> gpudb::create_projection_SERIES: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-series"
 *                 target="_top">series partitioning</a>.
 *                 </ul>
 *                         <li> gpudb::create_projection_partition_keys:
 *                 Comma-separated list of partition keys, which are the
 *                 columns or column expressions by which records will be
 *                 assigned to partitions defined by @a partition_definitions.
 *                         <li> gpudb::create_projection_partition_definitions:
 *                 Comma-separated list of partition definitions, whose format
 *                 depends on the choice of @a partition_type.  See <a
 *                 href="../../../concepts/tables/#partitioning-by-range"
 *                 target="_top">range partitioning</a>, <a
 *                 href="../../../concepts/tables/#partitioning-by-interval"
 *                 target="_top">interval partitioning</a>, <a
 *                 href="../../../concepts/tables/#partitioning-by-list"
 *                 target="_top">list partitioning</a>, <a
 *                 href="../../../concepts/tables/#partitioning-by-hash"
 *                 target="_top">hash partitioning</a>, or <a
 *                 href="../../../concepts/tables/#partitioning-by-series"
 *                 target="_top">series partitioning</a> for example formats.
 *                         <li>
 *                 gpudb::create_projection_is_automatic_partition: If @a true,
 *                 a new partition will be created for values which don't fall
 *                 into an existing partition.  Currently only supported for <a
 *                 href="../../../concepts/tables/#partitioning-by-list"
 *                 target="_top">list partitions</a>.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li> gpudb::create_projection_view_id: ID of view of
 *                 which this projection is a member.  The default value is ''.
 *                         <li> gpudb::create_projection_strategy_definition:
 *                 The <a href="../../../rm/concepts/#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateProjectionResponse createProjection( const std::string& tableName,
                                           const std::string& projectionName,
                                           const std::vector<std::string>& columnNames,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * Creates a new <a href="../../../concepts/projections/"
 * target="_top">projection</a> of
 * an existing table. A projection represents a subset of the columns
 * (potentially
 * including derived columns) of a table.
 * <p>
 * For projection details and examples, see
 * <a href="../../../concepts/projections/" target="_top">Projections</a>.  For
 * limitations, see
 * <a href="../../../concepts/projections/#limitations-and-cautions"
 * target="_top">Projection Limitations and Cautions</a>.
 * <p>
 * <a href="../../../concepts/window/" target="_top">Window functions</a>,
 * which can perform
 * operations like moving averages, are available through this endpoint as well
 * as
 * {@link #getRecordsByColumnRaw(const GetRecordsByColumnRequest&) const}.
 * <p>
 * A projection can be created with a different
 * <a href="../../../concepts/tables/#shard-keys" target="_top">shard key</a>
 * than the source table.
 * By specifying @a shard_key, the projection will be sharded
 * according to the specified columns, regardless of how the source table is
 * sharded.  The source table can even be unsharded or replicated.
 * <p>
 * If @a tableName is empty, selection is performed against a single-row
 * virtual table.  This can be useful in executing temporal
 * (<a href="../../../concepts/expressions/#date-time-functions"
 * target="_top">NOW()</a>), identity
 * (<a href="../../../concepts/expressions/#user-security-functions"
 * target="_top">USER()</a>), or
 * constant-based functions
 * (<a href="../../../concepts/expressions/#scalar-functions"
 * target="_top">GEODIST(-77.11, 38.88, -71.06, 42.36)</a>).
 * 
 * @param tableName  Name of the existing table on which the projection is to
 *                   be applied, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  An empty table
 *                   name creates a projection from a single-row virtual table,
 *                   where columns specified should be constants or constant
 *                   expressions.
 * @param projectionName  Name of the projection to be created, in
 *                        [schema_name.]table_name format, using standard <a
 *                        href="../../../concepts/tables/#table-name-resolution"
 *                        target="_top">name resolution rules</a> and meeting
 *                        <a
 *                        href="../../../concepts/tables/#table-naming-criteria"
 *                        target="_top">table naming criteria</a>.
 * @param columnNames  List of columns from @a tableName to be included in the
 *                     projection. Can include derived columns. Can be
 *                     specified as aliased via the syntax 'column_name as
 *                     alias'.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_projection_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a projectionName.
 *                 If @a persist is @a false (or unspecified), then this is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_projection_name.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li> gpudb::create_projection_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 projection as part of @a projectionName and use
 *                 /create/schema to create the schema if non-existent]  Name
 *                 of a schema for the projection. If the schema is
 *                 non-existent, it will be automatically created.  The default
 *                 value is ''.
 *                         <li> gpudb::create_projection_expression: An
 *                 optional filter <a href="../../../concepts/expressions/"
 *                 target="_top">expression</a> to be applied to the source
 *                 table prior to the projection.  The default value is ''.
 *                         <li> gpudb::create_projection_is_replicated: If @a
 *                 true then the projection will be replicated even if the
 *                 source table is not.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li> gpudb::create_projection_offset: The number of
 *                 initial results to skip (this can be useful for paging
 *                 through the results).  The default value is '0'.
 *                         <li> gpudb::create_projection_limit: The number of
 *                 records to keep.  The default value is '-9999'.
 *                         <li> gpudb::create_projection_order_by:
 *                 Comma-separated list of the columns to be sorted by; e.g.
 *                 'timestamp asc, x desc'.  The columns specified must be
 *                 present in @a columnNames.  If any alias is given for any
 *                 column name, the alias must be used, rather than the
 *                 original column name.  The default value is ''.
 *                         <li> gpudb::create_projection_chunk_size: Indicates
 *                 the number of records per chunk to be used for this
 *                 projection.
 *                         <li> gpudb::create_projection_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the projection.  The columns specified must be present in
 *                 @a columnNames.  If any alias is given for any column name,
 *                 the alias must be used, rather than the original column
 *                 name.
 *                         <li> gpudb::create_projection_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 projection specified in @a projectionName.
 *                         <li> gpudb::create_projection_shard_key:
 *                 Comma-separated list of the columns to be sharded on; e.g.
 *                 'column1, column2'.  The columns specified must be present
 *                 in @a columnNames.  If any alias is given for any column
 *                 name, the alias must be used, rather than the original
 *                 column name.  The default value is ''.
 *                         <li> gpudb::create_projection_persist: If @a true,
 *                 then the projection specified in @a projectionName will be
 *                 persisted and will not expire unless a @a ttl is specified.
 *                 If @a false, then the projection will be an in-memory table
 *                 and will expire unless a @a ttl is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li>
 *                 gpudb::create_projection_preserve_dict_encoding: If @a true,
 *                 then columns that were dict encoded in the source table will
 *                 be dict encoded in the projection.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_true.
 *                         <li> gpudb::create_projection_retain_partitions:
 *                 Determines whether the created projection will retain the
 *                 partitioning scheme from the source table.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li> gpudb::create_projection_partition_type: <a
 *                 href="../../../concepts/tables/#partitioning"
 *                 target="_top">Partitioning</a> scheme to use.
 *                 <ul>
 *                         <li> gpudb::create_projection_RANGE: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-range"
 *                 target="_top">range partitioning</a>.
 *                         <li> gpudb::create_projection_INTERVAL: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-interval"
 *                 target="_top">interval partitioning</a>.
 *                         <li> gpudb::create_projection_LIST: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-list"
 *                 target="_top">list partitioning</a>.
 *                         <li> gpudb::create_projection_HASH: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-hash"
 *                 target="_top">hash partitioning</a>.
 *                         <li> gpudb::create_projection_SERIES: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-series"
 *                 target="_top">series partitioning</a>.
 *                 </ul>
 *                         <li> gpudb::create_projection_partition_keys:
 *                 Comma-separated list of partition keys, which are the
 *                 columns or column expressions by which records will be
 *                 assigned to partitions defined by @a partition_definitions.
 *                         <li> gpudb::create_projection_partition_definitions:
 *                 Comma-separated list of partition definitions, whose format
 *                 depends on the choice of @a partition_type.  See <a
 *                 href="../../../concepts/tables/#partitioning-by-range"
 *                 target="_top">range partitioning</a>, <a
 *                 href="../../../concepts/tables/#partitioning-by-interval"
 *                 target="_top">interval partitioning</a>, <a
 *                 href="../../../concepts/tables/#partitioning-by-list"
 *                 target="_top">list partitioning</a>, <a
 *                 href="../../../concepts/tables/#partitioning-by-hash"
 *                 target="_top">hash partitioning</a>, or <a
 *                 href="../../../concepts/tables/#partitioning-by-series"
 *                 target="_top">series partitioning</a> for example formats.
 *                         <li>
 *                 gpudb::create_projection_is_automatic_partition: If @a true,
 *                 a new partition will be created for values which don't fall
 *                 into an existing partition.  Currently only supported for <a
 *                 href="../../../concepts/tables/#partitioning-by-list"
 *                 target="_top">list partitions</a>.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li> gpudb::create_projection_view_id: ID of view of
 *                 which this projection is a member.  The default value is ''.
 *                         <li> gpudb::create_projection_strategy_definition:
 *                 The <a href="../../../rm/concepts/#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateProjectionResponse& createProjection( const std::string& tableName,
                                            const std::string& projectionName,
                                            const std::vector<std::string>& columnNames,
                                            const std::map<std::string, std::string>& options,
                                            CreateProjectionResponse& response_ ) const;

/**
 * Creates a new resource group to facilitate resource management.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateResourceGroupResponse createResourceGroup( const CreateResourceGroupRequest& request_ ) const;

/**
 * Creates a new resource group to facilitate resource management.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateResourceGroupResponse& createResourceGroup( const CreateResourceGroupRequest& request_,
                                                  CreateResourceGroupResponse& response_ ) const;

/**
 * Creates a new resource group to facilitate resource management.
 * 
 * @param name  Name of the group to be created. Must contain only letters,
 *              digits, and underscores, and cannot begin with a digit. Must
 *              not match existing resource group name.
 * @param tierAttributes  Optional map containing tier names and their
 *                        respective attribute group limits.  The only valid
 *                        attribute limit that can be set is max_memory (in
 *                        bytes) for the VRAM & RAM tiers.
 *                        For instance, to set max VRAM capacity to 1GB and max
 *                        RAM capacity to 10GB, use:
 *                        {'VRAM':{'max_memory':'1000000000'},
 *                        'RAM':{'max_memory':'10000000000'}}
 *                        <ul>
 *                                <li> gpudb::create_resource_group_max_memory:
 *                        Maximum amount of memory usable in the given tier at
 *                        one time for this group.
 *                        </ul>
 * @param ranking  Indicates the relative ranking among existing resource
 *                 groups where this new resource group will be placed.  When
 *                 using @a before or @a after, specify which resource group
 *                 this one will be inserted before or after in @a
 *                 adjoiningResourceGroup.
 *                 <ul>
 *                         <li> gpudb::create_resource_group_first
 *                         <li> gpudb::create_resource_group_last
 *                         <li> gpudb::create_resource_group_before
 *                         <li> gpudb::create_resource_group_after
 *                 </ul>
 * @param adjoiningResourceGroup  If @a ranking is @a before or @a after, this
 *                                field indicates the resource group before or
 *                                after which the current group will be placed;
 *                                otherwise, leave blank.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::create_resource_group_max_cpu_concurrency: Maximum
 *                 number of simultaneous threads that will be used to execute
 *                 a request for this group.
 *                         <li> gpudb::create_resource_group_max_data: Maximum
 *                 amount of cumulative ram usage regardless of tier status for
 *                 this group.
 *                         <li>
 *                 gpudb::create_resource_group_max_scheduling_priority:
 *                 Maximum priority of a scheduled task for this group.
 *                         <li> gpudb::create_resource_group_max_tier_priority:
 *                 Maximum priority of a tiered object for this group.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateResourceGroupResponse createResourceGroup( const std::string& name,
                                                 const std::map<std::string, std::map<std::string, std::string> >& tierAttributes,
                                                 const std::string& ranking,
                                                 const std::string& adjoiningResourceGroup,
                                                 const std::map<std::string, std::string>& options ) const;

/**
 * Creates a new resource group to facilitate resource management.
 * 
 * @param name  Name of the group to be created. Must contain only letters,
 *              digits, and underscores, and cannot begin with a digit. Must
 *              not match existing resource group name.
 * @param tierAttributes  Optional map containing tier names and their
 *                        respective attribute group limits.  The only valid
 *                        attribute limit that can be set is max_memory (in
 *                        bytes) for the VRAM & RAM tiers.
 *                        For instance, to set max VRAM capacity to 1GB and max
 *                        RAM capacity to 10GB, use:
 *                        {'VRAM':{'max_memory':'1000000000'},
 *                        'RAM':{'max_memory':'10000000000'}}
 *                        <ul>
 *                                <li> gpudb::create_resource_group_max_memory:
 *                        Maximum amount of memory usable in the given tier at
 *                        one time for this group.
 *                        </ul>
 * @param ranking  Indicates the relative ranking among existing resource
 *                 groups where this new resource group will be placed.  When
 *                 using @a before or @a after, specify which resource group
 *                 this one will be inserted before or after in @a
 *                 adjoiningResourceGroup.
 *                 <ul>
 *                         <li> gpudb::create_resource_group_first
 *                         <li> gpudb::create_resource_group_last
 *                         <li> gpudb::create_resource_group_before
 *                         <li> gpudb::create_resource_group_after
 *                 </ul>
 * @param adjoiningResourceGroup  If @a ranking is @a before or @a after, this
 *                                field indicates the resource group before or
 *                                after which the current group will be placed;
 *                                otherwise, leave blank.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::create_resource_group_max_cpu_concurrency: Maximum
 *                 number of simultaneous threads that will be used to execute
 *                 a request for this group.
 *                         <li> gpudb::create_resource_group_max_data: Maximum
 *                 amount of cumulative ram usage regardless of tier status for
 *                 this group.
 *                         <li>
 *                 gpudb::create_resource_group_max_scheduling_priority:
 *                 Maximum priority of a scheduled task for this group.
 *                         <li> gpudb::create_resource_group_max_tier_priority:
 *                 Maximum priority of a tiered object for this group.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateResourceGroupResponse& createResourceGroup( const std::string& name,
                                                  const std::map<std::string, std::map<std::string, std::string> >& tierAttributes,
                                                  const std::string& ranking,
                                                  const std::string& adjoiningResourceGroup,
                                                  const std::map<std::string, std::string>& options,
                                                  CreateResourceGroupResponse& response_ ) const;

/**
 * Creates a new role.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateRoleResponse createRole( const CreateRoleRequest& request_ ) const;

/**
 * Creates a new role.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateRoleResponse& createRole( const CreateRoleRequest& request_,
                                CreateRoleResponse& response_ ) const;

/**
 * Creates a new role.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param name  Name of the role to be created. Must contain only lowercase
 *              letters, digits, and underscores, and cannot begin with a
 *              digit. Must not be the same name as an existing user or role.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_role_resource_group: Name of an
 *                 existing resource group to associate with this user
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateRoleResponse createRole( const std::string& name,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Creates a new role.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param name  Name of the role to be created. Must contain only lowercase
 *              letters, digits, and underscores, and cannot begin with a
 *              digit. Must not be the same name as an existing user or role.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_role_resource_group: Name of an
 *                 existing resource group to associate with this user
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateRoleResponse& createRole( const std::string& name,
                                const std::map<std::string, std::string>& options,
                                CreateRoleResponse& response_ ) const;

/**
 * Creates a SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>. Schemas are containers for tables and views.
 * Multiple tables and views can be defined with the same name in different
 * schemas.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateSchemaResponse createSchema( const CreateSchemaRequest& request_ ) const;

/**
 * Creates a SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>. Schemas are containers for tables and views.
 * Multiple tables and views can be defined with the same name in different
 * schemas.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateSchemaResponse& createSchema( const CreateSchemaRequest& request_,
                                    CreateSchemaResponse& response_ ) const;

/**
 * Creates a SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>. Schemas are containers for tables and views.
 * Multiple tables and views can be defined with the same name in different
 * schemas.
 * 
 * @param schemaName  Name of the schema to be created.  Has the same naming
 *                    restrictions as <a href="../../../concepts/tables/"
 *                    target="_top">tables</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_schema_no_error_if_exists: If @a
 *                 true, prevents an error from occurring if the schema already
 *                 exists.
 *                 <ul>
 *                         <li> gpudb::create_schema_true
 *                         <li> gpudb::create_schema_false
 *                 </ul>
 *                 The default value is gpudb::create_schema_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateSchemaResponse createSchema( const std::string& schemaName,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Creates a SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>. Schemas are containers for tables and views.
 * Multiple tables and views can be defined with the same name in different
 * schemas.
 * 
 * @param schemaName  Name of the schema to be created.  Has the same naming
 *                    restrictions as <a href="../../../concepts/tables/"
 *                    target="_top">tables</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_schema_no_error_if_exists: If @a
 *                 true, prevents an error from occurring if the schema already
 *                 exists.
 *                 <ul>
 *                         <li> gpudb::create_schema_true
 *                         <li> gpudb::create_schema_false
 *                 </ul>
 *                 The default value is gpudb::create_schema_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateSchemaResponse& createSchema( const std::string& schemaName,
                                    const std::map<std::string, std::string>& options,
                                    CreateSchemaResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateStateTableResponse createStateTable( const CreateStateTableRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateStateTableResponse& createStateTable( const CreateStateTableRequest& request_,
                                            CreateStateTableResponse& response_ ) const;

/**
 * @private
 * 
 * @param tableName
 * @param inputTableName
 * @param initTableName
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateStateTableResponse createStateTable( const std::string& tableName,
                                           const std::string& inputTableName,
                                           const std::string& initTableName,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param tableName
 * @param inputTableName
 * @param initTableName
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateStateTableResponse& createStateTable( const std::string& tableName,
                                            const std::string& inputTableName,
                                            const std::string& initTableName,
                                            const std::map<std::string, std::string>& options,
                                            CreateStateTableResponse& response_ ) const;

/**
 * Creates a new table. If a new table is being created,
 * the type of the table is given by @a typeId, which must be the ID of
 * a currently registered type (i.e. one created via {@link
 * #createType(const CreateTypeRequest&) const}).
 * <p>
 * A table may optionally be designated to use a
 * <a href="../../../concepts/tables/#replication" target="_top">replicated</a>
 * distribution scheme,
 * or be assigned: <a href="../../../concepts/tables/#foreign-keys"
 * target="_top">foreign keys</a> to
 * other tables, a <a href="../../../concepts/tables/#partitioning"
 * target="_top">partitioning</a>
 * scheme, and/or a <a href="../../../rm/concepts/#tier-strategies"
 * target="_top">tier strategy</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableResponse createTable( const CreateTableRequest& request_ ) const;

/**
 * Creates a new table. If a new table is being created,
 * the type of the table is given by @a typeId, which must be the ID of
 * a currently registered type (i.e. one created via {@link
 * #createType(const CreateTypeRequest&,CreateTypeResponse&) const}).
 * <p>
 * A table may optionally be designated to use a
 * <a href="../../../concepts/tables/#replication" target="_top">replicated</a>
 * distribution scheme,
 * or be assigned: <a href="../../../concepts/tables/#foreign-keys"
 * target="_top">foreign keys</a> to
 * other tables, a <a href="../../../concepts/tables/#partitioning"
 * target="_top">partitioning</a>
 * scheme, and/or a <a href="../../../rm/concepts/#tier-strategies"
 * target="_top">tier strategy</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableResponse& createTable( const CreateTableRequest& request_,
                                  CreateTableResponse& response_ ) const;

/**
 * Creates a new table. If a new table is being created,
 * the type of the table is given by @a typeId, which must be the ID of
 * a currently registered type (i.e. one created via {@link
 * #createType(const std::string&,const std::string&,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&) const}).
 * <p>
 * A table may optionally be designated to use a
 * <a href="../../../concepts/tables/#replication" target="_top">replicated</a>
 * distribution scheme,
 * or be assigned: <a href="../../../concepts/tables/#foreign-keys"
 * target="_top">foreign keys</a> to
 * other tables, a <a href="../../../concepts/tables/#partitioning"
 * target="_top">partitioning</a>
 * scheme, and/or a <a href="../../../rm/concepts/#tier-strategies"
 * target="_top">tier strategy</a>.
 * 
 * @param tableName  Name of the table to be created, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a> and meeting <a
 *                   href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>. Error for
 *                   requests with existing table of the same name and type ID
 *                   may be suppressed by using the @a no_error_if_exists
 *                   option.
 * @param typeId  ID of a currently registered type. All objects added to the
 *                newly created table will be of this type.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_table_no_error_if_exists: If @a
 *                 true, prevents an error from occurring if the table already
 *                 exists and is of the given type.  If a table with the same
 *                 ID but a different type exists, it is still an error.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a tableName. If @a
 *                 is_result_table is @a true, then this is always allowed even
 *                 if the caller does not have permission to create tables. The
 *                 generated name is returned in @a qualified_table_name.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_collection_name:
 *                 [DEPRECATED--please specify the containing schema as part of
 *                 @a tableName and use /create/schema to create the schema if
 *                 non-existent]  Name of a schema which is to contain the
 *                 newly created table. If the schema is non-existent, it will
 *                 be automatically created.
 *                         <li> gpudb::create_table_is_collection:
 *                 [DEPRECATED--please use /create/schema to create a schema
 *                 instead]  Indicates whether to create a schema instead of a
 *                 table.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li>
 *                 gpudb::create_table_disallow_homogeneous_tables: No longer
 *                 supported; value will be ignored.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_is_replicated: Affects the
 *                 <a href="../../../concepts/tables/#distribution"
 *                 target="_top">distribution scheme</a> for the table's data.
 *                 If @a true and the given type has no explicit <a
 *                 href="../../../concepts/tables/#shard-key"
 *                 target="_top">shard key</a> defined, the table will be <a
 *                 href="../../../concepts/tables/#replication"
 *                 target="_top">replicated</a>.  If @a false, the table will
 *                 be <a href="../../../concepts/tables/#sharding"
 *                 target="_top">sharded</a> according to the shard key
 *                 specified in the given @a typeId, or <a
 *                 href="../../../concepts/tables/#random-sharding"
 *                 target="_top">randomly sharded</a>, if no shard key is
 *                 specified.  Note that a type containing a shard key cannot
 *                 be used to create a replicated table.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_foreign_keys:
 *                 Semicolon-separated list of <a
 *                 href="../../../concepts/tables/#foreign-keys"
 *                 target="_top">foreign keys</a>, of the format
 *                 '(source_column_name [, ...]) references
 *                 target_table_name(primary_key_column_name [, ...]) [as
 *                 foreign_key_name]'.
 *                         <li> gpudb::create_table_foreign_shard_key: Foreign
 *                 shard key of the format 'source_column references
 *                 shard_by_column from target_table(primary_key_column)'.
 *                         <li> gpudb::create_table_partition_type: <a
 *                 href="../../../concepts/tables/#partitioning"
 *                 target="_top">Partitioning</a> scheme to use.
 *                 <ul>
 *                         <li> gpudb::create_table_RANGE: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-range"
 *                 target="_top">range partitioning</a>.
 *                         <li> gpudb::create_table_INTERVAL: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-interval"
 *                 target="_top">interval partitioning</a>.
 *                         <li> gpudb::create_table_LIST: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-list"
 *                 target="_top">list partitioning</a>.
 *                         <li> gpudb::create_table_HASH: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-hash"
 *                 target="_top">hash partitioning</a>.
 *                         <li> gpudb::create_table_SERIES: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-series"
 *                 target="_top">series partitioning</a>.
 *                 </ul>
 *                         <li> gpudb::create_table_partition_keys:
 *                 Comma-separated list of partition keys, which are the
 *                 columns or column expressions by which records will be
 *                 assigned to partitions defined by @a partition_definitions.
 *                         <li> gpudb::create_table_partition_definitions:
 *                 Comma-separated list of partition definitions, whose format
 *                 depends on the choice of @a partition_type.  See <a
 *                 href="../../../concepts/tables/#partitioning-by-range"
 *                 target="_top">range partitioning</a>, <a
 *                 href="../../../concepts/tables/#partitioning-by-interval"
 *                 target="_top">interval partitioning</a>, <a
 *                 href="../../../concepts/tables/#partitioning-by-list"
 *                 target="_top">list partitioning</a>, <a
 *                 href="../../../concepts/tables/#partitioning-by-hash"
 *                 target="_top">hash partitioning</a>, or <a
 *                 href="../../../concepts/tables/#partitioning-by-series"
 *                 target="_top">series partitioning</a> for example formats.
 *                         <li> gpudb::create_table_is_automatic_partition: If
 *                 @a true, a new partition will be created for values which
 *                 don't fall into an existing partition.  Currently only
 *                 supported for <a
 *                 href="../../../concepts/tables/#partitioning-by-list"
 *                 target="_top">list partitions</a>.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 table specified in @a tableName.
 *                         <li> gpudb::create_table_chunk_size: Indicates the
 *                 number of records per chunk to be used for this table.
 *                         <li> gpudb::create_table_is_result_table: Indicates
 *                 whether the table is a <a
 *                 href="../../../concepts/tables_memory_only/"
 *                 target="_top">memory-only table</a>. A result table cannot
 *                 contain columns with store_only or text_search <a
 *                 href="../../../concepts/types/#data-handling"
 *                 target="_top">data-handling</a> or that are <a
 *                 href="../../../concepts/types/#primitive-types"
 *                 target="_top">non-charN strings</a>, and it will not be
 *                 retained if the server is restarted.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_strategy_definition: The <a
 *                 href="../../../rm/concepts/#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableResponse createTable( const std::string& tableName,
                                 const std::string& typeId,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Creates a new table. If a new table is being created,
 * the type of the table is given by @a typeId, which must be the ID of
 * a currently registered type (i.e. one created via {@link
 * #createType(const std::string&,const std::string&,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&,CreateTypeResponse&) const}).
 * <p>
 * A table may optionally be designated to use a
 * <a href="../../../concepts/tables/#replication" target="_top">replicated</a>
 * distribution scheme,
 * or be assigned: <a href="../../../concepts/tables/#foreign-keys"
 * target="_top">foreign keys</a> to
 * other tables, a <a href="../../../concepts/tables/#partitioning"
 * target="_top">partitioning</a>
 * scheme, and/or a <a href="../../../rm/concepts/#tier-strategies"
 * target="_top">tier strategy</a>.
 * 
 * @param tableName  Name of the table to be created, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a> and meeting <a
 *                   href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>. Error for
 *                   requests with existing table of the same name and type ID
 *                   may be suppressed by using the @a no_error_if_exists
 *                   option.
 * @param typeId  ID of a currently registered type. All objects added to the
 *                newly created table will be of this type.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_table_no_error_if_exists: If @a
 *                 true, prevents an error from occurring if the table already
 *                 exists and is of the given type.  If a table with the same
 *                 ID but a different type exists, it is still an error.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a tableName. If @a
 *                 is_result_table is @a true, then this is always allowed even
 *                 if the caller does not have permission to create tables. The
 *                 generated name is returned in @a qualified_table_name.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_collection_name:
 *                 [DEPRECATED--please specify the containing schema as part of
 *                 @a tableName and use /create/schema to create the schema if
 *                 non-existent]  Name of a schema which is to contain the
 *                 newly created table. If the schema is non-existent, it will
 *                 be automatically created.
 *                         <li> gpudb::create_table_is_collection:
 *                 [DEPRECATED--please use /create/schema to create a schema
 *                 instead]  Indicates whether to create a schema instead of a
 *                 table.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li>
 *                 gpudb::create_table_disallow_homogeneous_tables: No longer
 *                 supported; value will be ignored.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_is_replicated: Affects the
 *                 <a href="../../../concepts/tables/#distribution"
 *                 target="_top">distribution scheme</a> for the table's data.
 *                 If @a true and the given type has no explicit <a
 *                 href="../../../concepts/tables/#shard-key"
 *                 target="_top">shard key</a> defined, the table will be <a
 *                 href="../../../concepts/tables/#replication"
 *                 target="_top">replicated</a>.  If @a false, the table will
 *                 be <a href="../../../concepts/tables/#sharding"
 *                 target="_top">sharded</a> according to the shard key
 *                 specified in the given @a typeId, or <a
 *                 href="../../../concepts/tables/#random-sharding"
 *                 target="_top">randomly sharded</a>, if no shard key is
 *                 specified.  Note that a type containing a shard key cannot
 *                 be used to create a replicated table.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_foreign_keys:
 *                 Semicolon-separated list of <a
 *                 href="../../../concepts/tables/#foreign-keys"
 *                 target="_top">foreign keys</a>, of the format
 *                 '(source_column_name [, ...]) references
 *                 target_table_name(primary_key_column_name [, ...]) [as
 *                 foreign_key_name]'.
 *                         <li> gpudb::create_table_foreign_shard_key: Foreign
 *                 shard key of the format 'source_column references
 *                 shard_by_column from target_table(primary_key_column)'.
 *                         <li> gpudb::create_table_partition_type: <a
 *                 href="../../../concepts/tables/#partitioning"
 *                 target="_top">Partitioning</a> scheme to use.
 *                 <ul>
 *                         <li> gpudb::create_table_RANGE: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-range"
 *                 target="_top">range partitioning</a>.
 *                         <li> gpudb::create_table_INTERVAL: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-interval"
 *                 target="_top">interval partitioning</a>.
 *                         <li> gpudb::create_table_LIST: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-list"
 *                 target="_top">list partitioning</a>.
 *                         <li> gpudb::create_table_HASH: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-hash"
 *                 target="_top">hash partitioning</a>.
 *                         <li> gpudb::create_table_SERIES: Use <a
 *                 href="../../../concepts/tables/#partitioning-by-series"
 *                 target="_top">series partitioning</a>.
 *                 </ul>
 *                         <li> gpudb::create_table_partition_keys:
 *                 Comma-separated list of partition keys, which are the
 *                 columns or column expressions by which records will be
 *                 assigned to partitions defined by @a partition_definitions.
 *                         <li> gpudb::create_table_partition_definitions:
 *                 Comma-separated list of partition definitions, whose format
 *                 depends on the choice of @a partition_type.  See <a
 *                 href="../../../concepts/tables/#partitioning-by-range"
 *                 target="_top">range partitioning</a>, <a
 *                 href="../../../concepts/tables/#partitioning-by-interval"
 *                 target="_top">interval partitioning</a>, <a
 *                 href="../../../concepts/tables/#partitioning-by-list"
 *                 target="_top">list partitioning</a>, <a
 *                 href="../../../concepts/tables/#partitioning-by-hash"
 *                 target="_top">hash partitioning</a>, or <a
 *                 href="../../../concepts/tables/#partitioning-by-series"
 *                 target="_top">series partitioning</a> for example formats.
 *                         <li> gpudb::create_table_is_automatic_partition: If
 *                 @a true, a new partition will be created for values which
 *                 don't fall into an existing partition.  Currently only
 *                 supported for <a
 *                 href="../../../concepts/tables/#partitioning-by-list"
 *                 target="_top">list partitions</a>.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 table specified in @a tableName.
 *                         <li> gpudb::create_table_chunk_size: Indicates the
 *                 number of records per chunk to be used for this table.
 *                         <li> gpudb::create_table_is_result_table: Indicates
 *                 whether the table is a <a
 *                 href="../../../concepts/tables_memory_only/"
 *                 target="_top">memory-only table</a>. A result table cannot
 *                 contain columns with store_only or text_search <a
 *                 href="../../../concepts/types/#data-handling"
 *                 target="_top">data-handling</a> or that are <a
 *                 href="../../../concepts/types/#primitive-types"
 *                 target="_top">non-charN strings</a>, and it will not be
 *                 retained if the server is restarted.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_strategy_definition: The <a
 *                 href="../../../rm/concepts/#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableResponse& createTable( const std::string& tableName,
                                  const std::string& typeId,
                                  const std::map<std::string, std::string>& options,
                                  CreateTableResponse& response_ ) const;

/**
 * Creates a new <a href="../../../concepts/external_tables/"
 * target="_top">external table</a>, which is a
 * local database object whose source data is located externally to the
 * database.  The source data can
 * be located either in <a href="../../../tools/kifs/" target="_top">KiFS</a>;
 * on the cluster, accessible to the database; or remotely, accessible via a
 * pre-defined external <a href="../../../concepts/data_sources/"
 * target="_top">data source</a>.
 * <p>
 * The external table can have its structure defined explicitly, via @a
 * createTableOptions,
 * which contains many of the options from {@link
 * #createTable(const CreateTableRequest&) const}; or defined implicitly,
 * inferred
 * from the source data.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableExternalResponse createTableExternal( const CreateTableExternalRequest& request_ ) const;

/**
 * Creates a new <a href="../../../concepts/external_tables/"
 * target="_top">external table</a>, which is a
 * local database object whose source data is located externally to the
 * database.  The source data can
 * be located either in <a href="../../../tools/kifs/" target="_top">KiFS</a>;
 * on the cluster, accessible to the database; or remotely, accessible via a
 * pre-defined external <a href="../../../concepts/data_sources/"
 * target="_top">data source</a>.
 * <p>
 * The external table can have its structure defined explicitly, via @a
 * createTableOptions,
 * which contains many of the options from {@link
 * #createTable(const CreateTableRequest&,CreateTableResponse&) const}; or
 * defined implicitly, inferred
 * from the source data.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableExternalResponse& createTableExternal( const CreateTableExternalRequest& request_,
                                                  CreateTableExternalResponse& response_ ) const;

/**
 * Creates a new <a href="../../../concepts/external_tables/"
 * target="_top">external table</a>, which is a
 * local database object whose source data is located externally to the
 * database.  The source data can
 * be located either in <a href="../../../tools/kifs/" target="_top">KiFS</a>;
 * on the cluster, accessible to the database; or remotely, accessible via a
 * pre-defined external <a href="../../../concepts/data_sources/"
 * target="_top">data source</a>.
 * <p>
 * The external table can have its structure defined explicitly, via @a
 * createTableOptions,
 * which contains many of the options from {@link
 * #createTable(const std::string&,const std::string&,const std::map<std::string, std::string>&) const};
 * or defined implicitly, inferred
 * from the source data.
 * 
 * @param tableName  Name of the table to be created, in
 *                   [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a> and meeting
 *                   <a href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>.
 * @param filepaths  A list of file paths from which data will be sourced;
 *                   For paths in <a href="../../../tools/kifs/"
 *                   target="_top">KiFS</a>, use the uri prefix of kifs://
 *                   followed by the path to
 *                   a file or directory. File matching by prefix is supported,
 *                   e.g. kifs://dir/file would match dir/file_1
 *                   and dir/file_2. When prefix matching is used, the path
 *                   must start with a full, valid KiFS directory name.
 *                   If an external data source is specified in @a
 *                   datasource_name, these file
 *                   paths must resolve to accessible files at that data source
 *                   location. Prefix matching is supported.
 *                   If the data source is hdfs, prefixes must be aligned with
 *                   directories, i.e. partial file names will not match.
 *                   If no data source is specified, the files are assumed to
 *                   be local to the database and must all be
 *                   accessible to the gpudb user, residing on the path (or
 *                   relative to the path) specified by the
 *                   external files directory in the Kinetica
 *                   <a href="../../../config/#config-main-external-files"
 *                   target="_top">configuration file</a>. Wildcards (*) can be
 *                   used to
 *                   specify a group of files.  Prefix matching is supported,
 *                   the prefixes must be aligned with
 *                   directories.
 *                   If the first path ends in .tsv, the text delimiter will be
 *                   defaulted to a tab character.
 *                   If the first path ends in .psv, the text delimiter will be
 *                   defaulted to a pipe character (|).
 * @param modifyColumns  Not implemented yet
 * @param createTableOptions  Options from /create/table, allowing the
 *                            structure of the table to
 *                            be defined independently of the data source
 *                            <ul>
 *                                    <li>
 *                            gpudb::create_table_external_type_id: ID of a
 *                            currently registered <a
 *                            href="../../../concepts/types/"
 *                            target="_top">type</a>.  The default value is ''.
 *                                    <li>
 *                            gpudb::create_table_external_no_error_if_exists:
 *                            If @a true,
 *                            prevents an error from occurring if the table
 *                            already exists and is of the given type.  If a
 *                            table with
 *                            the same name but a different type exists, it is
 *                            still an error.
 *                            <ul>
 *                                    <li> gpudb::create_table_external_true
 *                                    <li> gpudb::create_table_external_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::create_table_external_false.
 *                                    <li>
 *                            gpudb::create_table_external_is_replicated:
 *                            Affects the <a
 *                            href="../../../concepts/tables/#distribution"
 *                            target="_top">distribution scheme</a>
 *                            for the table's data.  If @a true and the
 *                            given table has no explicit <a
 *                            href="../../../concepts/tables/#shard-key"
 *                            target="_top">shard key</a> defined, the
 *                            table will be <a
 *                            href="../../../concepts/tables/#replication"
 *                            target="_top">replicated</a>.  If
 *                            @a false, the table will be
 *                            <a href="../../../concepts/tables/#sharding"
 *                            target="_top">sharded</a> according to the shard
 *                            key specified in the
 *                            given @a type_id, or
 *                            <a
 *                            href="../../../concepts/tables/#random-sharding"
 *                            target="_top">randomly sharded</a>, if no shard
 *                            key is specified.
 *                            Note that a type containing a shard key cannot be
 *                            used to create a replicated table.
 *                            <ul>
 *                                    <li> gpudb::create_table_external_true
 *                                    <li> gpudb::create_table_external_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::create_table_external_false.
 *                                    <li>
 *                            gpudb::create_table_external_foreign_keys:
 *                            Semicolon-separated list of
 *                            <a href="../../../concepts/tables/#foreign-keys"
 *                            target="_top">foreign keys</a>, of the format
 *                            '(source_column_name [, ...]) references
 *                            target_table_name(primary_key_column_name [,
 *                            ...]) [as foreign_key_name]'.
 *                                    <li>
 *                            gpudb::create_table_external_foreign_shard_key:
 *                            Foreign shard key of the format
 *                            'source_column references shard_by_column from
 *                            target_table(primary_key_column)'.
 *                                    <li>
 *                            gpudb::create_table_external_partition_type: <a
 *                            href="../../../concepts/tables/#partitioning"
 *                            target="_top">Partitioning</a> scheme to use.
 *                            <ul>
 *                                    <li> gpudb::create_table_external_RANGE:
 *                            Use <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>.
 *                                    <li>
 *                            gpudb::create_table_external_INTERVAL: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>.
 *                                    <li> gpudb::create_table_external_LIST:
 *                            Use <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>.
 *                                    <li> gpudb::create_table_external_HASH:
 *                            Use <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a>.
 *                                    <li> gpudb::create_table_external_SERIES:
 *                            Use <a
 *                            href="../../../concepts/tables/#partitioning-by-series"
 *                            target="_top">series partitioning</a>.
 *                            </ul>
 *                                    <li>
 *                            gpudb::create_table_external_partition_keys:
 *                            Comma-separated list of partition keys, which are
 *                            the columns or
 *                            column expressions by which records will be
 *                            assigned to partitions defined by
 *                            @a partition_definitions.
 *                                    <li>
 *                            gpudb::create_table_external_partition_definitions:
 *                            Comma-separated list of partition definitions,
 *                            whose format depends
 *                            on the choice of @a partition_type.  See
 *                            <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>,
 *                            <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>,
 *                            <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>, or
 *                            <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a> for example
 *                            formats.
 *                                    <li>
 *                            gpudb::create_table_external_is_automatic_partition:
 *                            If @a true,
 *                            a new partition will be created for values which
 *                            don't fall into an existing partition.  Currently
 *                            only supported for <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitions</a>.
 *                            <ul>
 *                                    <li> gpudb::create_table_external_true
 *                                    <li> gpudb::create_table_external_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::create_table_external_false.
 *                                    <li> gpudb::create_table_external_ttl:
 *                            Sets the <a href="../../../concepts/ttl/"
 *                            target="_top">TTL</a> of the table specified in
 *                            @a tableName.
 *                                    <li>
 *                            gpudb::create_table_external_chunk_size:
 *                            Indicates the number of records per chunk to be
 *                            used for this table.
 *                                    <li>
 *                            gpudb::create_table_external_is_result_table:
 *                            Indicates whether the table is a
 *                            <a href="../../../concepts/tables_memory_only/"
 *                            target="_top">memory-only table</a>. A result
 *                            table cannot contain
 *                            columns with store_only or text_search
 *                            <a href="../../../concepts/types/#data-handling"
 *                            target="_top">data-handling</a> or that are
 *                            <a
 *                            href="../../../concepts/types/#primitive-types"
 *                            target="_top">non-charN strings</a>, and it will
 *                            not be retained if
 *                            the server is restarted.
 *                            <ul>
 *                                    <li> gpudb::create_table_external_true
 *                                    <li> gpudb::create_table_external_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::create_table_external_false.
 *                                    <li>
 *                            gpudb::create_table_external_strategy_definition:
 *                            The <a
 *                            href="../../../rm/concepts/#tier-strategies"
 *                            target="_top">tier strategy</a>
 *                            for the table and its columns.
 *                            </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_table_external_avro_header_bytes:
 *                 Optional number of bytes to skip when reading an avro
 *                 record.
 *                         <li> gpudb::create_table_external_avro_num_records:
 *                 Optional number of avro records, if data includes only
 *                 records.
 *                         <li> gpudb::create_table_external_avro_schema:
 *                 Optional string representing avro schema, for insert records
 *                 in avro format, that does not include is schema.
 *                         <li> gpudb::create_table_external_avro_schemaless:
 *                 When user provides 'avro_schema', avro data is assumed to be
 *                 schemaless, unless specified. Default is 'true' when given
 *                 avro_schema. Igonred when avro_schema is not given.
 *                 <ul>
 *                         <li> gpudb::create_table_external_true
 *                         <li> gpudb::create_table_external_false
 *                 </ul>
 *                         <li>
 *                 gpudb::create_table_external_bad_record_table_name: Optional
 *                 name of a table to which records that were rejected are
 *                 written.  The bad-record-table has the following columns:
 *                 line_number (long), line_rejected (string), error_message
 *                 (string).
 *                         <li>
 *                 gpudb::create_table_external_bad_record_table_limit: A
 *                 positive integer indicating the maximum number of records
 *                 that can be  written to the bad-record-table.   Default
 *                 value is 10000
 *                         <li>
 *                 gpudb::create_table_external_bad_record_table_limit_per_input:
 *                 For subscriptions: A positive integer indicating the maximum
 *                 number of records that can be written to the
 *                 bad-record-table per file/payload. Default value will be
 *                 'bad_record_table_limit' and total size of the table per
 *                 rank is limited to 'bad_record_table_limit'
 *                         <li> gpudb::create_table_external_batch_size:
 *                 Internal tuning parameter--number of records per batch when
 *                 inserting data.
 *                         <li> gpudb::create_table_external_column_formats:
 *                 For each target column specified, applies the
 *                 column-property-bound format to the source data
 *                 loaded into that column.  Each column format will contain a
 *                 mapping of one or more of its column
 *                 properties to an appropriate format for each property.
 *                 Currently supported column properties
 *                 include date, time, & datetime. The parameter value must be
 *                 formatted as a JSON string of maps of
 *                 column names to maps of column properties to their
 *                 corresponding column formats, e.g.,
 *                 '{ "order_date" : { "date" : "%Y.%m.%d" }, "order_time" : {
 *                 "time" : "%H:%M:%S" } }'.
 *                 See @a default_column_formats for valid format syntax.
 *                         <li> gpudb::create_table_external_columns_to_load:
 *                 Specifies a comma-delimited list of columns from the source
 *                 data to
 *                 load.  If more than one file is being loaded, this list
 *                 applies to all files.
 *                 Column numbers can be specified discretely or as a range.
 *                 For example, a value of '5,7,1..3' will
 *                 insert values from the fifth column in the source data into
 *                 the first column in the target table,
 *                 from the seventh column in the source data into the second
 *                 column in the target table, and from the
 *                 first through third columns in the source data into the
 *                 third through fifth columns in the target
 *                 table.
 *                 If the source data contains a header, column names matching
 *                 the file header names may be provided
 *                 instead of column numbers.  If the target table doesn't
 *                 exist, the table will be created with the
 *                 columns in this order.  If the target table does exist with
 *                 columns in a different order than the
 *                 source data, this list can be used to match the order of the
 *                 target table.  For example, a value of
 *                 'C, B, A' will create a three column table with column C,
 *                 followed by column B, followed by column
 *                 A; or will insert those fields in that order into a table
 *                 created with columns in that order.  If
 *                 the target table exists, the column names must match the
 *                 source data field names for a name-mapping
 *                 to be successful.
 *                 Mutually exclusive with @a columns_to_skip.
 *                         <li> gpudb::create_table_external_columns_to_skip:
 *                 Specifies a comma-delimited list of columns from the source
 *                 data to
 *                 skip.  Mutually exclusive with @a columns_to_load.
 *                         <li> gpudb::create_table_external_compression_type:
 *                 Optional: compression type
 *                 <ul>
 *                         <li> gpudb::create_table_external_none: Uncompressed
 *                         <li> gpudb::create_table_external_auto: Default.
 *                 Auto detect compression type
 *                         <li> gpudb::create_table_external_gzip: gzip file
 *                 compression.
 *                         <li> gpudb::create_table_external_bzip2: bzip2 file
 *                 compression.
 *                 </ul>
 *                 The default value is gpudb::create_table_external_auto.
 *                         <li> gpudb::create_table_external_datasource_name:
 *                 Name of an existing external data source from which data
 *                 file(s) specified in @a filepaths will be loaded
 *                         <li>
 *                 gpudb::create_table_external_default_column_formats:
 *                 Specifies the default format to be applied to source data
 *                 loaded
 *                 into columns with the corresponding column property.
 *                 Currently supported column properties include
 *                 date, time, & datetime.  This default column-property-bound
 *                 format can be overridden by specifying a
 *                 column property & format for a given target column in @a
 *                 column_formats. For
 *                 each specified annotation, the format will apply to all
 *                 columns with that annotation unless a custom
 *                 @a column_formats for that annotation is specified.
 *                 The parameter value must be formatted as a JSON string that
 *                 is a map of column properties to their
 *                 respective column formats, e.g., '{ "date" : "%Y.%m.%d",
 *                 "time" : "%H:%M:%S" }'.  Column
 *                 formats are specified as a string of control characters and
 *                 plain text. The supported control
 *                 characters are 'Y', 'm', 'd', 'H', 'M', 'S', and 's', which
 *                 follow the Linux 'strptime()'
 *                 specification, as well as 's', which specifies seconds and
 *                 fractional seconds (though the fractional
 *                 component will be truncated past milliseconds).
 *                 Formats for the 'date' annotation must include the 'Y', 'm',
 *                 and 'd' control characters. Formats for
 *                 the 'time' annotation must include the 'H', 'M', and either
 *                 'S' or 's' (but not both) control
 *                 characters. Formats for the 'datetime' annotation meet both
 *                 the 'date' and 'time' control character
 *                 requirements. For example, '{"datetime" : "%m/%d/%Y
 *                 %H:%M:%S" }' would be used to interpret text
 *                 as "05/04/2000 12:12:11"
 *                         <li> gpudb::create_table_external_error_handling:
 *                 Specifies how errors should be handled upon insertion.
 *                 <ul>
 *                         <li> gpudb::create_table_external_permissive:
 *                 Records with missing columns are populated with nulls if
 *                 possible; otherwise, the malformed records are skipped.
 *                         <li>
 *                 gpudb::create_table_external_ignore_bad_records: Malformed
 *                 records are skipped.
 *                         <li> gpudb::create_table_external_abort: Stops
 *                 current insertion and aborts entire operation when an error
 *                 is encountered.  Primary key collisions are considered
 *                 abortable errors in this mode.
 *                 </ul>
 *                 The default value is gpudb::create_table_external_abort.
 *                         <li>
 *                 gpudb::create_table_external_external_table_type: Specifies
 *                 whether the external table holds a local copy of the
 *                 external data.
 *                 <ul>
 *                         <li> gpudb::create_table_external_materialized:
 *                 Loads a copy of the external data into the database,
 *                 refreshed on demand
 *                         <li> gpudb::create_table_external_logical: External
 *                 data will not be loaded into the database; the data will be
 *                 retrieved from the source upon servicing each query against
 *                 the external table
 *                 </ul>
 *                 The default value is
 *                 gpudb::create_table_external_materialized.
 *                         <li> gpudb::create_table_external_file_type:
 *                 Specifies the type of the file(s) whose records will be
 *                 inserted.
 *                 <ul>
 *                         <li> gpudb::create_table_external_avro: Avro file
 *                 format
 *                         <li> gpudb::create_table_external_delimited_text:
 *                 Delimited text file format; e.g., CSV, TSV, PSV, etc.
 *                         <li> gpudb::create_table_external_gdb: Esri/GDB file
 *                 format
 *                         <li> gpudb::create_table_external_json: Json file
 *                 format
 *                         <li> gpudb::create_table_external_parquet: Apache
 *                 Parquet file format
 *                         <li> gpudb::create_table_external_shapefile:
 *                 ShapeFile file format
 *                 </ul>
 *                 The default value is
 *                 gpudb::create_table_external_delimited_text.
 *                         <li>
 *                 gpudb::create_table_external_gdal_configuration_options:
 *                 Comma separated list of gdal conf options, for the specific
 *                 requets: key=value.  The default value is ''.
 *                         <li>
 *                 gpudb::create_table_external_ignore_existing_pk: Specifies
 *                 the record collision error-suppression policy for
 *                 inserting into a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only used when
 *                 not in upsert mode (upsert mode is disabled when @a
 *                 update_on_existing_pk is
 *                 @a false).  If set to
 *                 @a true, any record being inserted that is rejected
 *                 for having primary key values that match those of an
 *                 existing table record will be ignored with no
 *                 error generated.  If @a false, the rejection of any
 *                 record for having primary key values matching an existing
 *                 record will result in an error being
 *                 reported, as determined by @a error_handling.  If the
 *                 specified table does not
 *                 have a primary key or if upsert mode is in effect (@a
 *                 update_on_existing_pk is
 *                 @a true), then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::create_table_external_true: Ignore new
 *                 records whose primary key values collide with those of
 *                 existing records
 *                         <li> gpudb::create_table_external_false: Treat as
 *                 errors any new records whose primary key values collide with
 *                 those of existing records
 *                 </ul>
 *                 The default value is gpudb::create_table_external_false.
 *                         <li> gpudb::create_table_external_ingestion_mode:
 *                 Whether to do a full load, dry run, or perform a type
 *                 inference on the source data.
 *                 <ul>
 *                         <li> gpudb::create_table_external_full: Run a type
 *                 inference on the source data (if needed) and ingest
 *                         <li> gpudb::create_table_external_dry_run: Does not
 *                 load data, but walks through the source data and determines
 *                 the number of valid records, taking into account the current
 *                 mode of @a error_handling.
 *                         <li>
 *                 gpudb::create_table_external_type_inference_only: Infer the
 *                 type of the source data and return, without ingesting any
 *                 data.  The inferred type is returned in the response.
 *                 </ul>
 *                 The default value is gpudb::create_table_external_full.
 *                         <li> gpudb::create_table_external_jdbc_fetch_size:
 *                 The JDBC fetch size, which determines how many rows to fetch
 *                 per round trip.
 *                         <li> gpudb::create_table_external_kafka_group_id:
 *                 The group id to be used consuming data from a kakfa topic
 *                 (valid only for kafka datasource subscriptions).
 *                         <li>
 *                 gpudb::create_table_external_kafka_offset_reset_policy:
 *                 Policy to determine whether the data consumption starts
 *                 either at earliest offset or latest offset.
 *                 <ul>
 *                         <li> gpudb::create_table_external_earliest
 *                         <li> gpudb::create_table_external_latest
 *                 </ul>
 *                 The default value is gpudb::create_table_external_earliest.
 *                         <li>
 *                 gpudb::create_table_external_kafka_subscription_cancel_after:
 *                 Sets the subscription lifespan (in minutes). Expired
 *                 subscription will be cancelled automatically.
 *                         <li> gpudb::create_table_external_layer: Optional:
 *                 geo files layer(s) name(s): comma separated.  The default
 *                 value is ''.
 *                         <li> gpudb::create_table_external_loading_mode:
 *                 Scheme for distributing the extraction and loading of data
 *                 from the source data file(s). This option applies only when
 *                 loading files that are local to the database
 *                 <ul>
 *                         <li> gpudb::create_table_external_head: The head
 *                 node loads all data. All files must be available to the head
 *                 node.
 *                         <li>
 *                 gpudb::create_table_external_distributed_shared: The head
 *                 node coordinates loading data by worker
 *                 processes across all nodes from shared files available to
 *                 all workers.
 *                 NOTE:
 *                 Instead of existing on a shared source, the files can be
 *                 duplicated on a source local to each host
 *                 to improve performance, though the files must appear as the
 *                 same data set from the perspective of
 *                 all hosts performing the load.
 *                         <li> gpudb::create_table_external_distributed_local:
 *                 A single worker process on each node loads all files
 *                 that are available to it. This option works best when each
 *                 worker loads files from its own file
 *                 system, to maximize performance. In order to avoid data
 *                 duplication, either each worker performing
 *                 the load needs to have visibility to a set of files unique
 *                 to it (no file is visible to more than
 *                 one node) or the target table needs to have a primary key
 *                 (which will allow the worker to
 *                 automatically deduplicate data).
 *                 NOTE:
 *                 If the target table doesn't exist, the table structure will
 *                 be determined by the head node. If the
 *                 head node has no files local to it, it will be unable to
 *                 determine the structure and the request
 *                 will fail.
 *                 If the head node is configured to have no worker processes,
 *                 no data strictly accessible to the head
 *                 node will be loaded.
 *                 </ul>
 *                 The default value is gpudb::create_table_external_head.
 *                         <li> gpudb::create_table_external_local_time_offset:
 *                 For Avro local timestamp columns
 *                         <li>
 *                 gpudb::create_table_external_max_records_to_load: Limit the
 *                 number of records to load in this request: If this number is
 *                 larger than a batch_size, then the number of records loaded
 *                 will be limited to the next whole number of batch_size (per
 *                 working thread).  The default value is ''.
 *                         <li>
 *                 gpudb::create_table_external_num_tasks_per_rank: Optional:
 *                 number of tasks for reading file per rank. Default will be
 *                 external_file_reader_num_tasks
 *                         <li> gpudb::create_table_external_poll_interval: If
 *                 @a true, the number of seconds between attempts to load
 *                 external files into the table.  If zero, polling will be
 *                 continuous as long as data is found.  If no data is found,
 *                 the interval will steadily increase to a maximum of 60
 *                 seconds.
 *                         <li> gpudb::create_table_external_primary_keys:
 *                 Optional: comma separated list of column names, to set as
 *                 primary keys, when not specified in the type.  The default
 *                 value is ''.
 *                         <li> gpudb::create_table_external_refresh_method:
 *                 Method by which the table can be refreshed from its source
 *                 data.
 *                 <ul>
 *                         <li> gpudb::create_table_external_manual: Refresh
 *                 only occurs when manually requested by invoking the refresh
 *                 action of /alter/table on this table.
 *                         <li> gpudb::create_table_external_on_start: Refresh
 *                 table on database startup and when manually requested by
 *                 invoking the refresh action of /alter/table on this table.
 *                 </ul>
 *                 The default value is gpudb::create_table_external_manual.
 *                         <li>
 *                 gpudb::create_table_external_schema_registry_schema_id
 *                         <li>
 *                 gpudb::create_table_external_schema_registry_schema_name
 *                         <li>
 *                 gpudb::create_table_external_schema_registry_schema_version
 *                         <li> gpudb::create_table_external_shard_keys:
 *                 Optional: comma separated list of column names, to set as
 *                 primary keys, when not specified in the type.  The default
 *                 value is ''.
 *                         <li> gpudb::create_table_external_skip_lines: Skip
 *                 number of lines from begining of file.
 *                         <li> gpudb::create_table_external_subscribe:
 *                 Continuously poll the data source to check for new data and
 *                 load it into the table.
 *                 <ul>
 *                         <li> gpudb::create_table_external_true
 *                         <li> gpudb::create_table_external_false
 *                 </ul>
 *                 The default value is gpudb::create_table_external_false.
 *                         <li> gpudb::create_table_external_table_insert_mode:
 *                 Optional: table_insert_mode. When inserting records from
 *                 multiple files: if table_per_file then insert from each file
 *                 into a new table. Currently supported only for shapefiles.
 *                 <ul>
 *                         <li> gpudb::create_table_external_single
 *                         <li> gpudb::create_table_external_table_per_file
 *                 </ul>
 *                 The default value is gpudb::create_table_external_single.
 *                         <li>
 *                 gpudb::create_table_external_text_comment_string: Specifies
 *                 the character string that should be interpreted as a comment
 *                 line
 *                 prefix in the source data.  All lines in the data starting
 *                 with the provided string are ignored.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '#'.
 *                         <li> gpudb::create_table_external_text_delimiter:
 *                 Specifies the character delimiting field values in the
 *                 source data
 *                 and field names in the header (if present).
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is ','.
 *                         <li>
 *                 gpudb::create_table_external_text_escape_character:
 *                 Specifies the character that is used to escape other
 *                 characters in
 *                 the source data.
 *                 An 'a', 'b', 'f', 'n', 'r', 't', or 'v' preceded by an
 *                 escape character will be interpreted as the
 *                 ASCII bell, backspace, form feed, line feed, carriage
 *                 return, horizontal tab, & vertical tab,
 *                 respectively.  For example, the escape character followed by
 *                 an 'n' will be interpreted as a newline
 *                 within a field value.
 *                 The escape character can also be used to escape the quoting
 *                 character, and will be treated as an
 *                 escape character whether it is within a quoted field value
 *                 or not.
 *                 For @a delimited_text @a file_type only.
 *                         <li> gpudb::create_table_external_text_has_header:
 *                 Indicates whether the source data contains a header row.
 *                 For @a delimited_text @a file_type only.
 *                 <ul>
 *                         <li> gpudb::create_table_external_true
 *                         <li> gpudb::create_table_external_false
 *                 </ul>
 *                 The default value is gpudb::create_table_external_true.
 *                         <li>
 *                 gpudb::create_table_external_text_header_property_delimiter:
 *                 Specifies the delimiter for
 *                 <a href="../../../concepts/types/#column-properties"
 *                 target="_top">column properties</a> in the header row (if
 *                 present).  Cannot be set to same value as @a text_delimiter.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '|'.
 *                         <li> gpudb::create_table_external_text_null_string:
 *                 Specifies the character string that should be interpreted as
 *                 a null
 *                 value in the source data.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '\\N'.
 *                         <li>
 *                 gpudb::create_table_external_text_quote_character: Specifies
 *                 the character that should be interpreted as a field value
 *                 quoting character in the source data.  The character must
 *                 appear at beginning and end of field value
 *                 to take effect.  Delimiters within quoted fields are treated
 *                 as literals and not delimiters.  Within
 *                 a quoted field, two consecutive quote characters will be
 *                 interpreted as a single literal quote
 *                 character, effectively escaping it.  To not have a quote
 *                 character, specify an empty string.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '"'.
 *                         <li>
 *                 gpudb::create_table_external_text_search_columns: Add
 *                 'text_search' property to internally inferenced string
 *                 columns. Comma seperated list of column names or '*' for all
 *                 columns. To add text_search property only to string columns
 *                 of minimum size, set also the option
 *                 'text_search_min_column_length'
 *                         <li>
 *                 gpudb::create_table_external_text_search_min_column_length:
 *                 Set minimum column size. Used only when
 *                 'text_search_columns' has a value.
 *                         <li> gpudb::create_table_external_truncate_strings:
 *                 If set to @a true, truncate string values that are longer
 *                 than the column's type size.
 *                 <ul>
 *                         <li> gpudb::create_table_external_true
 *                         <li> gpudb::create_table_external_false
 *                 </ul>
 *                 The default value is gpudb::create_table_external_false.
 *                         <li> gpudb::create_table_external_truncate_table: If
 *                 set to @a true, truncates the table specified by @a
 *                 tableName prior to loading the file(s).
 *                 <ul>
 *                         <li> gpudb::create_table_external_true
 *                         <li> gpudb::create_table_external_false
 *                 </ul>
 *                 The default value is gpudb::create_table_external_false.
 *                         <li>
 *                 gpudb::create_table_external_type_inference_mode: optimize
 *                 type inference for:
 *                 <ul>
 *                         <li> gpudb::create_table_external_accuracy: Scans
 *                 data to get exactly-typed & sized columns for all data
 *                 scanned.
 *                         <li> gpudb::create_table_external_speed: Scans data
 *                 and picks the widest possible column types so that 'all'
 *                 values will fit with minimum data scanned
 *                 </ul>
 *                 The default value is gpudb::create_table_external_speed.
 *                         <li> gpudb::create_table_external_remote_query:
 *                 Remote SQL query from which data will be sourced
 *                         <li>
 *                 gpudb::create_table_external_remote_query_filter_column:
 *                 Name of column to be used for splitting the query into
 *                 multiple sub-queries using the data distribution of given
 *                 column.  The default value is ''.
 *                         <li>
 *                 gpudb::create_table_external_remote_query_increasing_column:
 *                 Column on subscribed remote query result that will increase
 *                 for new records (e.g., TIMESTAMP).  The default value is ''.
 *                         <li>
 *                 gpudb::create_table_external_remote_query_partition_column:
 *                 Alias name for remote_query_filter_column.  The default
 *                 value is ''.
 *                         <li>
 *                 gpudb::create_table_external_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting into a
 *                 table
 *                 with a <a href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>. If set to
 *                 @a true, any existing table record with primary
 *                 key values that match those of a record being inserted will
 *                 be replaced by that new record (the new
 *                 data will be "upserted"). If set to @a false,
 *                 any existing table record with primary key values that match
 *                 those of a record being inserted will
 *                 remain unchanged, while the new record will be rejected and
 *                 the error handled as determined by
 *                 @a ignore_existing_pk & @a error_handling.  If the
 *                 specified table does not have a primary key, then this
 *                 option has no effect.
 *                 <ul>
 *                         <li> gpudb::create_table_external_true: Upsert new
 *                 records when primary keys match existing records
 *                         <li> gpudb::create_table_external_false: Reject new
 *                 records when primary keys match existing records
 *                 </ul>
 *                 The default value is gpudb::create_table_external_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableExternalResponse createTableExternal( const std::string& tableName,
                                                 const std::vector<std::string>& filepaths,
                                                 const std::map<std::string, std::map<std::string, std::string> >& modifyColumns,
                                                 const std::map<std::string, std::string>& createTableOptions,
                                                 const std::map<std::string, std::string>& options ) const;

/**
 * Creates a new <a href="../../../concepts/external_tables/"
 * target="_top">external table</a>, which is a
 * local database object whose source data is located externally to the
 * database.  The source data can
 * be located either in <a href="../../../tools/kifs/" target="_top">KiFS</a>;
 * on the cluster, accessible to the database; or remotely, accessible via a
 * pre-defined external <a href="../../../concepts/data_sources/"
 * target="_top">data source</a>.
 * <p>
 * The external table can have its structure defined explicitly, via @a
 * createTableOptions,
 * which contains many of the options from {@link
 * #createTable(const std::string&,const std::string&,const std::map<std::string, std::string>&,CreateTableResponse&) const};
 * or defined implicitly, inferred
 * from the source data.
 * 
 * @param tableName  Name of the table to be created, in
 *                   [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a> and meeting
 *                   <a href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>.
 * @param filepaths  A list of file paths from which data will be sourced;
 *                   For paths in <a href="../../../tools/kifs/"
 *                   target="_top">KiFS</a>, use the uri prefix of kifs://
 *                   followed by the path to
 *                   a file or directory. File matching by prefix is supported,
 *                   e.g. kifs://dir/file would match dir/file_1
 *                   and dir/file_2. When prefix matching is used, the path
 *                   must start with a full, valid KiFS directory name.
 *                   If an external data source is specified in @a
 *                   datasource_name, these file
 *                   paths must resolve to accessible files at that data source
 *                   location. Prefix matching is supported.
 *                   If the data source is hdfs, prefixes must be aligned with
 *                   directories, i.e. partial file names will not match.
 *                   If no data source is specified, the files are assumed to
 *                   be local to the database and must all be
 *                   accessible to the gpudb user, residing on the path (or
 *                   relative to the path) specified by the
 *                   external files directory in the Kinetica
 *                   <a href="../../../config/#config-main-external-files"
 *                   target="_top">configuration file</a>. Wildcards (*) can be
 *                   used to
 *                   specify a group of files.  Prefix matching is supported,
 *                   the prefixes must be aligned with
 *                   directories.
 *                   If the first path ends in .tsv, the text delimiter will be
 *                   defaulted to a tab character.
 *                   If the first path ends in .psv, the text delimiter will be
 *                   defaulted to a pipe character (|).
 * @param modifyColumns  Not implemented yet
 * @param createTableOptions  Options from /create/table, allowing the
 *                            structure of the table to
 *                            be defined independently of the data source
 *                            <ul>
 *                                    <li>
 *                            gpudb::create_table_external_type_id: ID of a
 *                            currently registered <a
 *                            href="../../../concepts/types/"
 *                            target="_top">type</a>.  The default value is ''.
 *                                    <li>
 *                            gpudb::create_table_external_no_error_if_exists:
 *                            If @a true,
 *                            prevents an error from occurring if the table
 *                            already exists and is of the given type.  If a
 *                            table with
 *                            the same name but a different type exists, it is
 *                            still an error.
 *                            <ul>
 *                                    <li> gpudb::create_table_external_true
 *                                    <li> gpudb::create_table_external_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::create_table_external_false.
 *                                    <li>
 *                            gpudb::create_table_external_is_replicated:
 *                            Affects the <a
 *                            href="../../../concepts/tables/#distribution"
 *                            target="_top">distribution scheme</a>
 *                            for the table's data.  If @a true and the
 *                            given table has no explicit <a
 *                            href="../../../concepts/tables/#shard-key"
 *                            target="_top">shard key</a> defined, the
 *                            table will be <a
 *                            href="../../../concepts/tables/#replication"
 *                            target="_top">replicated</a>.  If
 *                            @a false, the table will be
 *                            <a href="../../../concepts/tables/#sharding"
 *                            target="_top">sharded</a> according to the shard
 *                            key specified in the
 *                            given @a type_id, or
 *                            <a
 *                            href="../../../concepts/tables/#random-sharding"
 *                            target="_top">randomly sharded</a>, if no shard
 *                            key is specified.
 *                            Note that a type containing a shard key cannot be
 *                            used to create a replicated table.
 *                            <ul>
 *                                    <li> gpudb::create_table_external_true
 *                                    <li> gpudb::create_table_external_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::create_table_external_false.
 *                                    <li>
 *                            gpudb::create_table_external_foreign_keys:
 *                            Semicolon-separated list of
 *                            <a href="../../../concepts/tables/#foreign-keys"
 *                            target="_top">foreign keys</a>, of the format
 *                            '(source_column_name [, ...]) references
 *                            target_table_name(primary_key_column_name [,
 *                            ...]) [as foreign_key_name]'.
 *                                    <li>
 *                            gpudb::create_table_external_foreign_shard_key:
 *                            Foreign shard key of the format
 *                            'source_column references shard_by_column from
 *                            target_table(primary_key_column)'.
 *                                    <li>
 *                            gpudb::create_table_external_partition_type: <a
 *                            href="../../../concepts/tables/#partitioning"
 *                            target="_top">Partitioning</a> scheme to use.
 *                            <ul>
 *                                    <li> gpudb::create_table_external_RANGE:
 *                            Use <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>.
 *                                    <li>
 *                            gpudb::create_table_external_INTERVAL: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>.
 *                                    <li> gpudb::create_table_external_LIST:
 *                            Use <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>.
 *                                    <li> gpudb::create_table_external_HASH:
 *                            Use <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a>.
 *                                    <li> gpudb::create_table_external_SERIES:
 *                            Use <a
 *                            href="../../../concepts/tables/#partitioning-by-series"
 *                            target="_top">series partitioning</a>.
 *                            </ul>
 *                                    <li>
 *                            gpudb::create_table_external_partition_keys:
 *                            Comma-separated list of partition keys, which are
 *                            the columns or
 *                            column expressions by which records will be
 *                            assigned to partitions defined by
 *                            @a partition_definitions.
 *                                    <li>
 *                            gpudb::create_table_external_partition_definitions:
 *                            Comma-separated list of partition definitions,
 *                            whose format depends
 *                            on the choice of @a partition_type.  See
 *                            <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>,
 *                            <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>,
 *                            <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>, or
 *                            <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a> for example
 *                            formats.
 *                                    <li>
 *                            gpudb::create_table_external_is_automatic_partition:
 *                            If @a true,
 *                            a new partition will be created for values which
 *                            don't fall into an existing partition.  Currently
 *                            only supported for <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitions</a>.
 *                            <ul>
 *                                    <li> gpudb::create_table_external_true
 *                                    <li> gpudb::create_table_external_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::create_table_external_false.
 *                                    <li> gpudb::create_table_external_ttl:
 *                            Sets the <a href="../../../concepts/ttl/"
 *                            target="_top">TTL</a> of the table specified in
 *                            @a tableName.
 *                                    <li>
 *                            gpudb::create_table_external_chunk_size:
 *                            Indicates the number of records per chunk to be
 *                            used for this table.
 *                                    <li>
 *                            gpudb::create_table_external_is_result_table:
 *                            Indicates whether the table is a
 *                            <a href="../../../concepts/tables_memory_only/"
 *                            target="_top">memory-only table</a>. A result
 *                            table cannot contain
 *                            columns with store_only or text_search
 *                            <a href="../../../concepts/types/#data-handling"
 *                            target="_top">data-handling</a> or that are
 *                            <a
 *                            href="../../../concepts/types/#primitive-types"
 *                            target="_top">non-charN strings</a>, and it will
 *                            not be retained if
 *                            the server is restarted.
 *                            <ul>
 *                                    <li> gpudb::create_table_external_true
 *                                    <li> gpudb::create_table_external_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::create_table_external_false.
 *                                    <li>
 *                            gpudb::create_table_external_strategy_definition:
 *                            The <a
 *                            href="../../../rm/concepts/#tier-strategies"
 *                            target="_top">tier strategy</a>
 *                            for the table and its columns.
 *                            </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_table_external_avro_header_bytes:
 *                 Optional number of bytes to skip when reading an avro
 *                 record.
 *                         <li> gpudb::create_table_external_avro_num_records:
 *                 Optional number of avro records, if data includes only
 *                 records.
 *                         <li> gpudb::create_table_external_avro_schema:
 *                 Optional string representing avro schema, for insert records
 *                 in avro format, that does not include is schema.
 *                         <li> gpudb::create_table_external_avro_schemaless:
 *                 When user provides 'avro_schema', avro data is assumed to be
 *                 schemaless, unless specified. Default is 'true' when given
 *                 avro_schema. Igonred when avro_schema is not given.
 *                 <ul>
 *                         <li> gpudb::create_table_external_true
 *                         <li> gpudb::create_table_external_false
 *                 </ul>
 *                         <li>
 *                 gpudb::create_table_external_bad_record_table_name: Optional
 *                 name of a table to which records that were rejected are
 *                 written.  The bad-record-table has the following columns:
 *                 line_number (long), line_rejected (string), error_message
 *                 (string).
 *                         <li>
 *                 gpudb::create_table_external_bad_record_table_limit: A
 *                 positive integer indicating the maximum number of records
 *                 that can be  written to the bad-record-table.   Default
 *                 value is 10000
 *                         <li>
 *                 gpudb::create_table_external_bad_record_table_limit_per_input:
 *                 For subscriptions: A positive integer indicating the maximum
 *                 number of records that can be written to the
 *                 bad-record-table per file/payload. Default value will be
 *                 'bad_record_table_limit' and total size of the table per
 *                 rank is limited to 'bad_record_table_limit'
 *                         <li> gpudb::create_table_external_batch_size:
 *                 Internal tuning parameter--number of records per batch when
 *                 inserting data.
 *                         <li> gpudb::create_table_external_column_formats:
 *                 For each target column specified, applies the
 *                 column-property-bound format to the source data
 *                 loaded into that column.  Each column format will contain a
 *                 mapping of one or more of its column
 *                 properties to an appropriate format for each property.
 *                 Currently supported column properties
 *                 include date, time, & datetime. The parameter value must be
 *                 formatted as a JSON string of maps of
 *                 column names to maps of column properties to their
 *                 corresponding column formats, e.g.,
 *                 '{ "order_date" : { "date" : "%Y.%m.%d" }, "order_time" : {
 *                 "time" : "%H:%M:%S" } }'.
 *                 See @a default_column_formats for valid format syntax.
 *                         <li> gpudb::create_table_external_columns_to_load:
 *                 Specifies a comma-delimited list of columns from the source
 *                 data to
 *                 load.  If more than one file is being loaded, this list
 *                 applies to all files.
 *                 Column numbers can be specified discretely or as a range.
 *                 For example, a value of '5,7,1..3' will
 *                 insert values from the fifth column in the source data into
 *                 the first column in the target table,
 *                 from the seventh column in the source data into the second
 *                 column in the target table, and from the
 *                 first through third columns in the source data into the
 *                 third through fifth columns in the target
 *                 table.
 *                 If the source data contains a header, column names matching
 *                 the file header names may be provided
 *                 instead of column numbers.  If the target table doesn't
 *                 exist, the table will be created with the
 *                 columns in this order.  If the target table does exist with
 *                 columns in a different order than the
 *                 source data, this list can be used to match the order of the
 *                 target table.  For example, a value of
 *                 'C, B, A' will create a three column table with column C,
 *                 followed by column B, followed by column
 *                 A; or will insert those fields in that order into a table
 *                 created with columns in that order.  If
 *                 the target table exists, the column names must match the
 *                 source data field names for a name-mapping
 *                 to be successful.
 *                 Mutually exclusive with @a columns_to_skip.
 *                         <li> gpudb::create_table_external_columns_to_skip:
 *                 Specifies a comma-delimited list of columns from the source
 *                 data to
 *                 skip.  Mutually exclusive with @a columns_to_load.
 *                         <li> gpudb::create_table_external_compression_type:
 *                 Optional: compression type
 *                 <ul>
 *                         <li> gpudb::create_table_external_none: Uncompressed
 *                         <li> gpudb::create_table_external_auto: Default.
 *                 Auto detect compression type
 *                         <li> gpudb::create_table_external_gzip: gzip file
 *                 compression.
 *                         <li> gpudb::create_table_external_bzip2: bzip2 file
 *                 compression.
 *                 </ul>
 *                 The default value is gpudb::create_table_external_auto.
 *                         <li> gpudb::create_table_external_datasource_name:
 *                 Name of an existing external data source from which data
 *                 file(s) specified in @a filepaths will be loaded
 *                         <li>
 *                 gpudb::create_table_external_default_column_formats:
 *                 Specifies the default format to be applied to source data
 *                 loaded
 *                 into columns with the corresponding column property.
 *                 Currently supported column properties include
 *                 date, time, & datetime.  This default column-property-bound
 *                 format can be overridden by specifying a
 *                 column property & format for a given target column in @a
 *                 column_formats. For
 *                 each specified annotation, the format will apply to all
 *                 columns with that annotation unless a custom
 *                 @a column_formats for that annotation is specified.
 *                 The parameter value must be formatted as a JSON string that
 *                 is a map of column properties to their
 *                 respective column formats, e.g., '{ "date" : "%Y.%m.%d",
 *                 "time" : "%H:%M:%S" }'.  Column
 *                 formats are specified as a string of control characters and
 *                 plain text. The supported control
 *                 characters are 'Y', 'm', 'd', 'H', 'M', 'S', and 's', which
 *                 follow the Linux 'strptime()'
 *                 specification, as well as 's', which specifies seconds and
 *                 fractional seconds (though the fractional
 *                 component will be truncated past milliseconds).
 *                 Formats for the 'date' annotation must include the 'Y', 'm',
 *                 and 'd' control characters. Formats for
 *                 the 'time' annotation must include the 'H', 'M', and either
 *                 'S' or 's' (but not both) control
 *                 characters. Formats for the 'datetime' annotation meet both
 *                 the 'date' and 'time' control character
 *                 requirements. For example, '{"datetime" : "%m/%d/%Y
 *                 %H:%M:%S" }' would be used to interpret text
 *                 as "05/04/2000 12:12:11"
 *                         <li> gpudb::create_table_external_error_handling:
 *                 Specifies how errors should be handled upon insertion.
 *                 <ul>
 *                         <li> gpudb::create_table_external_permissive:
 *                 Records with missing columns are populated with nulls if
 *                 possible; otherwise, the malformed records are skipped.
 *                         <li>
 *                 gpudb::create_table_external_ignore_bad_records: Malformed
 *                 records are skipped.
 *                         <li> gpudb::create_table_external_abort: Stops
 *                 current insertion and aborts entire operation when an error
 *                 is encountered.  Primary key collisions are considered
 *                 abortable errors in this mode.
 *                 </ul>
 *                 The default value is gpudb::create_table_external_abort.
 *                         <li>
 *                 gpudb::create_table_external_external_table_type: Specifies
 *                 whether the external table holds a local copy of the
 *                 external data.
 *                 <ul>
 *                         <li> gpudb::create_table_external_materialized:
 *                 Loads a copy of the external data into the database,
 *                 refreshed on demand
 *                         <li> gpudb::create_table_external_logical: External
 *                 data will not be loaded into the database; the data will be
 *                 retrieved from the source upon servicing each query against
 *                 the external table
 *                 </ul>
 *                 The default value is
 *                 gpudb::create_table_external_materialized.
 *                         <li> gpudb::create_table_external_file_type:
 *                 Specifies the type of the file(s) whose records will be
 *                 inserted.
 *                 <ul>
 *                         <li> gpudb::create_table_external_avro: Avro file
 *                 format
 *                         <li> gpudb::create_table_external_delimited_text:
 *                 Delimited text file format; e.g., CSV, TSV, PSV, etc.
 *                         <li> gpudb::create_table_external_gdb: Esri/GDB file
 *                 format
 *                         <li> gpudb::create_table_external_json: Json file
 *                 format
 *                         <li> gpudb::create_table_external_parquet: Apache
 *                 Parquet file format
 *                         <li> gpudb::create_table_external_shapefile:
 *                 ShapeFile file format
 *                 </ul>
 *                 The default value is
 *                 gpudb::create_table_external_delimited_text.
 *                         <li>
 *                 gpudb::create_table_external_gdal_configuration_options:
 *                 Comma separated list of gdal conf options, for the specific
 *                 requets: key=value.  The default value is ''.
 *                         <li>
 *                 gpudb::create_table_external_ignore_existing_pk: Specifies
 *                 the record collision error-suppression policy for
 *                 inserting into a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only used when
 *                 not in upsert mode (upsert mode is disabled when @a
 *                 update_on_existing_pk is
 *                 @a false).  If set to
 *                 @a true, any record being inserted that is rejected
 *                 for having primary key values that match those of an
 *                 existing table record will be ignored with no
 *                 error generated.  If @a false, the rejection of any
 *                 record for having primary key values matching an existing
 *                 record will result in an error being
 *                 reported, as determined by @a error_handling.  If the
 *                 specified table does not
 *                 have a primary key or if upsert mode is in effect (@a
 *                 update_on_existing_pk is
 *                 @a true), then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::create_table_external_true: Ignore new
 *                 records whose primary key values collide with those of
 *                 existing records
 *                         <li> gpudb::create_table_external_false: Treat as
 *                 errors any new records whose primary key values collide with
 *                 those of existing records
 *                 </ul>
 *                 The default value is gpudb::create_table_external_false.
 *                         <li> gpudb::create_table_external_ingestion_mode:
 *                 Whether to do a full load, dry run, or perform a type
 *                 inference on the source data.
 *                 <ul>
 *                         <li> gpudb::create_table_external_full: Run a type
 *                 inference on the source data (if needed) and ingest
 *                         <li> gpudb::create_table_external_dry_run: Does not
 *                 load data, but walks through the source data and determines
 *                 the number of valid records, taking into account the current
 *                 mode of @a error_handling.
 *                         <li>
 *                 gpudb::create_table_external_type_inference_only: Infer the
 *                 type of the source data and return, without ingesting any
 *                 data.  The inferred type is returned in the response.
 *                 </ul>
 *                 The default value is gpudb::create_table_external_full.
 *                         <li> gpudb::create_table_external_jdbc_fetch_size:
 *                 The JDBC fetch size, which determines how many rows to fetch
 *                 per round trip.
 *                         <li> gpudb::create_table_external_kafka_group_id:
 *                 The group id to be used consuming data from a kakfa topic
 *                 (valid only for kafka datasource subscriptions).
 *                         <li>
 *                 gpudb::create_table_external_kafka_offset_reset_policy:
 *                 Policy to determine whether the data consumption starts
 *                 either at earliest offset or latest offset.
 *                 <ul>
 *                         <li> gpudb::create_table_external_earliest
 *                         <li> gpudb::create_table_external_latest
 *                 </ul>
 *                 The default value is gpudb::create_table_external_earliest.
 *                         <li>
 *                 gpudb::create_table_external_kafka_subscription_cancel_after:
 *                 Sets the subscription lifespan (in minutes). Expired
 *                 subscription will be cancelled automatically.
 *                         <li> gpudb::create_table_external_layer: Optional:
 *                 geo files layer(s) name(s): comma separated.  The default
 *                 value is ''.
 *                         <li> gpudb::create_table_external_loading_mode:
 *                 Scheme for distributing the extraction and loading of data
 *                 from the source data file(s). This option applies only when
 *                 loading files that are local to the database
 *                 <ul>
 *                         <li> gpudb::create_table_external_head: The head
 *                 node loads all data. All files must be available to the head
 *                 node.
 *                         <li>
 *                 gpudb::create_table_external_distributed_shared: The head
 *                 node coordinates loading data by worker
 *                 processes across all nodes from shared files available to
 *                 all workers.
 *                 NOTE:
 *                 Instead of existing on a shared source, the files can be
 *                 duplicated on a source local to each host
 *                 to improve performance, though the files must appear as the
 *                 same data set from the perspective of
 *                 all hosts performing the load.
 *                         <li> gpudb::create_table_external_distributed_local:
 *                 A single worker process on each node loads all files
 *                 that are available to it. This option works best when each
 *                 worker loads files from its own file
 *                 system, to maximize performance. In order to avoid data
 *                 duplication, either each worker performing
 *                 the load needs to have visibility to a set of files unique
 *                 to it (no file is visible to more than
 *                 one node) or the target table needs to have a primary key
 *                 (which will allow the worker to
 *                 automatically deduplicate data).
 *                 NOTE:
 *                 If the target table doesn't exist, the table structure will
 *                 be determined by the head node. If the
 *                 head node has no files local to it, it will be unable to
 *                 determine the structure and the request
 *                 will fail.
 *                 If the head node is configured to have no worker processes,
 *                 no data strictly accessible to the head
 *                 node will be loaded.
 *                 </ul>
 *                 The default value is gpudb::create_table_external_head.
 *                         <li> gpudb::create_table_external_local_time_offset:
 *                 For Avro local timestamp columns
 *                         <li>
 *                 gpudb::create_table_external_max_records_to_load: Limit the
 *                 number of records to load in this request: If this number is
 *                 larger than a batch_size, then the number of records loaded
 *                 will be limited to the next whole number of batch_size (per
 *                 working thread).  The default value is ''.
 *                         <li>
 *                 gpudb::create_table_external_num_tasks_per_rank: Optional:
 *                 number of tasks for reading file per rank. Default will be
 *                 external_file_reader_num_tasks
 *                         <li> gpudb::create_table_external_poll_interval: If
 *                 @a true, the number of seconds between attempts to load
 *                 external files into the table.  If zero, polling will be
 *                 continuous as long as data is found.  If no data is found,
 *                 the interval will steadily increase to a maximum of 60
 *                 seconds.
 *                         <li> gpudb::create_table_external_primary_keys:
 *                 Optional: comma separated list of column names, to set as
 *                 primary keys, when not specified in the type.  The default
 *                 value is ''.
 *                         <li> gpudb::create_table_external_refresh_method:
 *                 Method by which the table can be refreshed from its source
 *                 data.
 *                 <ul>
 *                         <li> gpudb::create_table_external_manual: Refresh
 *                 only occurs when manually requested by invoking the refresh
 *                 action of /alter/table on this table.
 *                         <li> gpudb::create_table_external_on_start: Refresh
 *                 table on database startup and when manually requested by
 *                 invoking the refresh action of /alter/table on this table.
 *                 </ul>
 *                 The default value is gpudb::create_table_external_manual.
 *                         <li>
 *                 gpudb::create_table_external_schema_registry_schema_id
 *                         <li>
 *                 gpudb::create_table_external_schema_registry_schema_name
 *                         <li>
 *                 gpudb::create_table_external_schema_registry_schema_version
 *                         <li> gpudb::create_table_external_shard_keys:
 *                 Optional: comma separated list of column names, to set as
 *                 primary keys, when not specified in the type.  The default
 *                 value is ''.
 *                         <li> gpudb::create_table_external_skip_lines: Skip
 *                 number of lines from begining of file.
 *                         <li> gpudb::create_table_external_subscribe:
 *                 Continuously poll the data source to check for new data and
 *                 load it into the table.
 *                 <ul>
 *                         <li> gpudb::create_table_external_true
 *                         <li> gpudb::create_table_external_false
 *                 </ul>
 *                 The default value is gpudb::create_table_external_false.
 *                         <li> gpudb::create_table_external_table_insert_mode:
 *                 Optional: table_insert_mode. When inserting records from
 *                 multiple files: if table_per_file then insert from each file
 *                 into a new table. Currently supported only for shapefiles.
 *                 <ul>
 *                         <li> gpudb::create_table_external_single
 *                         <li> gpudb::create_table_external_table_per_file
 *                 </ul>
 *                 The default value is gpudb::create_table_external_single.
 *                         <li>
 *                 gpudb::create_table_external_text_comment_string: Specifies
 *                 the character string that should be interpreted as a comment
 *                 line
 *                 prefix in the source data.  All lines in the data starting
 *                 with the provided string are ignored.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '#'.
 *                         <li> gpudb::create_table_external_text_delimiter:
 *                 Specifies the character delimiting field values in the
 *                 source data
 *                 and field names in the header (if present).
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is ','.
 *                         <li>
 *                 gpudb::create_table_external_text_escape_character:
 *                 Specifies the character that is used to escape other
 *                 characters in
 *                 the source data.
 *                 An 'a', 'b', 'f', 'n', 'r', 't', or 'v' preceded by an
 *                 escape character will be interpreted as the
 *                 ASCII bell, backspace, form feed, line feed, carriage
 *                 return, horizontal tab, & vertical tab,
 *                 respectively.  For example, the escape character followed by
 *                 an 'n' will be interpreted as a newline
 *                 within a field value.
 *                 The escape character can also be used to escape the quoting
 *                 character, and will be treated as an
 *                 escape character whether it is within a quoted field value
 *                 or not.
 *                 For @a delimited_text @a file_type only.
 *                         <li> gpudb::create_table_external_text_has_header:
 *                 Indicates whether the source data contains a header row.
 *                 For @a delimited_text @a file_type only.
 *                 <ul>
 *                         <li> gpudb::create_table_external_true
 *                         <li> gpudb::create_table_external_false
 *                 </ul>
 *                 The default value is gpudb::create_table_external_true.
 *                         <li>
 *                 gpudb::create_table_external_text_header_property_delimiter:
 *                 Specifies the delimiter for
 *                 <a href="../../../concepts/types/#column-properties"
 *                 target="_top">column properties</a> in the header row (if
 *                 present).  Cannot be set to same value as @a text_delimiter.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '|'.
 *                         <li> gpudb::create_table_external_text_null_string:
 *                 Specifies the character string that should be interpreted as
 *                 a null
 *                 value in the source data.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '\\N'.
 *                         <li>
 *                 gpudb::create_table_external_text_quote_character: Specifies
 *                 the character that should be interpreted as a field value
 *                 quoting character in the source data.  The character must
 *                 appear at beginning and end of field value
 *                 to take effect.  Delimiters within quoted fields are treated
 *                 as literals and not delimiters.  Within
 *                 a quoted field, two consecutive quote characters will be
 *                 interpreted as a single literal quote
 *                 character, effectively escaping it.  To not have a quote
 *                 character, specify an empty string.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '"'.
 *                         <li>
 *                 gpudb::create_table_external_text_search_columns: Add
 *                 'text_search' property to internally inferenced string
 *                 columns. Comma seperated list of column names or '*' for all
 *                 columns. To add text_search property only to string columns
 *                 of minimum size, set also the option
 *                 'text_search_min_column_length'
 *                         <li>
 *                 gpudb::create_table_external_text_search_min_column_length:
 *                 Set minimum column size. Used only when
 *                 'text_search_columns' has a value.
 *                         <li> gpudb::create_table_external_truncate_strings:
 *                 If set to @a true, truncate string values that are longer
 *                 than the column's type size.
 *                 <ul>
 *                         <li> gpudb::create_table_external_true
 *                         <li> gpudb::create_table_external_false
 *                 </ul>
 *                 The default value is gpudb::create_table_external_false.
 *                         <li> gpudb::create_table_external_truncate_table: If
 *                 set to @a true, truncates the table specified by @a
 *                 tableName prior to loading the file(s).
 *                 <ul>
 *                         <li> gpudb::create_table_external_true
 *                         <li> gpudb::create_table_external_false
 *                 </ul>
 *                 The default value is gpudb::create_table_external_false.
 *                         <li>
 *                 gpudb::create_table_external_type_inference_mode: optimize
 *                 type inference for:
 *                 <ul>
 *                         <li> gpudb::create_table_external_accuracy: Scans
 *                 data to get exactly-typed & sized columns for all data
 *                 scanned.
 *                         <li> gpudb::create_table_external_speed: Scans data
 *                 and picks the widest possible column types so that 'all'
 *                 values will fit with minimum data scanned
 *                 </ul>
 *                 The default value is gpudb::create_table_external_speed.
 *                         <li> gpudb::create_table_external_remote_query:
 *                 Remote SQL query from which data will be sourced
 *                         <li>
 *                 gpudb::create_table_external_remote_query_filter_column:
 *                 Name of column to be used for splitting the query into
 *                 multiple sub-queries using the data distribution of given
 *                 column.  The default value is ''.
 *                         <li>
 *                 gpudb::create_table_external_remote_query_increasing_column:
 *                 Column on subscribed remote query result that will increase
 *                 for new records (e.g., TIMESTAMP).  The default value is ''.
 *                         <li>
 *                 gpudb::create_table_external_remote_query_partition_column:
 *                 Alias name for remote_query_filter_column.  The default
 *                 value is ''.
 *                         <li>
 *                 gpudb::create_table_external_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting into a
 *                 table
 *                 with a <a href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>. If set to
 *                 @a true, any existing table record with primary
 *                 key values that match those of a record being inserted will
 *                 be replaced by that new record (the new
 *                 data will be "upserted"). If set to @a false,
 *                 any existing table record with primary key values that match
 *                 those of a record being inserted will
 *                 remain unchanged, while the new record will be rejected and
 *                 the error handled as determined by
 *                 @a ignore_existing_pk & @a error_handling.  If the
 *                 specified table does not have a primary key, then this
 *                 option has no effect.
 *                 <ul>
 *                         <li> gpudb::create_table_external_true: Upsert new
 *                 records when primary keys match existing records
 *                         <li> gpudb::create_table_external_false: Reject new
 *                 records when primary keys match existing records
 *                 </ul>
 *                 The default value is gpudb::create_table_external_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableExternalResponse& createTableExternal( const std::string& tableName,
                                                  const std::vector<std::string>& filepaths,
                                                  const std::map<std::string, std::map<std::string, std::string> >& modifyColumns,
                                                  const std::map<std::string, std::string>& createTableOptions,
                                                  const std::map<std::string, std::string>& options,
                                                  CreateTableExternalResponse& response_ ) const;

/**
 * Creates a monitor that watches for a single table modification event
 * type (insert, update, or delete) on a particular table (identified by
 * @a tableName) and forwards event notifications to subscribers via ZMQ.
 * After this call completes, subscribe to the returned @a topicId on the
 * ZMQ table monitor port (default 9002). Each time an operation of the given
 * type
 * on the table completes, a multipart message is published for that topic; the
 * first part contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that corresponds to the event and can be decoded
 * using @a typeSchema. The monitor will continue to run (regardless of
 * whether or not there are any subscribers) until deactivated with
 * {@link #clearTableMonitor(const ClearTableMonitorRequest&) const}.
 * <p>
 * For more information on table monitors, see
 * <a href="../../../concepts/table_monitors/" target="_top">Table
 * Monitors</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableMonitorResponse createTableMonitor( const CreateTableMonitorRequest& request_ ) const;

/**
 * Creates a monitor that watches for a single table modification event
 * type (insert, update, or delete) on a particular table (identified by
 * @a tableName) and forwards event notifications to subscribers via ZMQ.
 * After this call completes, subscribe to the returned @a topicId on the
 * ZMQ table monitor port (default 9002). Each time an operation of the given
 * type
 * on the table completes, a multipart message is published for that topic; the
 * first part contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that corresponds to the event and can be decoded
 * using @a typeSchema. The monitor will continue to run (regardless of
 * whether or not there are any subscribers) until deactivated with
 * {@link
 * #clearTableMonitor(const ClearTableMonitorRequest&,ClearTableMonitorResponse&) const}.
 * <p>
 * For more information on table monitors, see
 * <a href="../../../concepts/table_monitors/" target="_top">Table
 * Monitors</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableMonitorResponse& createTableMonitor( const CreateTableMonitorRequest& request_,
                                                CreateTableMonitorResponse& response_ ) const;

/**
 * Creates a monitor that watches for a single table modification event
 * type (insert, update, or delete) on a particular table (identified by
 * @a tableName) and forwards event notifications to subscribers via ZMQ.
 * After this call completes, subscribe to the returned @a topicId on the
 * ZMQ table monitor port (default 9002). Each time an operation of the given
 * type
 * on the table completes, a multipart message is published for that topic; the
 * first part contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that corresponds to the event and can be decoded
 * using @a typeSchema. The monitor will continue to run (regardless of
 * whether or not there are any subscribers) until deactivated with
 * {@link
 * #clearTableMonitor(const std::string&,const std::map<std::string, std::string>&) const}.
 * <p>
 * For more information on table monitors, see
 * <a href="../../../concepts/table_monitors/" target="_top">Table
 * Monitors</a>.
 * 
 * @param tableName  Name of the table to monitor, in [schema_name.]table_name
 *                   format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_table_monitor_event: Type of
 *                 modification event on the target table to be monitored by
 *                 this table monitor.
 *                 <ul>
 *                         <li> gpudb::create_table_monitor_insert: Get
 *                 notifications of new record insertions. The new row images
 *                 are forwarded to the subscribers.
 *                         <li> gpudb::create_table_monitor_update: Get
 *                 notifications of update operations. The modified row count
 *                 information is forwarded to the subscribers.
 *                         <li> gpudb::create_table_monitor_delete: Get
 *                 notifications of delete operations. The deleted row count
 *                 information is forwarded to the subscribers.
 *                 </ul>
 *                 The default value is gpudb::create_table_monitor_insert.
 *                         <li> gpudb::create_table_monitor_monitor_id: ID to
 *                 use for this monitor instead of a randomly generated one
 *                         <li> gpudb::create_table_monitor_datasink_name: Name
 *                 of an existing <a href="../../../concepts/data_sinks/"
 *                 target="_top">data sink</a> to send change data
 *                 notifications to
 *                         <li> gpudb::create_table_monitor_destination:
 *                 Destination for the output data in format
 *                 'destination_type://path[:port]'. Supported destination
 *                 types are 'http', 'https' and 'kafka'.
 *                         <li> gpudb::create_table_monitor_kafka_topic_name:
 *                 Name of the Kafka topic to publish to if @a destination in
 *                 @a options is specified and is a Kafka broker
 *                         <li> gpudb::create_table_monitor_increasing_column:
 *                 Column on subscribed table that will increase for new
 *                 records (e.g., TIMESTAMP).
 *                         <li> gpudb::create_table_monitor_expression: Filter
 *                 expression to limit records for notification
 *                         <li> gpudb::create_table_monitor_refresh_method:
 *                 Method controlling when the table monitor reports changes to
 *                 the @a tableName.
 *                 <ul>
 *                         <li> gpudb::create_table_monitor_on_change: Report
 *                 changes as they occur.
 *                         <li> gpudb::create_table_monitor_periodic: Report
 *                 changes periodically at rate specified by @a refresh_period.
 *                 </ul>
 *                 The default value is gpudb::create_table_monitor_on_change.
 *                         <li> gpudb::create_table_monitor_refresh_period:
 *                 When @a refresh_method is @a periodic, specifies the period
 *                 in seconds at which changes are reported.
 *                         <li> gpudb::create_table_monitor_refresh_start_time:
 *                 When @a refresh_method is @a periodic, specifies the first
 *                 time at which changes are reported.  Value is a datetime
 *                 string with format 'YYYY-MM-DD HH:MM:SS'.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableMonitorResponse createTableMonitor( const std::string& tableName,
                                               const std::map<std::string, std::string>& options ) const;

/**
 * Creates a monitor that watches for a single table modification event
 * type (insert, update, or delete) on a particular table (identified by
 * @a tableName) and forwards event notifications to subscribers via ZMQ.
 * After this call completes, subscribe to the returned @a topicId on the
 * ZMQ table monitor port (default 9002). Each time an operation of the given
 * type
 * on the table completes, a multipart message is published for that topic; the
 * first part contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that corresponds to the event and can be decoded
 * using @a typeSchema. The monitor will continue to run (regardless of
 * whether or not there are any subscribers) until deactivated with
 * {@link
 * #clearTableMonitor(const std::string&,const std::map<std::string, std::string>&,ClearTableMonitorResponse&) const}.
 * <p>
 * For more information on table monitors, see
 * <a href="../../../concepts/table_monitors/" target="_top">Table
 * Monitors</a>.
 * 
 * @param tableName  Name of the table to monitor, in [schema_name.]table_name
 *                   format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_table_monitor_event: Type of
 *                 modification event on the target table to be monitored by
 *                 this table monitor.
 *                 <ul>
 *                         <li> gpudb::create_table_monitor_insert: Get
 *                 notifications of new record insertions. The new row images
 *                 are forwarded to the subscribers.
 *                         <li> gpudb::create_table_monitor_update: Get
 *                 notifications of update operations. The modified row count
 *                 information is forwarded to the subscribers.
 *                         <li> gpudb::create_table_monitor_delete: Get
 *                 notifications of delete operations. The deleted row count
 *                 information is forwarded to the subscribers.
 *                 </ul>
 *                 The default value is gpudb::create_table_monitor_insert.
 *                         <li> gpudb::create_table_monitor_monitor_id: ID to
 *                 use for this monitor instead of a randomly generated one
 *                         <li> gpudb::create_table_monitor_datasink_name: Name
 *                 of an existing <a href="../../../concepts/data_sinks/"
 *                 target="_top">data sink</a> to send change data
 *                 notifications to
 *                         <li> gpudb::create_table_monitor_destination:
 *                 Destination for the output data in format
 *                 'destination_type://path[:port]'. Supported destination
 *                 types are 'http', 'https' and 'kafka'.
 *                         <li> gpudb::create_table_monitor_kafka_topic_name:
 *                 Name of the Kafka topic to publish to if @a destination in
 *                 @a options is specified and is a Kafka broker
 *                         <li> gpudb::create_table_monitor_increasing_column:
 *                 Column on subscribed table that will increase for new
 *                 records (e.g., TIMESTAMP).
 *                         <li> gpudb::create_table_monitor_expression: Filter
 *                 expression to limit records for notification
 *                         <li> gpudb::create_table_monitor_refresh_method:
 *                 Method controlling when the table monitor reports changes to
 *                 the @a tableName.
 *                 <ul>
 *                         <li> gpudb::create_table_monitor_on_change: Report
 *                 changes as they occur.
 *                         <li> gpudb::create_table_monitor_periodic: Report
 *                 changes periodically at rate specified by @a refresh_period.
 *                 </ul>
 *                 The default value is gpudb::create_table_monitor_on_change.
 *                         <li> gpudb::create_table_monitor_refresh_period:
 *                 When @a refresh_method is @a periodic, specifies the period
 *                 in seconds at which changes are reported.
 *                         <li> gpudb::create_table_monitor_refresh_start_time:
 *                 When @a refresh_method is @a periodic, specifies the first
 *                 time at which changes are reported.  Value is a datetime
 *                 string with format 'YYYY-MM-DD HH:MM:SS'.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableMonitorResponse& createTableMonitor( const std::string& tableName,
                                                const std::map<std::string, std::string>& options,
                                                CreateTableMonitorResponse& response_ ) const;

/**
 * Sets up an area trigger mechanism for two column_names for one or
 * more tables. (This function is essentially the two-dimensional version of
 * {@link
 * #createTriggerByRange(const CreateTriggerByRangeRequest&) const}.) Once
 * the trigger has been activated, any
 * record added to the listed tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the
 * chosen columns' values falling within the specified region will trip the
 * trigger. All such records will be queued at the trigger port (by default
 * '9001'
 * but able to be retrieved via {@link
 * #showSystemStatus(const ShowSystemStatusRequest&) const}) for any
 * listening
 * client to collect. Active triggers can be cancelled by using the
 * {@link #clearTrigger(const ClearTriggerRequest&) const} endpoint or by
 * clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure
 * of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByAreaResponse createTriggerByArea( const CreateTriggerByAreaRequest& request_ ) const;

/**
 * Sets up an area trigger mechanism for two column_names for one or
 * more tables. (This function is essentially the two-dimensional version of
 * {@link
 * #createTriggerByRange(const CreateTriggerByRangeRequest&,CreateTriggerByRangeResponse&) const}.)
 * Once the trigger has been activated, any
 * record added to the listed tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&,InsertRecordsResponse&) const}
 * with the
 * chosen columns' values falling within the specified region will trip the
 * trigger. All such records will be queued at the trigger port (by default
 * '9001'
 * but able to be retrieved via {@link
 * #showSystemStatus(const ShowSystemStatusRequest&,ShowSystemStatusResponse&) const})
 * for any listening
 * client to collect. Active triggers can be cancelled by using the
 * {@link
 * #clearTrigger(const ClearTriggerRequest&,ClearTriggerResponse&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure
 * of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByAreaResponse& createTriggerByArea( const CreateTriggerByAreaRequest& request_,
                                                  CreateTriggerByAreaResponse& response_ ) const;

/**
 * Sets up an area trigger mechanism for two column_names for one or
 * more tables. (This function is essentially the two-dimensional version of
 * {@link
 * #createTriggerByRange(const std::string&,const std::vector<std::string>&,const std::string&,const double,const double,const std::map<std::string, std::string>&) const}.)
 * Once the trigger has been activated, any
 * record added to the listed tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the
 * chosen columns' values falling within the specified region will trip the
 * trigger. All such records will be queued at the trigger port (by default
 * '9001'
 * but able to be retrieved via {@link
 * #showSystemStatus(const std::map<std::string, std::string>&) const})
 * for any listening
 * client to collect. Active triggers can be cancelled by using the
 * {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure
 * of the trigger activation.
 * 
 * @param requestId  User-created ID for the trigger. The ID can be
 *                   alphanumeric, contain symbols, and must contain at least
 *                   one character.
 * @param tableNames  Names of the tables on which the trigger will be
 *                    activated and maintained, each in
 *                    [schema_name.]table_name format, using standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.
 * @param xColumnName  Name of a numeric column on which the trigger is
 *                     activated. Usually 'x' for geospatial data points.
 * @param xVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 x-coordinates of a geospatial region.
 * @param yColumnName  Name of a second numeric column on which the trigger is
 *                     activated. Usually 'y' for geospatial data points.
 * @param yVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 y-coordinates of a geospatial region. Must be the same
 *                 length as xvals.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByAreaResponse createTriggerByArea( const std::string& requestId,
                                                 const std::vector<std::string>& tableNames,
                                                 const std::string& xColumnName,
                                                 const std::vector<double>& xVector,
                                                 const std::string& yColumnName,
                                                 const std::vector<double>& yVector,
                                                 const std::map<std::string, std::string>& options ) const;

/**
 * Sets up an area trigger mechanism for two column_names for one or
 * more tables. (This function is essentially the two-dimensional version of
 * {@link
 * #createTriggerByRange(const std::string&,const std::vector<std::string>&,const std::string&,const double,const double,const std::map<std::string, std::string>&,CreateTriggerByRangeResponse&) const}.)
 * Once the trigger has been activated, any
 * record added to the listed tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the
 * chosen columns' values falling within the specified region will trip the
 * trigger. All such records will be queued at the trigger port (by default
 * '9001'
 * but able to be retrieved via {@link
 * #showSystemStatus(const std::map<std::string, std::string>&,ShowSystemStatusResponse&) const})
 * for any listening
 * client to collect. Active triggers can be cancelled by using the
 * {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&,ClearTriggerResponse&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure
 * of the trigger activation.
 * 
 * @param requestId  User-created ID for the trigger. The ID can be
 *                   alphanumeric, contain symbols, and must contain at least
 *                   one character.
 * @param tableNames  Names of the tables on which the trigger will be
 *                    activated and maintained, each in
 *                    [schema_name.]table_name format, using standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.
 * @param xColumnName  Name of a numeric column on which the trigger is
 *                     activated. Usually 'x' for geospatial data points.
 * @param xVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 x-coordinates of a geospatial region.
 * @param yColumnName  Name of a second numeric column on which the trigger is
 *                     activated. Usually 'y' for geospatial data points.
 * @param yVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 y-coordinates of a geospatial region. Must be the same
 *                 length as xvals.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByAreaResponse& createTriggerByArea( const std::string& requestId,
                                                  const std::vector<std::string>& tableNames,
                                                  const std::string& xColumnName,
                                                  const std::vector<double>& xVector,
                                                  const std::string& yColumnName,
                                                  const std::vector<double>& yVector,
                                                  const std::map<std::string, std::string>& options,
                                                  CreateTriggerByAreaResponse& response_ ) const;

/**
 * Sets up a simple range trigger for a column_name for one or more
 * tables. Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * column_name's value
 * falling within the specified range will trip the trigger. All such records
 * will
 * be queued at the trigger port (by default '9001' but able to be retrieved
 * via
 * {@link #showSystemStatus(const ShowSystemStatusRequest&) const}) for any
 * listening client to collect. Active
 * triggers can be cancelled by using the {@link
 * #clearTrigger(const ClearTriggerRequest&) const} endpoint or by
 * clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure
 * of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByRangeResponse createTriggerByRange( const CreateTriggerByRangeRequest& request_ ) const;

/**
 * Sets up a simple range trigger for a column_name for one or more
 * tables. Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&,InsertRecordsResponse&) const}
 * with the chosen column_name's value
 * falling within the specified range will trip the trigger. All such records
 * will
 * be queued at the trigger port (by default '9001' but able to be retrieved
 * via
 * {@link
 * #showSystemStatus(const ShowSystemStatusRequest&,ShowSystemStatusResponse&) const})
 * for any listening client to collect. Active
 * triggers can be cancelled by using the {@link
 * #clearTrigger(const ClearTriggerRequest&,ClearTriggerResponse&) const}
 * endpoint or by
 * clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure
 * of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByRangeResponse& createTriggerByRange( const CreateTriggerByRangeRequest& request_,
                                                    CreateTriggerByRangeResponse& response_ ) const;

/**
 * Sets up a simple range trigger for a column_name for one or more
 * tables. Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * column_name's value
 * falling within the specified range will trip the trigger. All such records
 * will
 * be queued at the trigger port (by default '9001' but able to be retrieved
 * via
 * {@link
 * #showSystemStatus(const std::map<std::string, std::string>&) const})
 * for any listening client to collect. Active
 * triggers can be cancelled by using the {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&) const}
 * endpoint or by
 * clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure
 * of the trigger activation.
 * 
 * @param requestId  User-created ID for the trigger. The ID can be
 *                   alphanumeric, contain symbols, and must contain at least
 *                   one character.
 * @param tableNames  Tables on which the trigger will be active, each in
 *                    [schema_name.]table_name format, using standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.
 * @param columnName  Name of a numeric column_name on which the trigger is
 *                    activated.
 * @param min  The lower bound (inclusive) for the trigger range.
 * @param max  The upper bound (inclusive) for the trigger range.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByRangeResponse createTriggerByRange( const std::string& requestId,
                                                   const std::vector<std::string>& tableNames,
                                                   const std::string& columnName,
                                                   const double min,
                                                   const double max,
                                                   const std::map<std::string, std::string>& options ) const;

/**
 * Sets up a simple range trigger for a column_name for one or more
 * tables. Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * column_name's value
 * falling within the specified range will trip the trigger. All such records
 * will
 * be queued at the trigger port (by default '9001' but able to be retrieved
 * via
 * {@link
 * #showSystemStatus(const std::map<std::string, std::string>&,ShowSystemStatusResponse&) const})
 * for any listening client to collect. Active
 * triggers can be cancelled by using the {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&,ClearTriggerResponse&) const}
 * endpoint or by
 * clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure
 * of the trigger activation.
 * 
 * @param requestId  User-created ID for the trigger. The ID can be
 *                   alphanumeric, contain symbols, and must contain at least
 *                   one character.
 * @param tableNames  Tables on which the trigger will be active, each in
 *                    [schema_name.]table_name format, using standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.
 * @param columnName  Name of a numeric column_name on which the trigger is
 *                    activated.
 * @param min  The lower bound (inclusive) for the trigger range.
 * @param max  The upper bound (inclusive) for the trigger range.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByRangeResponse& createTriggerByRange( const std::string& requestId,
                                                    const std::vector<std::string>& tableNames,
                                                    const std::string& columnName,
                                                    const double min,
                                                    const double max,
                                                    const std::map<std::string, std::string>& options,
                                                    CreateTriggerByRangeResponse& response_ ) const;

/**
 * Creates a new type describing the layout of a table. The type definition is
 * a JSON string describing the fields (i.e. columns) of the type. Each field
 * consists of a name and a data type. Supported data types are: double, float,
 * int, long, string, and bytes. In addition, one or more properties can be
 * specified for each column which customize the memory usage and query
 * availability of that column.  Note that some properties are mutually
 * exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * A single <a href="../../../concepts/tables/#primary-keys"
 * target="_top">primary key</a> and/or single <a
 * href="../../../concepts/tables/#shard-keys" target="_top">shard key</a> can
 * be set across one or more columns. If a primary key is specified, then a
 * uniqueness constraint is enforced, in that only a single object can exist
 * with a given primary key column value (or set of values for the key columns,
 * if using a composite primary key). When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const inserting} data
 * into a table with a primary key, depending on the parameters in the request,
 * incoming objects with primary key values that match existing objects will
 * either overwrite (i.e. update) the existing object or will be skipped and
 * not added into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTypeResponse createType( const CreateTypeRequest& request_ ) const;

/**
 * Creates a new type describing the layout of a table. The type definition is
 * a JSON string describing the fields (i.e. columns) of the type. Each field
 * consists of a name and a data type. Supported data types are: double, float,
 * int, long, string, and bytes. In addition, one or more properties can be
 * specified for each column which customize the memory usage and query
 * availability of that column.  Note that some properties are mutually
 * exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * A single <a href="../../../concepts/tables/#primary-keys"
 * target="_top">primary key</a> and/or single <a
 * href="../../../concepts/tables/#shard-keys" target="_top">shard key</a> can
 * be set across one or more columns. If a primary key is specified, then a
 * uniqueness constraint is enforced, in that only a single object can exist
 * with a given primary key column value (or set of values for the key columns,
 * if using a composite primary key). When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&,InsertRecordsResponse&) const
 * inserting} data into a table with a primary key, depending on the parameters
 * in the request, incoming objects with primary key values that match existing
 * objects will either overwrite (i.e. update) the existing object or will be
 * skipped and not added into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTypeResponse& createType( const CreateTypeRequest& request_,
                                CreateTypeResponse& response_ ) const;

/**
 * Creates a new type describing the layout of a table. The type definition is
 * a JSON string describing the fields (i.e. columns) of the type. Each field
 * consists of a name and a data type. Supported data types are: double, float,
 * int, long, string, and bytes. In addition, one or more properties can be
 * specified for each column which customize the memory usage and query
 * availability of that column.  Note that some properties are mutually
 * exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * A single <a href="../../../concepts/tables/#primary-keys"
 * target="_top">primary key</a> and/or single <a
 * href="../../../concepts/tables/#shard-keys" target="_top">shard key</a> can
 * be set across one or more columns. If a primary key is specified, then a
 * uniqueness constraint is enforced, in that only a single object can exist
 * with a given primary key column value (or set of values for the key columns,
 * if using a composite primary key). When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const inserting} data
 * into a table with a primary key, depending on the parameters in the request,
 * incoming objects with primary key values that match existing objects will
 * either overwrite (i.e. update) the existing object or will be skipped and
 * not added into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param typeDefinition  a JSON string describing the columns of the type to
 *                        be registered.
 * @param label  A user-defined description string which can be used to
 *               differentiate between tables and types with otherwise
 *               identical schemas.
 * @param properties  Each key-value pair specifies the properties to use for a
 *                    given column where the key is the column name.  All keys
 *                    used must be relevant column names for the given table.
 *                    Specifying any property overrides the default properties
 *                    for that column (which is based on the column's data
 *                    type).
 *                    <ul>
 *                            <li> gpudb::create_type_data: Default property
 *                    for all numeric and string type columns; makes the column
 *                    available for GPU queries.
 *                            <li> gpudb::create_type_text_search: Valid only
 *                    for select 'string' columns. Enables full text
 *                    search--see <a href="../../../concepts/full_text_search/"
 *                    target="_top">Full Text Search</a> for details and
 *                    applicable string column types. Can be set independently
 *                    of @a data and @a store_only.
 *                            <li> gpudb::create_type_store_only: Persist the
 *                    column value but do not make it available to queries
 *                    (e.g. /filter)-i.e. it is mutually exclusive to the @a
 *                    data property. Any 'bytes' type column must have a @a
 *                    store_only property. This property reduces system memory
 *                    usage.
 *                            <li> gpudb::create_type_disk_optimized: Works in
 *                    conjunction with the @a data property for string columns.
 *                    This property reduces system disk usage by disabling
 *                    reverse string lookups. Queries like /filter,
 *                    /filter/bylist, and /filter/byvalue work as usual but
 *                    /aggregate/unique and /aggregate/groupby are not allowed
 *                    on columns with this property.
 *                            <li> gpudb::create_type_timestamp: Valid only for
 *                    'long' columns. Indicates that this field represents a
 *                    timestamp and will be provided in milliseconds since the
 *                    Unix epoch: 00:00:00 Jan 1 1970.  Dates represented by a
 *                    timestamp must fall between the year 1000 and the year
 *                    2900.
 *                            <li> gpudb::create_type_ulong: Valid only for
 *                    'string' columns.  It represents an unsigned long integer
 *                    data type. The string can only be interpreted as an
 *                    unsigned long data type with minimum value of zero, and
 *                    maximum value of 18446744073709551615.
 *                            <li> gpudb::create_type_uuid: Valid only for
 *                    'string' columns.  It represents an uuid data type.
 *                    Internally, it is stored as a 128-bit integer.
 *                            <li> gpudb::create_type_decimal: Valid only for
 *                    'string' columns.  It represents a SQL type NUMERIC(19,
 *                    4) data type.  There can be up to 15 digits before the
 *                    decimal point and up to four digits in the fractional
 *                    part.  The value can be positive or negative (indicated
 *                    by a minus sign at the beginning).  This property is
 *                    mutually exclusive with the @a text_search property.
 *                            <li> gpudb::create_type_date: Valid only for
 *                    'string' columns.  Indicates that this field represents a
 *                    date and will be provided in the format 'YYYY-MM-DD'.
 *                    The allowable range is 1000-01-01 through 2900-01-01.
 *                    This property is mutually exclusive with the @a
 *                    text_search property.
 *                            <li> gpudb::create_type_time: Valid only for
 *                    'string' columns.  Indicates that this field represents a
 *                    time-of-day and will be provided in the format
 *                    'HH:MM:SS.mmm'.  The allowable range is 00:00:00.000
 *                    through 23:59:59.999.  This property is mutually
 *                    exclusive with the @a text_search property.
 *                            <li> gpudb::create_type_datetime: Valid only for
 *                    'string' columns.  Indicates that this field represents a
 *                    datetime and will be provided in the format 'YYYY-MM-DD
 *                    HH:MM:SS.mmm'.  The allowable range is 1000-01-01
 *                    00:00:00.000 through 2900-01-01 23:59:59.999.  This
 *                    property is mutually exclusive with the @a text_search
 *                    property.
 *                            <li> gpudb::create_type_char1: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 1 character.
 *                            <li> gpudb::create_type_char2: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 2 characters.
 *                            <li> gpudb::create_type_char4: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 4 characters.
 *                            <li> gpudb::create_type_char8: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 8 characters.
 *                            <li> gpudb::create_type_char16: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 16 characters.
 *                            <li> gpudb::create_type_char32: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 32 characters.
 *                            <li> gpudb::create_type_char64: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 64 characters.
 *                            <li> gpudb::create_type_char128: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 128 characters.
 *                            <li> gpudb::create_type_char256: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 256 characters.
 *                            <li> gpudb::create_type_boolean: This property
 *                    provides optimized memory and query performance for int
 *                    columns. Ints with this property must be between 0 and
 *                    1(inclusive)
 *                            <li> gpudb::create_type_int8: This property
 *                    provides optimized memory and query performance for int
 *                    columns. Ints with this property must be between -128 and
 *                    +127 (inclusive)
 *                            <li> gpudb::create_type_int16: This property
 *                    provides optimized memory and query performance for int
 *                    columns. Ints with this property must be between -32768
 *                    and +32767 (inclusive)
 *                            <li> gpudb::create_type_ipv4: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns representing IPv4 addresses (i.e.
 *                    192.168.1.1). Strings with this property must be of the
 *                    form: A.B.C.D where A, B, C and D are in the range of
 *                    0-255.
 *                            <li> gpudb::create_type_wkt: Valid only for
 *                    'string' and 'bytes' columns. Indicates that this field
 *                    contains geospatial geometry objects in Well-Known Text
 *                    (WKT) or Well-Known Binary (WKB) format.
 *                            <li> gpudb::create_type_primary_key: This
 *                    property indicates that this column will be part of (or
 *                    the entire) <a
 *                    href="../../../concepts/tables/#primary-keys"
 *                    target="_top">primary key</a>.
 *                            <li> gpudb::create_type_shard_key: This property
 *                    indicates that this column will be part of (or the
 *                    entire) <a href="../../../concepts/tables/#shard-keys"
 *                    target="_top">shard key</a>.
 *                            <li> gpudb::create_type_nullable: This property
 *                    indicates that this column is nullable.  However, setting
 *                    this property is insufficient for making the column
 *                    nullable.  The user must declare the type of the column
 *                    as a union between its regular type and 'null' in the
 *                    avro schema for the record type in @a typeDefinition.
 *                    For example, if a column is of type integer and is
 *                    nullable, then the entry for the column in the avro
 *                    schema must be: ['int', 'null'].
 *                    The C++, C#, Java, and Python APIs have built-in
 *                    convenience for bypassing setting the avro schema by
 *                    hand.  For those languages, one can use this property as
 *                    usual and not have to worry about the avro schema for the
 *                    record.
 *                            <li> gpudb::create_type_dict: This property
 *                    indicates that this column should be <a
 *                    href="../../../concepts/dictionary_encoding/"
 *                    target="_top">dictionary encoded</a>. It can only be used
 *                    in conjunction with restricted string (charN), int, long
 *                    or date columns. Dictionary encoding is best for columns
 *                    where the cardinality (the number of unique values) is
 *                    expected to be low. This property can save a large amount
 *                    of memory.
 *                            <li> gpudb::create_type_init_with_now: For
 *                    'date', 'time', 'datetime', or 'timestamp' column types,
 *                    replace empty strings and invalid timestamps with 'NOW()'
 *                    upon insert.
 *                            <li> gpudb::create_type_init_with_uuid: For
 *                    'uuid' type, replace empty strings and invalid UUID
 *                    values with randomly-generated UUIDs upon insert.
 *                    </ul>
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTypeResponse createType( const std::string& typeDefinition,
                               const std::string& label,
                               const std::map<std::string, std::vector<std::string> >& properties,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Creates a new type describing the layout of a table. The type definition is
 * a JSON string describing the fields (i.e. columns) of the type. Each field
 * consists of a name and a data type. Supported data types are: double, float,
 * int, long, string, and bytes. In addition, one or more properties can be
 * specified for each column which customize the memory usage and query
 * availability of that column.  Note that some properties are mutually
 * exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * A single <a href="../../../concepts/tables/#primary-keys"
 * target="_top">primary key</a> and/or single <a
 * href="../../../concepts/tables/#shard-keys" target="_top">shard key</a> can
 * be set across one or more columns. If a primary key is specified, then a
 * uniqueness constraint is enforced, in that only a single object can exist
 * with a given primary key column value (or set of values for the key columns,
 * if using a composite primary key). When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const inserting} data
 * into a table with a primary key, depending on the parameters in the request,
 * incoming objects with primary key values that match existing objects will
 * either overwrite (i.e. update) the existing object or will be skipped and
 * not added into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param typeDefinition  a JSON string describing the columns of the type to
 *                        be registered.
 * @param label  A user-defined description string which can be used to
 *               differentiate between tables and types with otherwise
 *               identical schemas.
 * @param properties  Each key-value pair specifies the properties to use for a
 *                    given column where the key is the column name.  All keys
 *                    used must be relevant column names for the given table.
 *                    Specifying any property overrides the default properties
 *                    for that column (which is based on the column's data
 *                    type).
 *                    <ul>
 *                            <li> gpudb::create_type_data: Default property
 *                    for all numeric and string type columns; makes the column
 *                    available for GPU queries.
 *                            <li> gpudb::create_type_text_search: Valid only
 *                    for select 'string' columns. Enables full text
 *                    search--see <a href="../../../concepts/full_text_search/"
 *                    target="_top">Full Text Search</a> for details and
 *                    applicable string column types. Can be set independently
 *                    of @a data and @a store_only.
 *                            <li> gpudb::create_type_store_only: Persist the
 *                    column value but do not make it available to queries
 *                    (e.g. /filter)-i.e. it is mutually exclusive to the @a
 *                    data property. Any 'bytes' type column must have a @a
 *                    store_only property. This property reduces system memory
 *                    usage.
 *                            <li> gpudb::create_type_disk_optimized: Works in
 *                    conjunction with the @a data property for string columns.
 *                    This property reduces system disk usage by disabling
 *                    reverse string lookups. Queries like /filter,
 *                    /filter/bylist, and /filter/byvalue work as usual but
 *                    /aggregate/unique and /aggregate/groupby are not allowed
 *                    on columns with this property.
 *                            <li> gpudb::create_type_timestamp: Valid only for
 *                    'long' columns. Indicates that this field represents a
 *                    timestamp and will be provided in milliseconds since the
 *                    Unix epoch: 00:00:00 Jan 1 1970.  Dates represented by a
 *                    timestamp must fall between the year 1000 and the year
 *                    2900.
 *                            <li> gpudb::create_type_ulong: Valid only for
 *                    'string' columns.  It represents an unsigned long integer
 *                    data type. The string can only be interpreted as an
 *                    unsigned long data type with minimum value of zero, and
 *                    maximum value of 18446744073709551615.
 *                            <li> gpudb::create_type_uuid: Valid only for
 *                    'string' columns.  It represents an uuid data type.
 *                    Internally, it is stored as a 128-bit integer.
 *                            <li> gpudb::create_type_decimal: Valid only for
 *                    'string' columns.  It represents a SQL type NUMERIC(19,
 *                    4) data type.  There can be up to 15 digits before the
 *                    decimal point and up to four digits in the fractional
 *                    part.  The value can be positive or negative (indicated
 *                    by a minus sign at the beginning).  This property is
 *                    mutually exclusive with the @a text_search property.
 *                            <li> gpudb::create_type_date: Valid only for
 *                    'string' columns.  Indicates that this field represents a
 *                    date and will be provided in the format 'YYYY-MM-DD'.
 *                    The allowable range is 1000-01-01 through 2900-01-01.
 *                    This property is mutually exclusive with the @a
 *                    text_search property.
 *                            <li> gpudb::create_type_time: Valid only for
 *                    'string' columns.  Indicates that this field represents a
 *                    time-of-day and will be provided in the format
 *                    'HH:MM:SS.mmm'.  The allowable range is 00:00:00.000
 *                    through 23:59:59.999.  This property is mutually
 *                    exclusive with the @a text_search property.
 *                            <li> gpudb::create_type_datetime: Valid only for
 *                    'string' columns.  Indicates that this field represents a
 *                    datetime and will be provided in the format 'YYYY-MM-DD
 *                    HH:MM:SS.mmm'.  The allowable range is 1000-01-01
 *                    00:00:00.000 through 2900-01-01 23:59:59.999.  This
 *                    property is mutually exclusive with the @a text_search
 *                    property.
 *                            <li> gpudb::create_type_char1: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 1 character.
 *                            <li> gpudb::create_type_char2: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 2 characters.
 *                            <li> gpudb::create_type_char4: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 4 characters.
 *                            <li> gpudb::create_type_char8: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 8 characters.
 *                            <li> gpudb::create_type_char16: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 16 characters.
 *                            <li> gpudb::create_type_char32: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 32 characters.
 *                            <li> gpudb::create_type_char64: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 64 characters.
 *                            <li> gpudb::create_type_char128: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 128 characters.
 *                            <li> gpudb::create_type_char256: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 256 characters.
 *                            <li> gpudb::create_type_boolean: This property
 *                    provides optimized memory and query performance for int
 *                    columns. Ints with this property must be between 0 and
 *                    1(inclusive)
 *                            <li> gpudb::create_type_int8: This property
 *                    provides optimized memory and query performance for int
 *                    columns. Ints with this property must be between -128 and
 *                    +127 (inclusive)
 *                            <li> gpudb::create_type_int16: This property
 *                    provides optimized memory and query performance for int
 *                    columns. Ints with this property must be between -32768
 *                    and +32767 (inclusive)
 *                            <li> gpudb::create_type_ipv4: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns representing IPv4 addresses (i.e.
 *                    192.168.1.1). Strings with this property must be of the
 *                    form: A.B.C.D where A, B, C and D are in the range of
 *                    0-255.
 *                            <li> gpudb::create_type_wkt: Valid only for
 *                    'string' and 'bytes' columns. Indicates that this field
 *                    contains geospatial geometry objects in Well-Known Text
 *                    (WKT) or Well-Known Binary (WKB) format.
 *                            <li> gpudb::create_type_primary_key: This
 *                    property indicates that this column will be part of (or
 *                    the entire) <a
 *                    href="../../../concepts/tables/#primary-keys"
 *                    target="_top">primary key</a>.
 *                            <li> gpudb::create_type_shard_key: This property
 *                    indicates that this column will be part of (or the
 *                    entire) <a href="../../../concepts/tables/#shard-keys"
 *                    target="_top">shard key</a>.
 *                            <li> gpudb::create_type_nullable: This property
 *                    indicates that this column is nullable.  However, setting
 *                    this property is insufficient for making the column
 *                    nullable.  The user must declare the type of the column
 *                    as a union between its regular type and 'null' in the
 *                    avro schema for the record type in @a typeDefinition.
 *                    For example, if a column is of type integer and is
 *                    nullable, then the entry for the column in the avro
 *                    schema must be: ['int', 'null'].
 *                    The C++, C#, Java, and Python APIs have built-in
 *                    convenience for bypassing setting the avro schema by
 *                    hand.  For those languages, one can use this property as
 *                    usual and not have to worry about the avro schema for the
 *                    record.
 *                            <li> gpudb::create_type_dict: This property
 *                    indicates that this column should be <a
 *                    href="../../../concepts/dictionary_encoding/"
 *                    target="_top">dictionary encoded</a>. It can only be used
 *                    in conjunction with restricted string (charN), int, long
 *                    or date columns. Dictionary encoding is best for columns
 *                    where the cardinality (the number of unique values) is
 *                    expected to be low. This property can save a large amount
 *                    of memory.
 *                            <li> gpudb::create_type_init_with_now: For
 *                    'date', 'time', 'datetime', or 'timestamp' column types,
 *                    replace empty strings and invalid timestamps with 'NOW()'
 *                    upon insert.
 *                            <li> gpudb::create_type_init_with_uuid: For
 *                    'uuid' type, replace empty strings and invalid UUID
 *                    values with randomly-generated UUIDs upon insert.
 *                    </ul>
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTypeResponse& createType( const std::string& typeDefinition,
                                const std::string& label,
                                const std::map<std::string, std::vector<std::string> >& properties,
                                const std::map<std::string, std::string>& options,
                                CreateTypeResponse& response_ ) const;

/**
 * Merges data from one or more tables with comparable data types into a new
 * table.
 * <p>
 * The following merges are supported:
 * <p>
 * UNION (DISTINCT/ALL) - For data set union details and examples, see <a
 * href="../../../concepts/unions/" target="_top">Union</a>.  For limitations,
 * see <a href="../../../concepts/unions/#limitations-and-cautions"
 * target="_top">Union Limitations and Cautions</a>.
 * <p>
 * INTERSECT (DISTINCT/ALL) - For data set intersection details and examples,
 * see <a href="../../../concepts/intersect/" target="_top">Intersect</a>.  For
 * limitations, see <a href="../../../concepts/intersect/#limitations"
 * target="_top">Intersect Limitations</a>.
 * <p>
 * EXCEPT (DISTINCT/ALL) - For data set subtraction details and examples, see
 * <a href="../../../concepts/except/" target="_top">Except</a>.  For
 * limitations, see <a href="../../../concepts/except/#limitations"
 * target="_top">Except Limitations</a>.
 * <p>
 * MERGE VIEWS - For a given set of <a href="../../../concepts/filtered_views/"
 * target="_top">filtered views</a> on a single table, creates a single
 * filtered view containing all of the unique records across all of the given
 * filtered data sets.
 * <p>
 * Non-charN 'string' and 'bytes' column types cannot be merged, nor can
 * columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUnionResponse createUnion( const CreateUnionRequest& request_ ) const;

/**
 * Merges data from one or more tables with comparable data types into a new
 * table.
 * <p>
 * The following merges are supported:
 * <p>
 * UNION (DISTINCT/ALL) - For data set union details and examples, see <a
 * href="../../../concepts/unions/" target="_top">Union</a>.  For limitations,
 * see <a href="../../../concepts/unions/#limitations-and-cautions"
 * target="_top">Union Limitations and Cautions</a>.
 * <p>
 * INTERSECT (DISTINCT/ALL) - For data set intersection details and examples,
 * see <a href="../../../concepts/intersect/" target="_top">Intersect</a>.  For
 * limitations, see <a href="../../../concepts/intersect/#limitations"
 * target="_top">Intersect Limitations</a>.
 * <p>
 * EXCEPT (DISTINCT/ALL) - For data set subtraction details and examples, see
 * <a href="../../../concepts/except/" target="_top">Except</a>.  For
 * limitations, see <a href="../../../concepts/except/#limitations"
 * target="_top">Except Limitations</a>.
 * <p>
 * MERGE VIEWS - For a given set of <a href="../../../concepts/filtered_views/"
 * target="_top">filtered views</a> on a single table, creates a single
 * filtered view containing all of the unique records across all of the given
 * filtered data sets.
 * <p>
 * Non-charN 'string' and 'bytes' column types cannot be merged, nor can
 * columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUnionResponse& createUnion( const CreateUnionRequest& request_,
                                  CreateUnionResponse& response_ ) const;

/**
 * Merges data from one or more tables with comparable data types into a new
 * table.
 * <p>
 * The following merges are supported:
 * <p>
 * UNION (DISTINCT/ALL) - For data set union details and examples, see <a
 * href="../../../concepts/unions/" target="_top">Union</a>.  For limitations,
 * see <a href="../../../concepts/unions/#limitations-and-cautions"
 * target="_top">Union Limitations and Cautions</a>.
 * <p>
 * INTERSECT (DISTINCT/ALL) - For data set intersection details and examples,
 * see <a href="../../../concepts/intersect/" target="_top">Intersect</a>.  For
 * limitations, see <a href="../../../concepts/intersect/#limitations"
 * target="_top">Intersect Limitations</a>.
 * <p>
 * EXCEPT (DISTINCT/ALL) - For data set subtraction details and examples, see
 * <a href="../../../concepts/except/" target="_top">Except</a>.  For
 * limitations, see <a href="../../../concepts/except/#limitations"
 * target="_top">Except Limitations</a>.
 * <p>
 * MERGE VIEWS - For a given set of <a href="../../../concepts/filtered_views/"
 * target="_top">filtered views</a> on a single table, creates a single
 * filtered view containing all of the unique records across all of the given
 * filtered data sets.
 * <p>
 * Non-charN 'string' and 'bytes' column types cannot be merged, nor can
 * columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a>.
 * 
 * @param tableName  Name of the table to be created, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a> and meeting <a
 *                   href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>.
 * @param tableNames  The list of table names to merge, in
 *                    [schema_name.]table_name format, using standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.  Must contain
 *                    the names of one or more existing tables.
 * @param inputColumnNames  The list of columns from each of the corresponding
 *                          input tables.
 * @param outputColumnNames  The list of names of the columns to be stored in
 *                           the output table.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_union_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a tableName. If @a
 *                 persist is @a false (or unspecified), then this is always
 *                 allowed even if the caller does not have permission to
 *                 create tables. The generated name is returned in @a
 *                 qualified_table_name.
 *                 <ul>
 *                         <li> gpudb::create_union_true
 *                         <li> gpudb::create_union_false
 *                 </ul>
 *                 The default value is gpudb::create_union_false.
 *                         <li> gpudb::create_union_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 projection as part of @a tableName and use /create/schema to
 *                 create the schema if non-existent]  Name of the schema for
 *                 the output table. If the schema provided is non-existent, it
 *                 will be automatically created.  The default value is ''.
 *                         <li> gpudb::create_union_mode: If @a merge_views,
 *                 then this operation will merge the provided views. All @a
 *                 tableNames must be views from the same underlying base
 *                 table.
 *                 <ul>
 *                         <li> gpudb::create_union_union_all: Retains all rows
 *                 from the specified tables.
 *                         <li> gpudb::create_union_union: Retains all unique
 *                 rows from the specified tables (synonym for @a
 *                 union_distinct).
 *                         <li> gpudb::create_union_union_distinct: Retains all
 *                 unique rows from the specified tables.
 *                         <li> gpudb::create_union_except: Retains all unique
 *                 rows from the first table that do not appear in the second
 *                 table (only works on 2 tables).
 *                         <li> gpudb::create_union_except_all: Retains all
 *                 rows(including duplicates) from the first table that do not
 *                 appear in the second table (only works on 2 tables).
 *                         <li> gpudb::create_union_intersect: Retains all
 *                 unique rows that appear in both of the specified tables
 *                 (only works on 2 tables).
 *                         <li> gpudb::create_union_intersect_all: Retains all
 *                 rows(including duplicates) that appear in both of the
 *                 specified tables (only works on 2 tables).
 *                         <li> gpudb::create_union_merge_views: Merge two or
 *                 more views (or views of views) of the same base data set
 *                 into a new view. If this mode is selected @a
 *                 inputColumnNames AND @a outputColumnNames must be empty. The
 *                 resulting view would match the results of a SQL OR
 *                 operation, e.g., if filter 1 creates a view using the
 *                 expression 'x = 20' and filter 2 creates a view using the
 *                 expression 'x <= 10', then the merge views operation creates
 *                 a new view using the expression 'x = 20 OR x <= 10'.
 *                 </ul>
 *                 The default value is gpudb::create_union_union_all.
 *                         <li> gpudb::create_union_chunk_size: Indicates the
 *                 number of records per chunk to be used for this output
 *                 table.
 *                         <li> gpudb::create_union_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the output table.  The columns specified must be present
 *                 in @a outputColumnNames.
 *                         <li> gpudb::create_union_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 output table specified in @a tableName.
 *                         <li> gpudb::create_union_persist: If @a true, then
 *                 the output table specified in @a tableName will be persisted
 *                 and will not expire unless a @a ttl is specified.   If @a
 *                 false, then the output table will be an in-memory table and
 *                 will expire unless a @a ttl is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::create_union_true
 *                         <li> gpudb::create_union_false
 *                 </ul>
 *                 The default value is gpudb::create_union_false.
 *                         <li> gpudb::create_union_view_id: ID of view of
 *                 which this output table is a member.  The default value is
 *                 ''.
 *                         <li> gpudb::create_union_force_replicated: If @a
 *                 true, then the output table specified in @a tableName will
 *                 be replicated even if the source tables are not.
 *                 <ul>
 *                         <li> gpudb::create_union_true
 *                         <li> gpudb::create_union_false
 *                 </ul>
 *                 The default value is gpudb::create_union_false.
 *                         <li> gpudb::create_union_strategy_definition: The <a
 *                 href="../../../rm/concepts/#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUnionResponse createUnion( const std::string& tableName,
                                 const std::vector<std::string>& tableNames,
                                 const std::vector<std::vector<std::string> >& inputColumnNames,
                                 const std::vector<std::string>& outputColumnNames,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Merges data from one or more tables with comparable data types into a new
 * table.
 * <p>
 * The following merges are supported:
 * <p>
 * UNION (DISTINCT/ALL) - For data set union details and examples, see <a
 * href="../../../concepts/unions/" target="_top">Union</a>.  For limitations,
 * see <a href="../../../concepts/unions/#limitations-and-cautions"
 * target="_top">Union Limitations and Cautions</a>.
 * <p>
 * INTERSECT (DISTINCT/ALL) - For data set intersection details and examples,
 * see <a href="../../../concepts/intersect/" target="_top">Intersect</a>.  For
 * limitations, see <a href="../../../concepts/intersect/#limitations"
 * target="_top">Intersect Limitations</a>.
 * <p>
 * EXCEPT (DISTINCT/ALL) - For data set subtraction details and examples, see
 * <a href="../../../concepts/except/" target="_top">Except</a>.  For
 * limitations, see <a href="../../../concepts/except/#limitations"
 * target="_top">Except Limitations</a>.
 * <p>
 * MERGE VIEWS - For a given set of <a href="../../../concepts/filtered_views/"
 * target="_top">filtered views</a> on a single table, creates a single
 * filtered view containing all of the unique records across all of the given
 * filtered data sets.
 * <p>
 * Non-charN 'string' and 'bytes' column types cannot be merged, nor can
 * columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a>.
 * 
 * @param tableName  Name of the table to be created, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a> and meeting <a
 *                   href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>.
 * @param tableNames  The list of table names to merge, in
 *                    [schema_name.]table_name format, using standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.  Must contain
 *                    the names of one or more existing tables.
 * @param inputColumnNames  The list of columns from each of the corresponding
 *                          input tables.
 * @param outputColumnNames  The list of names of the columns to be stored in
 *                           the output table.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_union_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a tableName. If @a
 *                 persist is @a false (or unspecified), then this is always
 *                 allowed even if the caller does not have permission to
 *                 create tables. The generated name is returned in @a
 *                 qualified_table_name.
 *                 <ul>
 *                         <li> gpudb::create_union_true
 *                         <li> gpudb::create_union_false
 *                 </ul>
 *                 The default value is gpudb::create_union_false.
 *                         <li> gpudb::create_union_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 projection as part of @a tableName and use /create/schema to
 *                 create the schema if non-existent]  Name of the schema for
 *                 the output table. If the schema provided is non-existent, it
 *                 will be automatically created.  The default value is ''.
 *                         <li> gpudb::create_union_mode: If @a merge_views,
 *                 then this operation will merge the provided views. All @a
 *                 tableNames must be views from the same underlying base
 *                 table.
 *                 <ul>
 *                         <li> gpudb::create_union_union_all: Retains all rows
 *                 from the specified tables.
 *                         <li> gpudb::create_union_union: Retains all unique
 *                 rows from the specified tables (synonym for @a
 *                 union_distinct).
 *                         <li> gpudb::create_union_union_distinct: Retains all
 *                 unique rows from the specified tables.
 *                         <li> gpudb::create_union_except: Retains all unique
 *                 rows from the first table that do not appear in the second
 *                 table (only works on 2 tables).
 *                         <li> gpudb::create_union_except_all: Retains all
 *                 rows(including duplicates) from the first table that do not
 *                 appear in the second table (only works on 2 tables).
 *                         <li> gpudb::create_union_intersect: Retains all
 *                 unique rows that appear in both of the specified tables
 *                 (only works on 2 tables).
 *                         <li> gpudb::create_union_intersect_all: Retains all
 *                 rows(including duplicates) that appear in both of the
 *                 specified tables (only works on 2 tables).
 *                         <li> gpudb::create_union_merge_views: Merge two or
 *                 more views (or views of views) of the same base data set
 *                 into a new view. If this mode is selected @a
 *                 inputColumnNames AND @a outputColumnNames must be empty. The
 *                 resulting view would match the results of a SQL OR
 *                 operation, e.g., if filter 1 creates a view using the
 *                 expression 'x = 20' and filter 2 creates a view using the
 *                 expression 'x <= 10', then the merge views operation creates
 *                 a new view using the expression 'x = 20 OR x <= 10'.
 *                 </ul>
 *                 The default value is gpudb::create_union_union_all.
 *                         <li> gpudb::create_union_chunk_size: Indicates the
 *                 number of records per chunk to be used for this output
 *                 table.
 *                         <li> gpudb::create_union_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the output table.  The columns specified must be present
 *                 in @a outputColumnNames.
 *                         <li> gpudb::create_union_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 output table specified in @a tableName.
 *                         <li> gpudb::create_union_persist: If @a true, then
 *                 the output table specified in @a tableName will be persisted
 *                 and will not expire unless a @a ttl is specified.   If @a
 *                 false, then the output table will be an in-memory table and
 *                 will expire unless a @a ttl is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::create_union_true
 *                         <li> gpudb::create_union_false
 *                 </ul>
 *                 The default value is gpudb::create_union_false.
 *                         <li> gpudb::create_union_view_id: ID of view of
 *                 which this output table is a member.  The default value is
 *                 ''.
 *                         <li> gpudb::create_union_force_replicated: If @a
 *                 true, then the output table specified in @a tableName will
 *                 be replicated even if the source tables are not.
 *                 <ul>
 *                         <li> gpudb::create_union_true
 *                         <li> gpudb::create_union_false
 *                 </ul>
 *                 The default value is gpudb::create_union_false.
 *                         <li> gpudb::create_union_strategy_definition: The <a
 *                 href="../../../rm/concepts/#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUnionResponse& createUnion( const std::string& tableName,
                                  const std::vector<std::string>& tableNames,
                                  const std::vector<std::vector<std::string> >& inputColumnNames,
                                  const std::vector<std::string>& outputColumnNames,
                                  const std::map<std::string, std::string>& options,
                                  CreateUnionResponse& response_ ) const;

/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUserExternalResponse createUserExternal( const CreateUserExternalRequest& request_ ) const;

/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUserExternalResponse& createUserExternal( const CreateUserExternalRequest& request_,
                                                CreateUserExternalResponse& response_ ) const;

/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param name  Name of the user to be created. Must exactly match the user's
 *              name in the external LDAP, prefixed with a @. Must not be the
 *              same name as an existing user.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_user_external_resource_group:
 *                 Name of an existing resource group to associate with this
 *                 user
 *                         <li> gpudb::create_user_external_default_schema:
 *                 Default schema to associate with this user
 *                         <li>
 *                 gpudb::create_user_external_create_home_directory: When @a
 *                 true, a home directory in KiFS is created for this user
 *                 <ul>
 *                         <li> gpudb::create_user_external_true
 *                         <li> gpudb::create_user_external_false
 *                 </ul>
 *                 The default value is gpudb::create_user_external_true.
 *                         <li>
 *                 gpudb::create_user_external_directory_data_limit: The
 *                 maximum capacity to apply to the created directory if @a
 *                 create_home_directory is @a true. Set to -1 to indicate no
 *                 upper limit. If empty, the system default limit is applied.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUserExternalResponse createUserExternal( const std::string& name,
                                               const std::map<std::string, std::string>& options ) const;

/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param name  Name of the user to be created. Must exactly match the user's
 *              name in the external LDAP, prefixed with a @. Must not be the
 *              same name as an existing user.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_user_external_resource_group:
 *                 Name of an existing resource group to associate with this
 *                 user
 *                         <li> gpudb::create_user_external_default_schema:
 *                 Default schema to associate with this user
 *                         <li>
 *                 gpudb::create_user_external_create_home_directory: When @a
 *                 true, a home directory in KiFS is created for this user
 *                 <ul>
 *                         <li> gpudb::create_user_external_true
 *                         <li> gpudb::create_user_external_false
 *                 </ul>
 *                 The default value is gpudb::create_user_external_true.
 *                         <li>
 *                 gpudb::create_user_external_directory_data_limit: The
 *                 maximum capacity to apply to the created directory if @a
 *                 create_home_directory is @a true. Set to -1 to indicate no
 *                 upper limit. If empty, the system default limit is applied.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUserExternalResponse& createUserExternal( const std::string& name,
                                                const std::map<std::string, std::string>& options,
                                                CreateUserExternalResponse& response_ ) const;

/**
 * Creates a new internal user (a user whose credentials are managed by the
 * database system).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUserInternalResponse createUserInternal( const CreateUserInternalRequest& request_ ) const;

/**
 * Creates a new internal user (a user whose credentials are managed by the
 * database system).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUserInternalResponse& createUserInternal( const CreateUserInternalRequest& request_,
                                                CreateUserInternalResponse& response_ ) const;

/**
 * Creates a new internal user (a user whose credentials are managed by the
 * database system).
 * 
 * @param name  Name of the user to be created. Must contain only lowercase
 *              letters, digits, and underscores, and cannot begin with a
 *              digit. Must not be the same name as an existing user or role.
 * @param password  Initial password of the user to be created. May be an empty
 *                  string for no password.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_user_internal_resource_group:
 *                 Name of an existing resource group to associate with this
 *                 user
 *                         <li> gpudb::create_user_internal_default_schema:
 *                 Default schema to associate with this user
 *                         <li>
 *                 gpudb::create_user_internal_create_home_directory: When @a
 *                 true, a home directory in KiFS is created for this user
 *                 <ul>
 *                         <li> gpudb::create_user_internal_true
 *                         <li> gpudb::create_user_internal_false
 *                 </ul>
 *                 The default value is gpudb::create_user_internal_true.
 *                         <li>
 *                 gpudb::create_user_internal_directory_data_limit: The
 *                 maximum capacity to apply to the created directory if @a
 *                 create_home_directory is @a true. Set to -1 to indicate no
 *                 upper limit. If empty, the system default limit is applied.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUserInternalResponse createUserInternal( const std::string& name,
                                               const std::string& password,
                                               const std::map<std::string, std::string>& options ) const;

/**
 * Creates a new internal user (a user whose credentials are managed by the
 * database system).
 * 
 * @param name  Name of the user to be created. Must contain only lowercase
 *              letters, digits, and underscores, and cannot begin with a
 *              digit. Must not be the same name as an existing user or role.
 * @param password  Initial password of the user to be created. May be an empty
 *                  string for no password.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_user_internal_resource_group:
 *                 Name of an existing resource group to associate with this
 *                 user
 *                         <li> gpudb::create_user_internal_default_schema:
 *                 Default schema to associate with this user
 *                         <li>
 *                 gpudb::create_user_internal_create_home_directory: When @a
 *                 true, a home directory in KiFS is created for this user
 *                 <ul>
 *                         <li> gpudb::create_user_internal_true
 *                         <li> gpudb::create_user_internal_false
 *                 </ul>
 *                 The default value is gpudb::create_user_internal_true.
 *                         <li>
 *                 gpudb::create_user_internal_directory_data_limit: The
 *                 maximum capacity to apply to the created directory if @a
 *                 create_home_directory is @a true. Set to -1 to indicate no
 *                 upper limit. If empty, the system default limit is applied.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUserInternalResponse& createUserInternal( const std::string& name,
                                                const std::string& password,
                                                const std::map<std::string, std::string>& options,
                                                CreateUserInternalResponse& response_ ) const;

/**
 * Creates a job to generate a sequence of raster images that visualize data
 * over a specified time.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateVideoResponse createVideo( const CreateVideoRequest& request_ ) const;

/**
 * Creates a job to generate a sequence of raster images that visualize data
 * over a specified time.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateVideoResponse& createVideo( const CreateVideoRequest& request_,
                                  CreateVideoResponse& response_ ) const;

/**
 * Creates a job to generate a sequence of raster images that visualize data
 * over a specified time.
 * 
 * @param attribute  The animated attribute to map to the video's frames. Must
 *                   be present in the LAYERS specified for the visualization.
 *                   This is often a time-related field but may be any numeric
 *                   type.
 * @param begin  The start point for the video. Accepts an expression evaluable
 *               over the @a attribute.
 * @param durationSeconds  Seconds of video to produce
 * @param end  The end point for the video. Accepts an expression evaluable
 *             over the @a attribute.
 * @param framesPerSecond  The presentation frame rate of the encoded video in
 *                         frames per second.
 * @param style  The name of the visualize mode; should correspond to the
 *               schema used for the @a styleParameters field.
 *               <ul>
 *                       <li> gpudb::create_video_chart
 *                       <li> gpudb::create_video_raster
 *                       <li> gpudb::create_video_classbreak
 *                       <li> gpudb::create_video_contour
 *                       <li> gpudb::create_video_heatmap
 *                       <li> gpudb::create_video_labels
 *               </ul>
 * @param path  Fully-qualified <a href="../../../tools/kifs/"
 *              target="_top">KiFS</a> path.  Write access is required. A file
 *              must not exist at that path, unless @a replace_if_exists is @a
 *              true.
 * @param styleParameters  A string containing the JSON-encoded visualize
 *                         request.  Must correspond to the visualize mode
 *                         specified in the @a style field.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_video_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 video.
 *                         <li> gpudb::create_video_window: Specified using the
 *                 data-type corresponding to the @a attribute. For a window of
 *                 size W, a video frame rendered for time t will visualize
 *                 data in the interval [t-W,t]. The minimum window size is the
 *                 interval between successive frames.  The minimum value is
 *                 the default.  If a value less than the minimum value is
 *                 specified, it is replaced with the minimum window size.
 *                 Larger values will make changes throughout the video appear
 *                 more smooth while smaller values will capture fast
 *                 variations in the data.
 *                         <li> gpudb::create_video_no_error_if_exists: If @a
 *                 true, does not return an error if the video already exists.
 *                 Ignored if @a replace_if_exists is @a true.
 *                 <ul>
 *                         <li> gpudb::create_video_false
 *                         <li> gpudb::create_video_true
 *                 </ul>
 *                 The default value is gpudb::create_video_false.
 *                         <li> gpudb::create_video_replace_if_exists: If @a
 *                 true, deletes any existing video with the same path before
 *                 creating a new video.
 *                 <ul>
 *                         <li> gpudb::create_video_false
 *                         <li> gpudb::create_video_true
 *                 </ul>
 *                 The default value is gpudb::create_video_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateVideoResponse createVideo( const std::string& attribute,
                                 const std::string& begin,
                                 const double durationSeconds,
                                 const std::string& end,
                                 const double framesPerSecond,
                                 const std::string& style,
                                 const std::string& path,
                                 const std::string& styleParameters,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Creates a job to generate a sequence of raster images that visualize data
 * over a specified time.
 * 
 * @param attribute  The animated attribute to map to the video's frames. Must
 *                   be present in the LAYERS specified for the visualization.
 *                   This is often a time-related field but may be any numeric
 *                   type.
 * @param begin  The start point for the video. Accepts an expression evaluable
 *               over the @a attribute.
 * @param durationSeconds  Seconds of video to produce
 * @param end  The end point for the video. Accepts an expression evaluable
 *             over the @a attribute.
 * @param framesPerSecond  The presentation frame rate of the encoded video in
 *                         frames per second.
 * @param style  The name of the visualize mode; should correspond to the
 *               schema used for the @a styleParameters field.
 *               <ul>
 *                       <li> gpudb::create_video_chart
 *                       <li> gpudb::create_video_raster
 *                       <li> gpudb::create_video_classbreak
 *                       <li> gpudb::create_video_contour
 *                       <li> gpudb::create_video_heatmap
 *                       <li> gpudb::create_video_labels
 *               </ul>
 * @param path  Fully-qualified <a href="../../../tools/kifs/"
 *              target="_top">KiFS</a> path.  Write access is required. A file
 *              must not exist at that path, unless @a replace_if_exists is @a
 *              true.
 * @param styleParameters  A string containing the JSON-encoded visualize
 *                         request.  Must correspond to the visualize mode
 *                         specified in the @a style field.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_video_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 video.
 *                         <li> gpudb::create_video_window: Specified using the
 *                 data-type corresponding to the @a attribute. For a window of
 *                 size W, a video frame rendered for time t will visualize
 *                 data in the interval [t-W,t]. The minimum window size is the
 *                 interval between successive frames.  The minimum value is
 *                 the default.  If a value less than the minimum value is
 *                 specified, it is replaced with the minimum window size.
 *                 Larger values will make changes throughout the video appear
 *                 more smooth while smaller values will capture fast
 *                 variations in the data.
 *                         <li> gpudb::create_video_no_error_if_exists: If @a
 *                 true, does not return an error if the video already exists.
 *                 Ignored if @a replace_if_exists is @a true.
 *                 <ul>
 *                         <li> gpudb::create_video_false
 *                         <li> gpudb::create_video_true
 *                 </ul>
 *                 The default value is gpudb::create_video_false.
 *                         <li> gpudb::create_video_replace_if_exists: If @a
 *                 true, deletes any existing video with the same path before
 *                 creating a new video.
 *                 <ul>
 *                         <li> gpudb::create_video_false
 *                         <li> gpudb::create_video_true
 *                 </ul>
 *                 The default value is gpudb::create_video_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateVideoResponse& createVideo( const std::string& attribute,
                                  const std::string& begin,
                                  const double durationSeconds,
                                  const std::string& end,
                                  const double framesPerSecond,
                                  const std::string& style,
                                  const std::string& path,
                                  const std::string& styleParameters,
                                  const std::map<std::string, std::string>& options,
                                  CreateVideoResponse& response_ ) const;

/**
 * Deletes a directory from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteDirectoryResponse deleteDirectory( const DeleteDirectoryRequest& request_ ) const;

/**
 * Deletes a directory from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteDirectoryResponse& deleteDirectory( const DeleteDirectoryRequest& request_,
                                          DeleteDirectoryResponse& response_ ) const;

/**
 * Deletes a directory from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param directoryName  Name of the directory in KiFS to be deleted. The
 *                       directory must contain no files, unless @a recursive
 *                       is @a true
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::delete_directory_recursive: If @a true,
 *                 will delete directory and all files residing in it. If
 *                 false, directory must be empty for deletion.
 *                 <ul>
 *                         <li> gpudb::delete_directory_true
 *                         <li> gpudb::delete_directory_false
 *                 </ul>
 *                 The default value is gpudb::delete_directory_false.
 *                         <li> gpudb::delete_directory_no_error_if_not_exists:
 *                 If @a true, no error is returned if specified directory does
 *                 not exist
 *                 <ul>
 *                         <li> gpudb::delete_directory_true
 *                         <li> gpudb::delete_directory_false
 *                 </ul>
 *                 The default value is gpudb::delete_directory_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteDirectoryResponse deleteDirectory( const std::string& directoryName,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Deletes a directory from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param directoryName  Name of the directory in KiFS to be deleted. The
 *                       directory must contain no files, unless @a recursive
 *                       is @a true
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::delete_directory_recursive: If @a true,
 *                 will delete directory and all files residing in it. If
 *                 false, directory must be empty for deletion.
 *                 <ul>
 *                         <li> gpudb::delete_directory_true
 *                         <li> gpudb::delete_directory_false
 *                 </ul>
 *                 The default value is gpudb::delete_directory_false.
 *                         <li> gpudb::delete_directory_no_error_if_not_exists:
 *                 If @a true, no error is returned if specified directory does
 *                 not exist
 *                 <ul>
 *                         <li> gpudb::delete_directory_true
 *                         <li> gpudb::delete_directory_false
 *                 </ul>
 *                 The default value is gpudb::delete_directory_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteDirectoryResponse& deleteDirectory( const std::string& directoryName,
                                          const std::map<std::string, std::string>& options,
                                          DeleteDirectoryResponse& response_ ) const;

/**
 * Deletes one or more files from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteFilesResponse deleteFiles( const DeleteFilesRequest& request_ ) const;

/**
 * Deletes one or more files from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteFilesResponse& deleteFiles( const DeleteFilesRequest& request_,
                                  DeleteFilesResponse& response_ ) const;

/**
 * Deletes one or more files from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param fileNames  An array of names of files to be deleted. File paths may
 *                   contain wildcard characters after the KiFS directory
 *                   delimeter.
 *                   Accepted wildcard characters are asterisk (*) to represent
 *                   any string of zero or more characters, and question mark
 *                   (?) to indicate a single character.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::delete_files_no_error_if_not_exists: If
 *                 @a true, no error is returned if a specified file does not
 *                 exist
 *                 <ul>
 *                         <li> gpudb::delete_files_true
 *                         <li> gpudb::delete_files_false
 *                 </ul>
 *                 The default value is gpudb::delete_files_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteFilesResponse deleteFiles( const std::vector<std::string>& fileNames,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Deletes one or more files from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param fileNames  An array of names of files to be deleted. File paths may
 *                   contain wildcard characters after the KiFS directory
 *                   delimeter.
 *                   Accepted wildcard characters are asterisk (*) to represent
 *                   any string of zero or more characters, and question mark
 *                   (?) to indicate a single character.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::delete_files_no_error_if_not_exists: If
 *                 @a true, no error is returned if a specified file does not
 *                 exist
 *                 <ul>
 *                         <li> gpudb::delete_files_true
 *                         <li> gpudb::delete_files_false
 *                 </ul>
 *                 The default value is gpudb::delete_files_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteFilesResponse& deleteFiles( const std::vector<std::string>& fileNames,
                                  const std::map<std::string, std::string>& options,
                                  DeleteFilesResponse& response_ ) const;

/**
 * Deletes an existing graph from the graph server and/or persist.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteGraphResponse deleteGraph( const DeleteGraphRequest& request_ ) const;

/**
 * Deletes an existing graph from the graph server and/or persist.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteGraphResponse& deleteGraph( const DeleteGraphRequest& request_,
                                  DeleteGraphResponse& response_ ) const;

/**
 * Deletes an existing graph from the graph server and/or persist.
 * 
 * @param graphName  Name of the graph to be deleted.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::delete_graph_delete_persist: If set to
 *                 @a true, the graph is removed from the server and persist.
 *                 If set to @a false, the graph is removed from the server but
 *                 is left in persist. The graph can be reloaded from persist
 *                 if it is recreated with the same 'graph_name'.
 *                 <ul>
 *                         <li> gpudb::delete_graph_true
 *                         <li> gpudb::delete_graph_false
 *                 </ul>
 *                 The default value is gpudb::delete_graph_true.
 *                         <li> gpudb::delete_graph_server_id: Indicates which
 *                 graph server(s) to send the request to. Default is to send
 *                 to get information about all the servers.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteGraphResponse deleteGraph( const std::string& graphName,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Deletes an existing graph from the graph server and/or persist.
 * 
 * @param graphName  Name of the graph to be deleted.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::delete_graph_delete_persist: If set to
 *                 @a true, the graph is removed from the server and persist.
 *                 If set to @a false, the graph is removed from the server but
 *                 is left in persist. The graph can be reloaded from persist
 *                 if it is recreated with the same 'graph_name'.
 *                 <ul>
 *                         <li> gpudb::delete_graph_true
 *                         <li> gpudb::delete_graph_false
 *                 </ul>
 *                 The default value is gpudb::delete_graph_true.
 *                         <li> gpudb::delete_graph_server_id: Indicates which
 *                 graph server(s) to send the request to. Default is to send
 *                 to get information about all the servers.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteGraphResponse& deleteGraph( const std::string& graphName,
                                  const std::map<std::string, std::string>& options,
                                  DeleteGraphResponse& response_ ) const;

/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteProcResponse deleteProc( const DeleteProcRequest& request_ ) const;

/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteProcResponse& deleteProc( const DeleteProcRequest& request_,
                                DeleteProcResponse& response_ ) const;

/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 * 
 * @param procName  Name of the proc to be deleted. Must be the name of a
 *                  currently existing proc.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteProcResponse deleteProc( const std::string& procName,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 * 
 * @param procName  Name of the proc to be deleted. Must be the name of a
 *                  currently existing proc.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteProcResponse& deleteProc( const std::string& procName,
                                const std::map<std::string, std::string>& options,
                                DeleteProcResponse& response_ ) const;

/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records), a single record identified by @a record_id
 * options, or all records when using @a delete_all_records.  Note that the
 * three selection criteria are mutually exclusive.  This operation cannot be
 * run on a view.  The operation is synchronous meaning that a response will
 * not be available until the request is completely processed and all the
 * matching records are deleted.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteRecordsResponse deleteRecords( const DeleteRecordsRequest& request_ ) const;

/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records), a single record identified by @a record_id
 * options, or all records when using @a delete_all_records.  Note that the
 * three selection criteria are mutually exclusive.  This operation cannot be
 * run on a view.  The operation is synchronous meaning that a response will
 * not be available until the request is completely processed and all the
 * matching records are deleted.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteRecordsResponse& deleteRecords( const DeleteRecordsRequest& request_,
                                      DeleteRecordsResponse& response_ ) const;

/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records), a single record identified by @a record_id
 * options, or all records when using @a delete_all_records.  Note that the
 * three selection criteria are mutually exclusive.  This operation cannot be
 * run on a view.  The operation is synchronous meaning that a response will
 * not be available until the request is completely processed and all the
 * matching records are deleted.
 * 
 * @param tableName  Name of the table from which to delete records, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>. Must contain the
 *                   name of an existing table; not applicable to views.
 * @param expressions  A list of the actual predicates, one for each select;
 *                     format should follow the guidelines provided <a
 *                     href="../../../concepts/expressions/"
 *                     target="_top">here</a>. Specifying one or more @a
 *                     expressions is mutually exclusive to specifying @a
 *                     record_id in the @a options.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::delete_records_global_expression: An
 *                 optional global expression to reduce the search space of the
 *                 @a expressions.  The default value is ''.
 *                         <li> gpudb::delete_records_record_id: A record ID
 *                 identifying a single record, obtained at the time of
 *                 /insert/records or by calling /get/records/fromcollection
 *                 with the *return_record_ids* option. This option cannot be
 *                 used to delete records from <a
 *                 href="../../../concepts/tables/#replication"
 *                 target="_top">replicated</a> tables.
 *                         <li> gpudb::delete_records_delete_all_records: If
 *                 set to @a true, all records in the table will be deleted. If
 *                 set to @a false, then the option is effectively ignored.
 *                 <ul>
 *                         <li> gpudb::delete_records_true
 *                         <li> gpudb::delete_records_false
 *                 </ul>
 *                 The default value is gpudb::delete_records_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteRecordsResponse deleteRecords( const std::string& tableName,
                                     const std::vector<std::string>& expressions,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records), a single record identified by @a record_id
 * options, or all records when using @a delete_all_records.  Note that the
 * three selection criteria are mutually exclusive.  This operation cannot be
 * run on a view.  The operation is synchronous meaning that a response will
 * not be available until the request is completely processed and all the
 * matching records are deleted.
 * 
 * @param tableName  Name of the table from which to delete records, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>. Must contain the
 *                   name of an existing table; not applicable to views.
 * @param expressions  A list of the actual predicates, one for each select;
 *                     format should follow the guidelines provided <a
 *                     href="../../../concepts/expressions/"
 *                     target="_top">here</a>. Specifying one or more @a
 *                     expressions is mutually exclusive to specifying @a
 *                     record_id in the @a options.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::delete_records_global_expression: An
 *                 optional global expression to reduce the search space of the
 *                 @a expressions.  The default value is ''.
 *                         <li> gpudb::delete_records_record_id: A record ID
 *                 identifying a single record, obtained at the time of
 *                 /insert/records or by calling /get/records/fromcollection
 *                 with the *return_record_ids* option. This option cannot be
 *                 used to delete records from <a
 *                 href="../../../concepts/tables/#replication"
 *                 target="_top">replicated</a> tables.
 *                         <li> gpudb::delete_records_delete_all_records: If
 *                 set to @a true, all records in the table will be deleted. If
 *                 set to @a false, then the option is effectively ignored.
 *                 <ul>
 *                         <li> gpudb::delete_records_true
 *                         <li> gpudb::delete_records_false
 *                 </ul>
 *                 The default value is gpudb::delete_records_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteRecordsResponse& deleteRecords( const std::string& tableName,
                                      const std::vector<std::string>& expressions,
                                      const std::map<std::string, std::string>& options,
                                      DeleteRecordsResponse& response_ ) const;

/**
 * Deletes a resource group.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteResourceGroupResponse deleteResourceGroup( const DeleteResourceGroupRequest& request_ ) const;

/**
 * Deletes a resource group.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteResourceGroupResponse& deleteResourceGroup( const DeleteResourceGroupRequest& request_,
                                                  DeleteResourceGroupResponse& response_ ) const;

/**
 * Deletes a resource group.
 * 
 * @param name  Name of the resource group to be deleted.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::delete_resource_group_cascade_delete: If
 *                 @a true, delete any existing entities owned by this group.
 *                 Otherwise this request will return an error of any such
 *                 entities exist.
 *                 <ul>
 *                         <li> gpudb::delete_resource_group_true
 *                         <li> gpudb::delete_resource_group_false
 *                 </ul>
 *                 The default value is gpudb::delete_resource_group_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteResourceGroupResponse deleteResourceGroup( const std::string& name,
                                                 const std::map<std::string, std::string>& options ) const;

/**
 * Deletes a resource group.
 * 
 * @param name  Name of the resource group to be deleted.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::delete_resource_group_cascade_delete: If
 *                 @a true, delete any existing entities owned by this group.
 *                 Otherwise this request will return an error of any such
 *                 entities exist.
 *                 <ul>
 *                         <li> gpudb::delete_resource_group_true
 *                         <li> gpudb::delete_resource_group_false
 *                 </ul>
 *                 The default value is gpudb::delete_resource_group_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteResourceGroupResponse& deleteResourceGroup( const std::string& name,
                                                  const std::map<std::string, std::string>& options,
                                                  DeleteResourceGroupResponse& response_ ) const;

/**
 * Deletes an existing role.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteRoleResponse deleteRole( const DeleteRoleRequest& request_ ) const;

/**
 * Deletes an existing role.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteRoleResponse& deleteRole( const DeleteRoleRequest& request_,
                                DeleteRoleResponse& response_ ) const;

/**
 * Deletes an existing role.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param name  Name of the role to be deleted. Must be an existing role.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteRoleResponse deleteRole( const std::string& name,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Deletes an existing role.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param name  Name of the role to be deleted. Must be an existing role.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteRoleResponse& deleteRole( const std::string& name,
                                const std::map<std::string, std::string>& options,
                                DeleteRoleResponse& response_ ) const;

/**
 * Deletes an existing user.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteUserResponse deleteUser( const DeleteUserRequest& request_ ) const;

/**
 * Deletes an existing user.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteUserResponse& deleteUser( const DeleteUserRequest& request_,
                                DeleteUserResponse& response_ ) const;

/**
 * Deletes an existing user.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param name  Name of the user to be deleted. Must be an existing user.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteUserResponse deleteUser( const std::string& name,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Deletes an existing user.
 * <p>
 * @attention This method should be used for on-premise deployments only.
 * <p>
 * 
 * @param name  Name of the user to be deleted. Must be an existing user.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteUserResponse& deleteUser( const std::string& name,
                                const std::map<std::string, std::string>& options,
                                DeleteUserResponse& response_ ) const;

/**
 * Downloads one or more files from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DownloadFilesResponse downloadFiles( const DownloadFilesRequest& request_ ) const;

/**
 * Downloads one or more files from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DownloadFilesResponse& downloadFiles( const DownloadFilesRequest& request_,
                                      DownloadFilesResponse& response_ ) const;

/**
 * Downloads one or more files from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param fileNames  An array of the file names to download from KiFS. File
 *                   paths may contain wildcard characters after the KiFS
 *                   directory delimeter.
 *                   Accepted wildcard characters are asterisk (*) to represent
 *                   any string of zero or more characters, and question mark
 *                   (?) to indicate a single character.
 * @param readOffsets  An array of starting byte offsets from which to read
 *                     each
 *                     respective file in @a fileNames. Must either be empty or
 *                     the same length
 *                     as @a fileNames. If empty, files are downloaded in their
 *                     entirety. If not
 *                     empty, @a readLengths must also not be empty.
 * @param readLengths  Array of number of bytes to read from each respective
 *                     file
 *                     in @a fileNames. Must either be empty or the same length
 *                     as
 *                     @a fileNames. If empty, files are downloaded in their
 *                     entirety. If not
 *                     empty, @a readOffsets must also not be empty.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::download_files_file_encoding: Encoding
 *                 to be applied to the output file data. When using JSON
 *                 serialization it is recommended to specify this as @a
 *                 base64.
 *                 <ul>
 *                         <li> gpudb::download_files_base64: Apply base64
 *                 encoding to the output file data.
 *                         <li> gpudb::download_files_none: Do not apply any
 *                 encoding to the output file data.
 *                 </ul>
 *                 The default value is gpudb::download_files_none.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DownloadFilesResponse downloadFiles( const std::vector<std::string>& fileNames,
                                     const std::vector<int64_t>& readOffsets,
                                     const std::vector<int64_t>& readLengths,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Downloads one or more files from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * 
 * @param fileNames  An array of the file names to download from KiFS. File
 *                   paths may contain wildcard characters after the KiFS
 *                   directory delimeter.
 *                   Accepted wildcard characters are asterisk (*) to represent
 *                   any string of zero or more characters, and question mark
 *                   (?) to indicate a single character.
 * @param readOffsets  An array of starting byte offsets from which to read
 *                     each
 *                     respective file in @a fileNames. Must either be empty or
 *                     the same length
 *                     as @a fileNames. If empty, files are downloaded in their
 *                     entirety. If not
 *                     empty, @a readLengths must also not be empty.
 * @param readLengths  Array of number of bytes to read from each respective
 *                     file
 *                     in @a fileNames. Must either be empty or the same length
 *                     as
 *                     @a fileNames. If empty, files are downloaded in their
 *                     entirety. If not
 *                     empty, @a readOffsets must also not be empty.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::download_files_file_encoding: Encoding
 *                 to be applied to the output file data. When using JSON
 *                 serialization it is recommended to specify this as @a
 *                 base64.
 *                 <ul>
 *                         <li> gpudb::download_files_base64: Apply base64
 *                 encoding to the output file data.
 *                         <li> gpudb::download_files_none: Do not apply any
 *                 encoding to the output file data.
 *                 </ul>
 *                 The default value is gpudb::download_files_none.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DownloadFilesResponse& downloadFiles( const std::vector<std::string>& fileNames,
                                      const std::vector<int64_t>& readOffsets,
                                      const std::vector<int64_t>& readLengths,
                                      const std::map<std::string, std::string>& options,
                                      DownloadFilesResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DropContainerRegistryResponse dropContainerRegistry( const DropContainerRegistryRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DropContainerRegistryResponse& dropContainerRegistry( const DropContainerRegistryRequest& request_,
                                                      DropContainerRegistryResponse& response_ ) const;

/**
 * @private
 * 
 * @param registryName
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DropContainerRegistryResponse dropContainerRegistry( const std::string& registryName,
                                                     const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param registryName
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DropContainerRegistryResponse& dropContainerRegistry( const std::string& registryName,
                                                      const std::map<std::string, std::string>& options,
                                                      DropContainerRegistryResponse& response_ ) const;

/**
 * Drop an existing <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DropCredentialResponse dropCredential( const DropCredentialRequest& request_ ) const;

/**
 * Drop an existing <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DropCredentialResponse& dropCredential( const DropCredentialRequest& request_,
                                        DropCredentialResponse& response_ ) const;

/**
 * Drop an existing <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 * 
 * @param credentialName  Name of the credential to be dropped. Must be an
 *                        existing credential.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DropCredentialResponse dropCredential( const std::string& credentialName,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Drop an existing <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 * 
 * @param credentialName  Name of the credential to be dropped. Must be an
 *                        existing credential.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DropCredentialResponse& dropCredential( const std::string& credentialName,
                                        const std::map<std::string, std::string>& options,
                                        DropCredentialResponse& response_ ) const;

/**
 * Drops an existing <a href="../../../concepts/data_sinks/" target="_top">data
 * sink</a>.
 * <p>
 * By default, if any <a href="../../../concepts/table_monitors"
 * target="_top">table monitors</a> use this
 * sink as a destination, the request will be blocked unless option
 * @a clear_table_monitors is
 * @a true.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DropDatasinkResponse dropDatasink( const DropDatasinkRequest& request_ ) const;

/**
 * Drops an existing <a href="../../../concepts/data_sinks/" target="_top">data
 * sink</a>.
 * <p>
 * By default, if any <a href="../../../concepts/table_monitors"
 * target="_top">table monitors</a> use this
 * sink as a destination, the request will be blocked unless option
 * @a clear_table_monitors is
 * @a true.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DropDatasinkResponse& dropDatasink( const DropDatasinkRequest& request_,
                                    DropDatasinkResponse& response_ ) const;

/**
 * Drops an existing <a href="../../../concepts/data_sinks/" target="_top">data
 * sink</a>.
 * <p>
 * By default, if any <a href="../../../concepts/table_monitors"
 * target="_top">table monitors</a> use this
 * sink as a destination, the request will be blocked unless option
 * @a clear_table_monitors is
 * @a true.
 * 
 * @param name  Name of the data sink to be dropped. Must be an existing data
 *              sink.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::drop_datasink_clear_table_monitors: If
 *                 @a true, any <a href="../../../concepts/table_monitors/"
 *                 target="_top">table monitors</a> that use this data sink
 *                 will be cleared.
 *                 <ul>
 *                         <li> gpudb::drop_datasink_true
 *                         <li> gpudb::drop_datasink_false
 *                 </ul>
 *                 The default value is gpudb::drop_datasink_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DropDatasinkResponse dropDatasink( const std::string& name,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Drops an existing <a href="../../../concepts/data_sinks/" target="_top">data
 * sink</a>.
 * <p>
 * By default, if any <a href="../../../concepts/table_monitors"
 * target="_top">table monitors</a> use this
 * sink as a destination, the request will be blocked unless option
 * @a clear_table_monitors is
 * @a true.
 * 
 * @param name  Name of the data sink to be dropped. Must be an existing data
 *              sink.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::drop_datasink_clear_table_monitors: If
 *                 @a true, any <a href="../../../concepts/table_monitors/"
 *                 target="_top">table monitors</a> that use this data sink
 *                 will be cleared.
 *                 <ul>
 *                         <li> gpudb::drop_datasink_true
 *                         <li> gpudb::drop_datasink_false
 *                 </ul>
 *                 The default value is gpudb::drop_datasink_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DropDatasinkResponse& dropDatasink( const std::string& name,
                                    const std::map<std::string, std::string>& options,
                                    DropDatasinkResponse& response_ ) const;

/**
 * Drops an existing <a href="../../../concepts/data_sources/"
 * target="_top">data source</a>.  Any external
 * tables that depend on the data source must be dropped before it can be
 * dropped.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DropDatasourceResponse dropDatasource( const DropDatasourceRequest& request_ ) const;

/**
 * Drops an existing <a href="../../../concepts/data_sources/"
 * target="_top">data source</a>.  Any external
 * tables that depend on the data source must be dropped before it can be
 * dropped.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DropDatasourceResponse& dropDatasource( const DropDatasourceRequest& request_,
                                        DropDatasourceResponse& response_ ) const;

/**
 * Drops an existing <a href="../../../concepts/data_sources/"
 * target="_top">data source</a>.  Any external
 * tables that depend on the data source must be dropped before it can be
 * dropped.
 * 
 * @param name  Name of the data source to be dropped. Must be an existing data
 *              source.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DropDatasourceResponse dropDatasource( const std::string& name,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Drops an existing <a href="../../../concepts/data_sources/"
 * target="_top">data source</a>.  Any external
 * tables that depend on the data source must be dropped before it can be
 * dropped.
 * 
 * @param name  Name of the data source to be dropped. Must be an existing data
 *              source.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DropDatasourceResponse& dropDatasource( const std::string& name,
                                        const std::map<std::string, std::string>& options,
                                        DropDatasourceResponse& response_ ) const;

/**
 * Drop an existing <a href="../../../concepts/udf/" target="_top">user-defined
 * function</a> (UDF) environment.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DropEnvironmentResponse dropEnvironment( const DropEnvironmentRequest& request_ ) const;

/**
 * Drop an existing <a href="../../../concepts/udf/" target="_top">user-defined
 * function</a> (UDF) environment.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DropEnvironmentResponse& dropEnvironment( const DropEnvironmentRequest& request_,
                                          DropEnvironmentResponse& response_ ) const;

/**
 * Drop an existing <a href="../../../concepts/udf/" target="_top">user-defined
 * function</a> (UDF) environment.
 * 
 * @param environmentName  Name of the environment to be dropped. Must be an
 *                         existing environment.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::drop_environment_no_error_if_not_exists:
 *                 If @a true and if the environment specified in @a
 *                 environmentName does not exist, no error is returned. If @a
 *                 false and if the environment specified in @a environmentName
 *                 does not exist, then an error is returned.
 *                 <ul>
 *                         <li> gpudb::drop_environment_true
 *                         <li> gpudb::drop_environment_false
 *                 </ul>
 *                 The default value is gpudb::drop_environment_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DropEnvironmentResponse dropEnvironment( const std::string& environmentName,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Drop an existing <a href="../../../concepts/udf/" target="_top">user-defined
 * function</a> (UDF) environment.
 * 
 * @param environmentName  Name of the environment to be dropped. Must be an
 *                         existing environment.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::drop_environment_no_error_if_not_exists:
 *                 If @a true and if the environment specified in @a
 *                 environmentName does not exist, no error is returned. If @a
 *                 false and if the environment specified in @a environmentName
 *                 does not exist, then an error is returned.
 *                 <ul>
 *                         <li> gpudb::drop_environment_true
 *                         <li> gpudb::drop_environment_false
 *                 </ul>
 *                 The default value is gpudb::drop_environment_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DropEnvironmentResponse& dropEnvironment( const std::string& environmentName,
                                          const std::map<std::string, std::string>& options,
                                          DropEnvironmentResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DropModelResponse dropModel( const DropModelRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DropModelResponse& dropModel( const DropModelRequest& request_,
                              DropModelResponse& response_ ) const;

/**
 * @private
 * 
 * @param modelName
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DropModelResponse dropModel( const std::string& modelName,
                             const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param modelName
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DropModelResponse& dropModel( const std::string& modelName,
                              const std::map<std::string, std::string>& options,
                              DropModelResponse& response_ ) const;

/**
 * Drops an existing SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>, specified in @a schemaName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DropSchemaResponse dropSchema( const DropSchemaRequest& request_ ) const;

/**
 * Drops an existing SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>, specified in @a schemaName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DropSchemaResponse& dropSchema( const DropSchemaRequest& request_,
                                DropSchemaResponse& response_ ) const;

/**
 * Drops an existing SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>, specified in @a schemaName.
 * 
 * @param schemaName  Name of the schema to be dropped. Must be an existing
 *                    schema.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::drop_schema_no_error_if_not_exists: If
 *                 @a true and if the schema specified in @a schemaName does
 *                 not exist, no error is returned. If @a false and if the
 *                 schema specified in @a schemaName does not exist, then an
 *                 error is returned.
 *                 <ul>
 *                         <li> gpudb::drop_schema_true
 *                         <li> gpudb::drop_schema_false
 *                 </ul>
 *                 The default value is gpudb::drop_schema_false.
 *                         <li> gpudb::drop_schema_cascade: If @a true, all
 *                 tables within the schema will be dropped. If @a false, the
 *                 schema will be dropped only if empty.
 *                 <ul>
 *                         <li> gpudb::drop_schema_true
 *                         <li> gpudb::drop_schema_false
 *                 </ul>
 *                 The default value is gpudb::drop_schema_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DropSchemaResponse dropSchema( const std::string& schemaName,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Drops an existing SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>, specified in @a schemaName.
 * 
 * @param schemaName  Name of the schema to be dropped. Must be an existing
 *                    schema.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::drop_schema_no_error_if_not_exists: If
 *                 @a true and if the schema specified in @a schemaName does
 *                 not exist, no error is returned. If @a false and if the
 *                 schema specified in @a schemaName does not exist, then an
 *                 error is returned.
 *                 <ul>
 *                         <li> gpudb::drop_schema_true
 *                         <li> gpudb::drop_schema_false
 *                 </ul>
 *                 The default value is gpudb::drop_schema_false.
 *                         <li> gpudb::drop_schema_cascade: If @a true, all
 *                 tables within the schema will be dropped. If @a false, the
 *                 schema will be dropped only if empty.
 *                 <ul>
 *                         <li> gpudb::drop_schema_true
 *                         <li> gpudb::drop_schema_false
 *                 </ul>
 *                 The default value is gpudb::drop_schema_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DropSchemaResponse& dropSchema( const std::string& schemaName,
                                const std::map<std::string, std::string>& options,
                                DropSchemaResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

EvaluateModelResponse evaluateModel( const EvaluateModelRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

EvaluateModelResponse& evaluateModel( const EvaluateModelRequest& request_,
                                      EvaluateModelResponse& response_ ) const;

/**
 * @private
 * 
 * @param modelName
 * @param replicas
 * @param deploymentMode
 * @param sourceTable
 * @param destinationTable
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

EvaluateModelResponse evaluateModel( const std::string& modelName,
                                     const int32_t replicas,
                                     const std::string& deploymentMode,
                                     const std::string& sourceTable,
                                     const std::string& destinationTable,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param modelName
 * @param replicas
 * @param deploymentMode
 * @param sourceTable
 * @param destinationTable
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

EvaluateModelResponse& evaluateModel( const std::string& modelName,
                                      const int32_t replicas,
                                      const std::string& deploymentMode,
                                      const std::string& sourceTable,
                                      const std::string& destinationTable,
                                      const std::map<std::string, std::string>& options,
                                      EvaluateModelResponse& response_ ) const;

/**
 * Executes a proc. This endpoint is asynchronous and does not wait for
 * the proc to complete before returning.
 * <p>
 * If the proc being executed is distributed, @a inputTableNames &
 * @a inputColumnNames may be passed to the proc to use for reading data,
 * and @a outputTableNames may be passed to the proc to use for writing
 * data.
 * <p>
 * If the proc being executed is non-distributed, these table parameters will
 * be
 * ignored.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExecuteProcResponse executeProc( const ExecuteProcRequest& request_ ) const;

/**
 * Executes a proc. This endpoint is asynchronous and does not wait for
 * the proc to complete before returning.
 * <p>
 * If the proc being executed is distributed, @a inputTableNames &
 * @a inputColumnNames may be passed to the proc to use for reading data,
 * and @a outputTableNames may be passed to the proc to use for writing
 * data.
 * <p>
 * If the proc being executed is non-distributed, these table parameters will
 * be
 * ignored.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExecuteProcResponse& executeProc( const ExecuteProcRequest& request_,
                                  ExecuteProcResponse& response_ ) const;

/**
 * Executes a proc. This endpoint is asynchronous and does not wait for
 * the proc to complete before returning.
 * <p>
 * If the proc being executed is distributed, @a inputTableNames &
 * @a inputColumnNames may be passed to the proc to use for reading data,
 * and @a outputTableNames may be passed to the proc to use for writing
 * data.
 * <p>
 * If the proc being executed is non-distributed, these table parameters will
 * be
 * ignored.
 * 
 * @param procName  Name of the proc to execute. Must be the name of a
 *                  currently existing proc.
 * @param params  A map containing named parameters to pass to the proc. Each
 *                key/value pair specifies the name of a parameter and its
 *                value.
 * @param binParams  A map containing named binary parameters to pass to the
 *                   proc. Each key/value pair specifies the name of a
 *                   parameter and its value.
 * @param inputTableNames  Names of the tables containing data to be passed to
 *                         the
 *                         proc. Each name specified must be the name of a
 *                         currently existing table, in
 *                         [schema_name.]table_name format, using standard
 *                         <a
 *                         href="../../../concepts/tables/#table-name-resolution"
 *                         target="_top">name resolution rules</a>.
 *                         If no table names are specified, no data will be
 *                         passed to the proc.  This
 *                         parameter is ignored if the proc has a
 *                         non-distributed execution mode.
 * @param inputColumnNames  Map of table names from @a inputTableNames to lists
 *                          of names of columns from those tables that will be
 *                          passed to the proc. Each
 *                          column name specified must be the name of an
 *                          existing column in the
 *                          corresponding table. If a table name from @a
 *                          inputTableNames is not
 *                          included, all columns from that table will be
 *                          passed to the proc.  This
 *                          parameter is ignored if the proc has a
 *                          non-distributed execution mode.
 * @param outputTableNames  Names of the tables to which output data from the
 *                          proc will
 *                          be written, each in [schema_name.]table_name
 *                          format, using standard
 *                          <a
 *                          href="../../../concepts/tables/#table-name-resolution"
 *                          target="_top">name resolution rules</a>
 *                          and meeting <a
 *                          href="../../../concepts/tables/#table-naming-criteria"
 *                          target="_top">table naming criteria</a>.
 *                          If a specified table does not exist, it will
 *                          automatically be created with the
 *                          same schema as the corresponding table (by order)
 *                          from
 *                          @a inputTableNames, excluding any primary and shard
 *                          keys. If a specified
 *                          table is a non-persistent result table, it must not
 *                          have primary or shard keys.
 *                          If no table names are specified, no output data can
 *                          be returned from the proc.
 *                          This parameter is ignored if the proc has a
 *                          non-distributed execution mode.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::execute_proc_cache_input: A
 *                 comma-delimited list of table names from @a inputTableNames
 *                 from which input data will be cached for use in subsequent
 *                 calls to /execute/proc with the @a use_cached_input option.
 *                 Cached input data will be retained until the proc status is
 *                 cleared with the /show/proc/status option of
 *                 /show/proc/status and all proc instances using the cached
 *                 data have completed.  The default value is ''.
 *                         <li> gpudb::execute_proc_use_cached_input: A
 *                 comma-delimited list of run IDs (as returned from prior
 *                 calls to /execute/proc) of running or completed proc
 *                 instances from which input data cached using the @a
 *                 cache_input option will be used. Cached input data will not
 *                 be used for any tables specified in @a inputTableNames, but
 *                 data from all other tables cached for the specified run IDs
 *                 will be passed to the proc. If the same table was cached for
 *                 multiple specified run IDs, the cached data from the first
 *                 run ID specified in the list that includes that table will
 *                 be used.  The default value is ''.
 *                         <li> gpudb::execute_proc_run_tag: A string that, if
 *                 not empty, can be used in subsequent calls to
 *                 /show/proc/status or /kill/proc to identify the proc
 *                 instance.  The default value is ''.
 *                         <li> gpudb::execute_proc_max_output_lines: The
 *                 maximum number of lines of output from stdout and stderr to
 *                 return via /show/proc/status. If the number of lines output
 *                 exceeds the maximum, earlier lines are discarded.  The
 *                 default value is '100'.
 *                         <li> gpudb::execute_proc_execute_at_startup: If @a
 *                 true, an instance of the proc will run when the database is
 *                 started instead of running immediately. The @a runId can be
 *                 retrieved using /show/proc and used in /show/proc/status.
 *                 <ul>
 *                         <li> gpudb::execute_proc_true
 *                         <li> gpudb::execute_proc_false
 *                 </ul>
 *                 The default value is gpudb::execute_proc_false.
 *                         <li> gpudb::execute_proc_execute_at_startup_as: Sets
 *                 the alternate user name to execute this proc instance as
 *                 when @a execute_at_startup is @a true.  The default value is
 *                 ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExecuteProcResponse executeProc( const std::string& procName,
                                 const std::map<std::string, std::string>& params,
                                 const std::map<std::string, std::vector<uint8_t> >& binParams,
                                 const std::vector<std::string>& inputTableNames,
                                 const std::map<std::string, std::vector<std::string> >& inputColumnNames,
                                 const std::vector<std::string>& outputTableNames,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Executes a proc. This endpoint is asynchronous and does not wait for
 * the proc to complete before returning.
 * <p>
 * If the proc being executed is distributed, @a inputTableNames &
 * @a inputColumnNames may be passed to the proc to use for reading data,
 * and @a outputTableNames may be passed to the proc to use for writing
 * data.
 * <p>
 * If the proc being executed is non-distributed, these table parameters will
 * be
 * ignored.
 * 
 * @param procName  Name of the proc to execute. Must be the name of a
 *                  currently existing proc.
 * @param params  A map containing named parameters to pass to the proc. Each
 *                key/value pair specifies the name of a parameter and its
 *                value.
 * @param binParams  A map containing named binary parameters to pass to the
 *                   proc. Each key/value pair specifies the name of a
 *                   parameter and its value.
 * @param inputTableNames  Names of the tables containing data to be passed to
 *                         the
 *                         proc. Each name specified must be the name of a
 *                         currently existing table, in
 *                         [schema_name.]table_name format, using standard
 *                         <a
 *                         href="../../../concepts/tables/#table-name-resolution"
 *                         target="_top">name resolution rules</a>.
 *                         If no table names are specified, no data will be
 *                         passed to the proc.  This
 *                         parameter is ignored if the proc has a
 *                         non-distributed execution mode.
 * @param inputColumnNames  Map of table names from @a inputTableNames to lists
 *                          of names of columns from those tables that will be
 *                          passed to the proc. Each
 *                          column name specified must be the name of an
 *                          existing column in the
 *                          corresponding table. If a table name from @a
 *                          inputTableNames is not
 *                          included, all columns from that table will be
 *                          passed to the proc.  This
 *                          parameter is ignored if the proc has a
 *                          non-distributed execution mode.
 * @param outputTableNames  Names of the tables to which output data from the
 *                          proc will
 *                          be written, each in [schema_name.]table_name
 *                          format, using standard
 *                          <a
 *                          href="../../../concepts/tables/#table-name-resolution"
 *                          target="_top">name resolution rules</a>
 *                          and meeting <a
 *                          href="../../../concepts/tables/#table-naming-criteria"
 *                          target="_top">table naming criteria</a>.
 *                          If a specified table does not exist, it will
 *                          automatically be created with the
 *                          same schema as the corresponding table (by order)
 *                          from
 *                          @a inputTableNames, excluding any primary and shard
 *                          keys. If a specified
 *                          table is a non-persistent result table, it must not
 *                          have primary or shard keys.
 *                          If no table names are specified, no output data can
 *                          be returned from the proc.
 *                          This parameter is ignored if the proc has a
 *                          non-distributed execution mode.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::execute_proc_cache_input: A
 *                 comma-delimited list of table names from @a inputTableNames
 *                 from which input data will be cached for use in subsequent
 *                 calls to /execute/proc with the @a use_cached_input option.
 *                 Cached input data will be retained until the proc status is
 *                 cleared with the /show/proc/status option of
 *                 /show/proc/status and all proc instances using the cached
 *                 data have completed.  The default value is ''.
 *                         <li> gpudb::execute_proc_use_cached_input: A
 *                 comma-delimited list of run IDs (as returned from prior
 *                 calls to /execute/proc) of running or completed proc
 *                 instances from which input data cached using the @a
 *                 cache_input option will be used. Cached input data will not
 *                 be used for any tables specified in @a inputTableNames, but
 *                 data from all other tables cached for the specified run IDs
 *                 will be passed to the proc. If the same table was cached for
 *                 multiple specified run IDs, the cached data from the first
 *                 run ID specified in the list that includes that table will
 *                 be used.  The default value is ''.
 *                         <li> gpudb::execute_proc_run_tag: A string that, if
 *                 not empty, can be used in subsequent calls to
 *                 /show/proc/status or /kill/proc to identify the proc
 *                 instance.  The default value is ''.
 *                         <li> gpudb::execute_proc_max_output_lines: The
 *                 maximum number of lines of output from stdout and stderr to
 *                 return via /show/proc/status. If the number of lines output
 *                 exceeds the maximum, earlier lines are discarded.  The
 *                 default value is '100'.
 *                         <li> gpudb::execute_proc_execute_at_startup: If @a
 *                 true, an instance of the proc will run when the database is
 *                 started instead of running immediately. The @a runId can be
 *                 retrieved using /show/proc and used in /show/proc/status.
 *                 <ul>
 *                         <li> gpudb::execute_proc_true
 *                         <li> gpudb::execute_proc_false
 *                 </ul>
 *                 The default value is gpudb::execute_proc_false.
 *                         <li> gpudb::execute_proc_execute_at_startup_as: Sets
 *                 the alternate user name to execute this proc instance as
 *                 when @a execute_at_startup is @a true.  The default value is
 *                 ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExecuteProcResponse& executeProc( const std::string& procName,
                                  const std::map<std::string, std::string>& params,
                                  const std::map<std::string, std::vector<uint8_t> >& binParams,
                                  const std::vector<std::string>& inputTableNames,
                                  const std::map<std::string, std::vector<std::string> >& inputColumnNames,
                                  const std::vector<std::string>& outputTableNames,
                                  const std::map<std::string, std::string>& options,
                                  ExecuteProcResponse& response_ ) const;

/**
 * Execute a SQL statement (query, DML, or DDL).
 * <p>
 * See <a href="../../../sql/" target="_top">SQL Support</a> for the complete
 * set of supported SQL commands.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawExecuteSqlResponse executeSqlRaw( const ExecuteSqlRequest& request_ ) const;

/**
 * Execute a SQL statement (query, DML, or DDL).
 * <p>
 * See <a href="../../../sql/" target="_top">SQL Support</a> for the complete
 * set of supported SQL commands.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawExecuteSqlResponse& executeSqlRaw( const ExecuteSqlRequest& request_,
                                      RawExecuteSqlResponse& response_ ) const;

/**
 * Execute a SQL statement (query, DML, or DDL).
 * <p>
 * See <a href="../../../sql/" target="_top">SQL Support</a> for the complete
 * set of supported SQL commands.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExecuteSqlResponse executeSql( const ExecuteSqlRequest& request_ ) const;

/**
 * Execute a SQL statement (query, DML, or DDL).
 * <p>
 * See <a href="../../../sql/" target="_top">SQL Support</a> for the complete
 * set of supported SQL commands.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExecuteSqlResponse& executeSql( const ExecuteSqlRequest& request_,
                                ExecuteSqlResponse& response_ ) const;

/**
 * Execute a SQL statement (query, DML, or DDL).
 * <p>
 * See <a href="../../../sql/" target="_top">SQL Support</a> for the complete
 * set of supported SQL commands.
 * 
 * @param statement  SQL statement (query, DML, or DDL) to be executed
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a hasMoreRecords to see if more records exist in the
 *               result to be fetched, and
 *               @a offset & @a limit to request subsequent pages of results.
 * @param requestSchemaStr  Avro schema of @a data.
 * @param data  An array of binary-encoded data for the records to be binded to
 *              the SQL query.  Or use @a query_parameters to pass the data in
 *              JSON format.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::execute_sql_cost_based_optimization: If
 *                 @a false, disables the cost-based optimization of the given
 *                 query.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_distributed_joins: If @a
 *                 true, enables the use of distributed joins in servicing the
 *                 given query.  Any query requiring a distributed join will
 *                 succeed, though hints can be used in the query to change the
 *                 distribution of the source data to allow the query to
 *                 succeed.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_distributed_operations: If
 *                 @a true, enables the use of distributed operations in
 *                 servicing the given query.  Any query requiring a
 *                 distributed join will succeed, though hints can be used in
 *                 the query to change the distribution of the source data to
 *                 allow the query to succeed.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_ignore_existing_pk:
 *                 Specifies the record collision error-suppression policy for
 *                 inserting into or updating a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only
 *                 used when primary key record collisions are rejected (@a
 *                 update_on_existing_pk
 *                 is @a false).  If set to
 *                 @a true, any record insert/update that is rejected
 *                 for resulting in a primary key collision with an existing
 *                 table record will be ignored with no error
 *                 generated.  If @a false, the rejection of any
 *                 insert/update for resulting in a primary key collision will
 *                 cause an error to be reported.  If the
 *                 specified table does not have a primary key or if @a
 *                 update_on_existing_pk is
 *                 @a true, then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true: Ignore inserts/updates
 *                 that result in primary key collisions with existing records
 *                         <li> gpudb::execute_sql_false: Treat as errors any
 *                 inserts/updates that result in primary key collisions with
 *                 existing records
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_late_materialization: If @a
 *                 true, Joins/Filters results  will always be materialized (
 *                 saved to result tables format)
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_paging_table: When empty or
 *                 the specified paging table not exists, the system will
 *                 create a paging table and return when query output has more
 *                 records than the user asked. If the paging table exists in
 *                 the system, the records from the paging table are returned
 *                 without evaluating the query.
 *                         <li> gpudb::execute_sql_paging_table_ttl: Sets the
 *                 <a href="../../../concepts/ttl/" target="_top">TTL</a> of
 *                 the paging table.
 *                         <li> gpudb::execute_sql_parallel_execution: If @a
 *                 false, disables the parallel step execution of the given
 *                 query.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_plan_cache: If @a false,
 *                 disables plan caching for the given query.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_prepare_mode: If @a true,
 *                 compiles a query into an execution plan and saves it in
 *                 query cache. Query execution is not performed and an empty
 *                 response will be returned to user
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_preserve_dict_encoding: If
 *                 @a true, then columns that were dict encoded in the source
 *                 table will be dict encoded in the projection table.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_query_parameters: Query
 *                 parameters in JSON array or arrays (for inserting multiple
 *                 rows).  This can be used instead of @a data and @a
 *                 requestSchemaStr.
 *                         <li> gpudb::execute_sql_results_caching: If @a
 *                 false, disables caching of the results of the given query
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_rule_based_optimization: If
 *                 @a false, disables rule-based rewrite optimizations for the
 *                 given query
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_ssq_optimization: If @a
 *                 false, scalar subqueries will be translated into joins
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 intermediate result tables used in query execution.
 *                         <li> gpudb::execute_sql_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting into or
 *                 updating
 *                 a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>. If set to
 *                 @a true, any existing table record with primary
 *                 key values that match those of a record being inserted or
 *                 updated will be replaced by that record.
 *                 If set to @a false, any such primary key
 *                 collision will result in the insert/update being rejected
 *                 and the error handled as determined by
 *                 @a ignore_existing_pk.  If the specified table does not have
 *                 a primary key,
 *                 then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true: Replace the
 *                 collided-into record with the record inserted or updated
 *                 when a new/modified record causes a primary key collision
 *                 with an existing record
 *                         <li> gpudb::execute_sql_false: Reject the insert or
 *                 update when it results in a primary key collision with an
 *                 existing record
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_validate_change_column: When
 *                 changing a column using alter table, validate the change
 *                 before applying it. If @a true, then validate all values. A
 *                 value too large (or too long) for the new type will prevent
 *                 any change. If @a false, then when a value is too large or
 *                 long, it will be truncated.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_current_schema: Use the
 *                 supplied value as the <a
 *                 href="../../../concepts/schemas/#default-schema"
 *                 target="_top">default schema</a> when processing this SQL
 *                 command.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExecuteSqlResponse executeSql( const std::string& statement,
                               const int64_t offset,
                               const int64_t limit,
                               const std::string& requestSchemaStr,
                               const std::vector<std::vector<uint8_t> >& data,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Execute a SQL statement (query, DML, or DDL).
 * <p>
 * See <a href="../../../sql/" target="_top">SQL Support</a> for the complete
 * set of supported SQL commands.
 * 
 * @param statement  SQL statement (query, DML, or DDL) to be executed
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a hasMoreRecords to see if more records exist in the
 *               result to be fetched, and
 *               @a offset & @a limit to request subsequent pages of results.
 * @param requestSchemaStr  Avro schema of @a data.
 * @param data  An array of binary-encoded data for the records to be binded to
 *              the SQL query.  Or use @a query_parameters to pass the data in
 *              JSON format.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::execute_sql_cost_based_optimization: If
 *                 @a false, disables the cost-based optimization of the given
 *                 query.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_distributed_joins: If @a
 *                 true, enables the use of distributed joins in servicing the
 *                 given query.  Any query requiring a distributed join will
 *                 succeed, though hints can be used in the query to change the
 *                 distribution of the source data to allow the query to
 *                 succeed.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_distributed_operations: If
 *                 @a true, enables the use of distributed operations in
 *                 servicing the given query.  Any query requiring a
 *                 distributed join will succeed, though hints can be used in
 *                 the query to change the distribution of the source data to
 *                 allow the query to succeed.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_ignore_existing_pk:
 *                 Specifies the record collision error-suppression policy for
 *                 inserting into or updating a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only
 *                 used when primary key record collisions are rejected (@a
 *                 update_on_existing_pk
 *                 is @a false).  If set to
 *                 @a true, any record insert/update that is rejected
 *                 for resulting in a primary key collision with an existing
 *                 table record will be ignored with no error
 *                 generated.  If @a false, the rejection of any
 *                 insert/update for resulting in a primary key collision will
 *                 cause an error to be reported.  If the
 *                 specified table does not have a primary key or if @a
 *                 update_on_existing_pk is
 *                 @a true, then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true: Ignore inserts/updates
 *                 that result in primary key collisions with existing records
 *                         <li> gpudb::execute_sql_false: Treat as errors any
 *                 inserts/updates that result in primary key collisions with
 *                 existing records
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_late_materialization: If @a
 *                 true, Joins/Filters results  will always be materialized (
 *                 saved to result tables format)
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_paging_table: When empty or
 *                 the specified paging table not exists, the system will
 *                 create a paging table and return when query output has more
 *                 records than the user asked. If the paging table exists in
 *                 the system, the records from the paging table are returned
 *                 without evaluating the query.
 *                         <li> gpudb::execute_sql_paging_table_ttl: Sets the
 *                 <a href="../../../concepts/ttl/" target="_top">TTL</a> of
 *                 the paging table.
 *                         <li> gpudb::execute_sql_parallel_execution: If @a
 *                 false, disables the parallel step execution of the given
 *                 query.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_plan_cache: If @a false,
 *                 disables plan caching for the given query.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_prepare_mode: If @a true,
 *                 compiles a query into an execution plan and saves it in
 *                 query cache. Query execution is not performed and an empty
 *                 response will be returned to user
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_preserve_dict_encoding: If
 *                 @a true, then columns that were dict encoded in the source
 *                 table will be dict encoded in the projection table.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_query_parameters: Query
 *                 parameters in JSON array or arrays (for inserting multiple
 *                 rows).  This can be used instead of @a data and @a
 *                 requestSchemaStr.
 *                         <li> gpudb::execute_sql_results_caching: If @a
 *                 false, disables caching of the results of the given query
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_rule_based_optimization: If
 *                 @a false, disables rule-based rewrite optimizations for the
 *                 given query
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_ssq_optimization: If @a
 *                 false, scalar subqueries will be translated into joins
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 intermediate result tables used in query execution.
 *                         <li> gpudb::execute_sql_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting into or
 *                 updating
 *                 a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>. If set to
 *                 @a true, any existing table record with primary
 *                 key values that match those of a record being inserted or
 *                 updated will be replaced by that record.
 *                 If set to @a false, any such primary key
 *                 collision will result in the insert/update being rejected
 *                 and the error handled as determined by
 *                 @a ignore_existing_pk.  If the specified table does not have
 *                 a primary key,
 *                 then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true: Replace the
 *                 collided-into record with the record inserted or updated
 *                 when a new/modified record causes a primary key collision
 *                 with an existing record
 *                         <li> gpudb::execute_sql_false: Reject the insert or
 *                 update when it results in a primary key collision with an
 *                 existing record
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_validate_change_column: When
 *                 changing a column using alter table, validate the change
 *                 before applying it. If @a true, then validate all values. A
 *                 value too large (or too long) for the new type will prevent
 *                 any change. If @a false, then when a value is too large or
 *                 long, it will be truncated.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_current_schema: Use the
 *                 supplied value as the <a
 *                 href="../../../concepts/schemas/#default-schema"
 *                 target="_top">default schema</a> when processing this SQL
 *                 command.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExecuteSqlResponse& executeSql( const std::string& statement,
                                const int64_t offset,
                                const int64_t limit,
                                const std::string& requestSchemaStr,
                                const std::vector<std::vector<uint8_t> >& data,
                                const std::map<std::string, std::string>& options,
                                ExecuteSqlResponse& response_ ) const;

/**
 * Export records from a table to files. All tables can be exported, in full or
 * partial
 * (see @a columns_to_export and @a columns_to_skip).
 * Additional filtering can be applied when using export table with expression
 * through SQL.
 * Default destination is KIFS, though other storage types (Azure, S3, GCS, and
 * HDFS) are supported
 * through @a datasink_name; see {@link
 * #createDatasink(const CreateDatasinkRequest&) const}.
 * <p>
 * Server's local file system is not supported.  Default file format is
 * delimited text. See options for
 * different file types and different options for each file type.  Table is
 * saved to a single file if
 * within max file size limits (may vary depending on datasink type).  If not,
 * then table is split into
 * multiple files; these may be smaller than the max size limit.
 * <p>
 * All filenames created are returned in the response.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExportRecordsToFilesResponse exportRecordsToFiles( const ExportRecordsToFilesRequest& request_ ) const;

/**
 * Export records from a table to files. All tables can be exported, in full or
 * partial
 * (see @a columns_to_export and @a columns_to_skip).
 * Additional filtering can be applied when using export table with expression
 * through SQL.
 * Default destination is KIFS, though other storage types (Azure, S3, GCS, and
 * HDFS) are supported
 * through @a datasink_name; see {@link
 * #createDatasink(const CreateDatasinkRequest&,CreateDatasinkResponse&) const}.
 * <p>
 * Server's local file system is not supported.  Default file format is
 * delimited text. See options for
 * different file types and different options for each file type.  Table is
 * saved to a single file if
 * within max file size limits (may vary depending on datasink type).  If not,
 * then table is split into
 * multiple files; these may be smaller than the max size limit.
 * <p>
 * All filenames created are returned in the response.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExportRecordsToFilesResponse& exportRecordsToFiles( const ExportRecordsToFilesRequest& request_,
                                                    ExportRecordsToFilesResponse& response_ ) const;

/**
 * Export records from a table to files. All tables can be exported, in full or
 * partial
 * (see @a columns_to_export and @a columns_to_skip).
 * Additional filtering can be applied when using export table with expression
 * through SQL.
 * Default destination is KIFS, though other storage types (Azure, S3, GCS, and
 * HDFS) are supported
 * through @a datasink_name; see {@link
 * #createDatasink(const std::string&,const std::string&,const std::map<std::string, std::string>&) const}.
 * <p>
 * Server's local file system is not supported.  Default file format is
 * delimited text. See options for
 * different file types and different options for each file type.  Table is
 * saved to a single file if
 * within max file size limits (may vary depending on datasink type).  If not,
 * then table is split into
 * multiple files; these may be smaller than the max size limit.
 * <p>
 * All filenames created are returned in the response.
 * 
 * @param tableName
 * @param filepath  Path to data export target.  If @a filepath has a file
 *                  extension, it is
 *                  read as the name of a file. If @a filepath is a directory,
 *                  then the source table name with a
 *                  random UUID appended will be used as the name of each
 *                  exported file, all written to that directory.
 *                  If filepath is a filename, then all exported files will
 *                  have a random UUID appended to the given
 *                  name.  In either case, the target directory specified or
 *                  implied must exist.  The names of all
 *                  exported files are returned in the response.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::export_records_to_files_batch_size:
 *                 Number of records to be exported as a batch.  The default
 *                 value is '1000000'.
 *                         <li> gpudb::export_records_to_files_column_formats:
 *                 For each source column specified, applies the
 *                 column-property-bound
 *                 format.  Currently supported column properties include date,
 *                 time, & datetime. The parameter value
 *                 must be formatted as a JSON string of maps of column names
 *                 to maps of column properties to their
 *                 corresponding column formats, e.g.,
 *                 '{ "order_date" : { "date" : "%Y.%m.%d" }, "order_time" : {
 *                 "time" : "%H:%M:%S" } }'.
 *                 See @a default_column_formats for valid format syntax.
 *                         <li>
 *                 gpudb::export_records_to_files_columns_to_export: Specifies
 *                 a comma-delimited list of columns from the source table to
 *                 export, written to the output file in the order they are
 *                 given.
 *                 Column names can be provided, in which case the target file
 *                 will use those names as the column
 *                 headers as well.
 *                 Alternatively, column numbers can be specified--discretely
 *                 or as a range.  For example, a value of
 *                 '5,7,1..3' will write values from the fifth column in the
 *                 source table into the first column in the
 *                 target file, from the seventh column in the source table
 *                 into the second column in the target file,
 *                 and from the first through third columns in the source table
 *                 into the third through fifth columns in
 *                 the target file.
 *                 Mutually exclusive with @a columns_to_skip.
 *                         <li> gpudb::export_records_to_files_columns_to_skip:
 *                 Comma-separated list of column names or column numbers to
 *                 not
 *                 export.  All columns in the source table not specified will
 *                 be written to the target file in the
 *                 order they appear in the table definition.  Mutually
 *                 exclusive with
 *                 @a columns_to_export.
 *                         <li> gpudb::export_records_to_files_datasink_name:
 *                 Datasink name, created using /create/datasink.
 *                         <li>
 *                 gpudb::export_records_to_files_default_column_formats:
 *                 Specifies the default format to use to write data.
 *                 Currently
 *                 supported column properties include date, time, & datetime.
 *                 This default column-property-bound
 *                 format can be overridden by specifying a column property &
 *                 format for a given source column in
 *                 @a column_formats. For each specified annotation, the format
 *                 will apply to all
 *                 columns with that annotation unless custom @a column_formats
 *                 for that
 *                 annotation are specified.
 *                 The parameter value must be formatted as a JSON string that
 *                 is a map of column properties to their
 *                 respective column formats, e.g., '{ "date" : "%Y.%m.%d",
 *                 "time" : "%H:%M:%S" }'.  Column
 *                 formats are specified as a string of control characters and
 *                 plain text. The supported control
 *                 characters are 'Y', 'm', 'd', 'H', 'M', 'S', and 's', which
 *                 follow the Linux 'strptime()'
 *                 specification, as well as 's', which specifies seconds and
 *                 fractional seconds (though the fractional
 *                 component will be truncated past milliseconds).
 *                 Formats for the 'date' annotation must include the 'Y', 'm',
 *                 and 'd' control characters. Formats for
 *                 the 'time' annotation must include the 'H', 'M', and either
 *                 'S' or 's' (but not both) control
 *                 characters. Formats for the 'datetime' annotation meet both
 *                 the 'date' and 'time' control character
 *                 requirements. For example, '{"datetime" : "%m/%d/%Y
 *                 %H:%M:%S" }' would be used to write text
 *                 as "05/04/2000 12:12:11"
 *                         <li> gpudb::export_records_to_files_export_ddl: Save
 *                 DDL to a separate file.  The default value is 'false'.
 *                         <li> gpudb::export_records_to_files_file_extension:
 *                 Extension to give the export file.  The default value is
 *                 '.csv'.
 *                         <li> gpudb::export_records_to_files_file_type:
 *                 Specifies the file format to use when exporting data.
 *                 <ul>
 *                         <li> gpudb::export_records_to_files_delimited_text:
 *                 Delimited text file format; e.g., CSV, TSV, PSV, etc.
 *                         <li> gpudb::export_records_to_files_parquet
 *                 </ul>
 *                 The default value is
 *                 gpudb::export_records_to_files_delimited_text.
 *                         <li> gpudb::export_records_to_files_kinetica_header:
 *                 Whether to include a Kinetica proprietary header. Will not
 *                 be
 *                 written if @a text_has_header is
 *                 @a false.
 *                 <ul>
 *                         <li> gpudb::export_records_to_files_true
 *                         <li> gpudb::export_records_to_files_false
 *                 </ul>
 *                 The default value is gpudb::export_records_to_files_false.
 *                         <li>
 *                 gpudb::export_records_to_files_kinetica_header_delimiter: If
 *                 a Kinetica proprietary header is included, then specify a
 *                 property separator. Different from column delimiter.  The
 *                 default value is '|'.
 *                         <li>
 *                 gpudb::export_records_to_files_compression_type: File
 *                 compression type. GZip can be applied to text and Parquet
 *                 files.  Snappy can only be applied to Parquet files, and is
 *                 the default compression for them.
 *                 <ul>
 *                         <li> gpudb::export_records_to_files_uncompressed
 *                         <li> gpudb::export_records_to_files_snappy
 *                         <li> gpudb::export_records_to_files_gzip
 *                 </ul>
 *                         <li> gpudb::export_records_to_files_single_file:
 *                 Save records to a single file. This option may be ignored if
 *                 file
 *                 size exceeds internal file size limits (this limit will
 *                 differ on different targets).
 *                 <ul>
 *                         <li> gpudb::export_records_to_files_true
 *                         <li> gpudb::export_records_to_files_false
 *                         <li> gpudb::export_records_to_files_overwrite
 *                 </ul>
 *                 The default value is gpudb::export_records_to_files_true.
 *                         <li> gpudb::export_records_to_files_text_delimiter:
 *                 Specifies the character to write out to delimit field values
 *                 and
 *                 field names in the header (if present).
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is ','.
 *                         <li> gpudb::export_records_to_files_text_has_header:
 *                 Indicates whether to write out a header row.
 *                 For @a delimited_text @a file_type only.
 *                 <ul>
 *                         <li> gpudb::export_records_to_files_true
 *                         <li> gpudb::export_records_to_files_false
 *                 </ul>
 *                 The default value is gpudb::export_records_to_files_true.
 *                         <li>
 *                 gpudb::export_records_to_files_text_null_string: Specifies
 *                 the character string that should be written out for the null
 *                 value in the data.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '\\N'.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExportRecordsToFilesResponse exportRecordsToFiles( const std::string& tableName,
                                                   const std::string& filepath,
                                                   const std::map<std::string, std::string>& options ) const;

/**
 * Export records from a table to files. All tables can be exported, in full or
 * partial
 * (see @a columns_to_export and @a columns_to_skip).
 * Additional filtering can be applied when using export table with expression
 * through SQL.
 * Default destination is KIFS, though other storage types (Azure, S3, GCS, and
 * HDFS) are supported
 * through @a datasink_name; see {@link
 * #createDatasink(const std::string&,const std::string&,const std::map<std::string, std::string>&,CreateDatasinkResponse&) const}.
 * <p>
 * Server's local file system is not supported.  Default file format is
 * delimited text. See options for
 * different file types and different options for each file type.  Table is
 * saved to a single file if
 * within max file size limits (may vary depending on datasink type).  If not,
 * then table is split into
 * multiple files; these may be smaller than the max size limit.
 * <p>
 * All filenames created are returned in the response.
 * 
 * @param tableName
 * @param filepath  Path to data export target.  If @a filepath has a file
 *                  extension, it is
 *                  read as the name of a file. If @a filepath is a directory,
 *                  then the source table name with a
 *                  random UUID appended will be used as the name of each
 *                  exported file, all written to that directory.
 *                  If filepath is a filename, then all exported files will
 *                  have a random UUID appended to the given
 *                  name.  In either case, the target directory specified or
 *                  implied must exist.  The names of all
 *                  exported files are returned in the response.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::export_records_to_files_batch_size:
 *                 Number of records to be exported as a batch.  The default
 *                 value is '1000000'.
 *                         <li> gpudb::export_records_to_files_column_formats:
 *                 For each source column specified, applies the
 *                 column-property-bound
 *                 format.  Currently supported column properties include date,
 *                 time, & datetime. The parameter value
 *                 must be formatted as a JSON string of maps of column names
 *                 to maps of column properties to their
 *                 corresponding column formats, e.g.,
 *                 '{ "order_date" : { "date" : "%Y.%m.%d" }, "order_time" : {
 *                 "time" : "%H:%M:%S" } }'.
 *                 See @a default_column_formats for valid format syntax.
 *                         <li>
 *                 gpudb::export_records_to_files_columns_to_export: Specifies
 *                 a comma-delimited list of columns from the source table to
 *                 export, written to the output file in the order they are
 *                 given.
 *                 Column names can be provided, in which case the target file
 *                 will use those names as the column
 *                 headers as well.
 *                 Alternatively, column numbers can be specified--discretely
 *                 or as a range.  For example, a value of
 *                 '5,7,1..3' will write values from the fifth column in the
 *                 source table into the first column in the
 *                 target file, from the seventh column in the source table
 *                 into the second column in the target file,
 *                 and from the first through third columns in the source table
 *                 into the third through fifth columns in
 *                 the target file.
 *                 Mutually exclusive with @a columns_to_skip.
 *                         <li> gpudb::export_records_to_files_columns_to_skip:
 *                 Comma-separated list of column names or column numbers to
 *                 not
 *                 export.  All columns in the source table not specified will
 *                 be written to the target file in the
 *                 order they appear in the table definition.  Mutually
 *                 exclusive with
 *                 @a columns_to_export.
 *                         <li> gpudb::export_records_to_files_datasink_name:
 *                 Datasink name, created using /create/datasink.
 *                         <li>
 *                 gpudb::export_records_to_files_default_column_formats:
 *                 Specifies the default format to use to write data.
 *                 Currently
 *                 supported column properties include date, time, & datetime.
 *                 This default column-property-bound
 *                 format can be overridden by specifying a column property &
 *                 format for a given source column in
 *                 @a column_formats. For each specified annotation, the format
 *                 will apply to all
 *                 columns with that annotation unless custom @a column_formats
 *                 for that
 *                 annotation are specified.
 *                 The parameter value must be formatted as a JSON string that
 *                 is a map of column properties to their
 *                 respective column formats, e.g., '{ "date" : "%Y.%m.%d",
 *                 "time" : "%H:%M:%S" }'.  Column
 *                 formats are specified as a string of control characters and
 *                 plain text. The supported control
 *                 characters are 'Y', 'm', 'd', 'H', 'M', 'S', and 's', which
 *                 follow the Linux 'strptime()'
 *                 specification, as well as 's', which specifies seconds and
 *                 fractional seconds (though the fractional
 *                 component will be truncated past milliseconds).
 *                 Formats for the 'date' annotation must include the 'Y', 'm',
 *                 and 'd' control characters. Formats for
 *                 the 'time' annotation must include the 'H', 'M', and either
 *                 'S' or 's' (but not both) control
 *                 characters. Formats for the 'datetime' annotation meet both
 *                 the 'date' and 'time' control character
 *                 requirements. For example, '{"datetime" : "%m/%d/%Y
 *                 %H:%M:%S" }' would be used to write text
 *                 as "05/04/2000 12:12:11"
 *                         <li> gpudb::export_records_to_files_export_ddl: Save
 *                 DDL to a separate file.  The default value is 'false'.
 *                         <li> gpudb::export_records_to_files_file_extension:
 *                 Extension to give the export file.  The default value is
 *                 '.csv'.
 *                         <li> gpudb::export_records_to_files_file_type:
 *                 Specifies the file format to use when exporting data.
 *                 <ul>
 *                         <li> gpudb::export_records_to_files_delimited_text:
 *                 Delimited text file format; e.g., CSV, TSV, PSV, etc.
 *                         <li> gpudb::export_records_to_files_parquet
 *                 </ul>
 *                 The default value is
 *                 gpudb::export_records_to_files_delimited_text.
 *                         <li> gpudb::export_records_to_files_kinetica_header:
 *                 Whether to include a Kinetica proprietary header. Will not
 *                 be
 *                 written if @a text_has_header is
 *                 @a false.
 *                 <ul>
 *                         <li> gpudb::export_records_to_files_true
 *                         <li> gpudb::export_records_to_files_false
 *                 </ul>
 *                 The default value is gpudb::export_records_to_files_false.
 *                         <li>
 *                 gpudb::export_records_to_files_kinetica_header_delimiter: If
 *                 a Kinetica proprietary header is included, then specify a
 *                 property separator. Different from column delimiter.  The
 *                 default value is '|'.
 *                         <li>
 *                 gpudb::export_records_to_files_compression_type: File
 *                 compression type. GZip can be applied to text and Parquet
 *                 files.  Snappy can only be applied to Parquet files, and is
 *                 the default compression for them.
 *                 <ul>
 *                         <li> gpudb::export_records_to_files_uncompressed
 *                         <li> gpudb::export_records_to_files_snappy
 *                         <li> gpudb::export_records_to_files_gzip
 *                 </ul>
 *                         <li> gpudb::export_records_to_files_single_file:
 *                 Save records to a single file. This option may be ignored if
 *                 file
 *                 size exceeds internal file size limits (this limit will
 *                 differ on different targets).
 *                 <ul>
 *                         <li> gpudb::export_records_to_files_true
 *                         <li> gpudb::export_records_to_files_false
 *                         <li> gpudb::export_records_to_files_overwrite
 *                 </ul>
 *                 The default value is gpudb::export_records_to_files_true.
 *                         <li> gpudb::export_records_to_files_text_delimiter:
 *                 Specifies the character to write out to delimit field values
 *                 and
 *                 field names in the header (if present).
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is ','.
 *                         <li> gpudb::export_records_to_files_text_has_header:
 *                 Indicates whether to write out a header row.
 *                 For @a delimited_text @a file_type only.
 *                 <ul>
 *                         <li> gpudb::export_records_to_files_true
 *                         <li> gpudb::export_records_to_files_false
 *                 </ul>
 *                 The default value is gpudb::export_records_to_files_true.
 *                         <li>
 *                 gpudb::export_records_to_files_text_null_string: Specifies
 *                 the character string that should be written out for the null
 *                 value in the data.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '\\N'.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExportRecordsToFilesResponse& exportRecordsToFiles( const std::string& tableName,
                                                    const std::string& filepath,
                                                    const std::map<std::string, std::string>& options,
                                                    ExportRecordsToFilesResponse& response_ ) const;

/**
 * Exports records from source table to the specified target table in an
 * external database
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExportRecordsToTableResponse exportRecordsToTable( const ExportRecordsToTableRequest& request_ ) const;

/**
 * Exports records from source table to the specified target table in an
 * external database
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExportRecordsToTableResponse& exportRecordsToTable( const ExportRecordsToTableRequest& request_,
                                                    ExportRecordsToTableResponse& response_ ) const;

/**
 * Exports records from source table to the specified target table in an
 * external database
 * 
 * @param tableName  Name of the table from which the data will be exported to
 *                   remote database, in
 *                   [schema_name.]table_name format, using standard
 *                   <a href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param remoteQuery  Parameterized insert query to export gpudb table data
 *                     into remote database
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::export_records_to_table_batch_size:
 *                 Batch size, which determines how many rows to export per
 *                 round trip.  The default value is '200000'.
 *                         <li> gpudb::export_records_to_table_datasink_name:
 *                 Name of an existing external data sink to which table name
 *                 specified in @a tableName will be exported
 *                         <li>
 *                 gpudb::export_records_to_table_jdbc_session_init_statement:
 *                 Executes the statement per each jdbc session before doing
 *                 actual load.  The default value is ''.
 *                         <li>
 *                 gpudb::export_records_to_table_jdbc_connection_init_statement:
 *                 Executes the statement once before doing actual load.  The
 *                 default value is ''.
 *                         <li> gpudb::export_records_to_table_remote_table:
 *                 Name of the target table to which source table is exported.
 *                 When this option is specified remote_query cannot be
 *                 specified.  The default value is ''.
 *                         <li>
 *                 gpudb::export_records_to_table_use_st_geomfrom_casts: Wraps
 *                 parametrized variables with st_geomfromtext or
 *                 st_geomfromwkb based on source column type
 *                 <ul>
 *                         <li> gpudb::export_records_to_table_true
 *                         <li> gpudb::export_records_to_table_false
 *                 </ul>
 *                 The default value is gpudb::export_records_to_table_false.
 *                         <li>
 *                 gpudb::export_records_to_table_use_indexed_parameters: Uses
 *                 $n style syntax when generating insert query for
 *                 remote_table option
 *                 <ul>
 *                         <li> gpudb::export_records_to_table_true
 *                         <li> gpudb::export_records_to_table_false
 *                 </ul>
 *                 The default value is gpudb::export_records_to_table_true.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExportRecordsToTableResponse exportRecordsToTable( const std::string& tableName,
                                                   const std::string& remoteQuery,
                                                   const std::map<std::string, std::string>& options ) const;

/**
 * Exports records from source table to the specified target table in an
 * external database
 * 
 * @param tableName  Name of the table from which the data will be exported to
 *                   remote database, in
 *                   [schema_name.]table_name format, using standard
 *                   <a href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param remoteQuery  Parameterized insert query to export gpudb table data
 *                     into remote database
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::export_records_to_table_batch_size:
 *                 Batch size, which determines how many rows to export per
 *                 round trip.  The default value is '200000'.
 *                         <li> gpudb::export_records_to_table_datasink_name:
 *                 Name of an existing external data sink to which table name
 *                 specified in @a tableName will be exported
 *                         <li>
 *                 gpudb::export_records_to_table_jdbc_session_init_statement:
 *                 Executes the statement per each jdbc session before doing
 *                 actual load.  The default value is ''.
 *                         <li>
 *                 gpudb::export_records_to_table_jdbc_connection_init_statement:
 *                 Executes the statement once before doing actual load.  The
 *                 default value is ''.
 *                         <li> gpudb::export_records_to_table_remote_table:
 *                 Name of the target table to which source table is exported.
 *                 When this option is specified remote_query cannot be
 *                 specified.  The default value is ''.
 *                         <li>
 *                 gpudb::export_records_to_table_use_st_geomfrom_casts: Wraps
 *                 parametrized variables with st_geomfromtext or
 *                 st_geomfromwkb based on source column type
 *                 <ul>
 *                         <li> gpudb::export_records_to_table_true
 *                         <li> gpudb::export_records_to_table_false
 *                 </ul>
 *                 The default value is gpudb::export_records_to_table_false.
 *                         <li>
 *                 gpudb::export_records_to_table_use_indexed_parameters: Uses
 *                 $n style syntax when generating insert query for
 *                 remote_table option
 *                 <ul>
 *                         <li> gpudb::export_records_to_table_true
 *                         <li> gpudb::export_records_to_table_false
 *                 </ul>
 *                 The default value is gpudb::export_records_to_table_true.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExportRecordsToTableResponse& exportRecordsToTable( const std::string& tableName,
                                                    const std::string& remoteQuery,
                                                    const std::map<std::string, std::string>& options,
                                                    ExportRecordsToTableResponse& response_ ) const;

/**
 * Filters data based on the specified expression.  The results are
 * stored in a <a href="../../../concepts/filtered_views/" target="_top">result
 * set</a> with the
 * given @a viewName.
 * <p>
 * For details see <a href="../../../concepts/expressions/"
 * target="_top">Expressions</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterResponse filter( const FilterRequest& request_ ) const;

/**
 * Filters data based on the specified expression.  The results are
 * stored in a <a href="../../../concepts/filtered_views/" target="_top">result
 * set</a> with the
 * given @a viewName.
 * <p>
 * For details see <a href="../../../concepts/expressions/"
 * target="_top">Expressions</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterResponse& filter( const FilterRequest& request_,
                        FilterResponse& response_ ) const;

/**
 * Filters data based on the specified expression.  The results are
 * stored in a <a href="../../../concepts/filtered_views/" target="_top">result
 * set</a> with the
 * given @a viewName.
 * <p>
 * For details see <a href="../../../concepts/expressions/"
 * target="_top">Expressions</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param tableName  Name of the table to filter, in [schema_name.]table_name
 *                   format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  This may be the
 *                   name of a table or a view (when chaining queries).
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param expression  The select expression to filter the specified table.  For
 *                    details see <a href="../../../concepts/expressions/"
 *                    target="_top">Expressions</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_create_temp_table: If @a true, a
 *                 unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_true
 *                         <li> gpudb::filter_false
 *                 </ul>
 *                 The default value is gpudb::filter_false.
 *                         <li> gpudb::filter_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                         <li> gpudb::filter_view_id: view this filtered-view
 *                 is part of.  The default value is ''.
 *                         <li> gpudb::filter_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 view specified in @a viewName.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterResponse filter( const std::string& tableName,
                       const std::string& viewName,
                       const std::string& expression,
                       const std::map<std::string, std::string>& options ) const;

/**
 * Filters data based on the specified expression.  The results are
 * stored in a <a href="../../../concepts/filtered_views/" target="_top">result
 * set</a> with the
 * given @a viewName.
 * <p>
 * For details see <a href="../../../concepts/expressions/"
 * target="_top">Expressions</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param tableName  Name of the table to filter, in [schema_name.]table_name
 *                   format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  This may be the
 *                   name of a table or a view (when chaining queries).
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param expression  The select expression to filter the specified table.  For
 *                    details see <a href="../../../concepts/expressions/"
 *                    target="_top">Expressions</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_create_temp_table: If @a true, a
 *                 unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_true
 *                         <li> gpudb::filter_false
 *                 </ul>
 *                 The default value is gpudb::filter_false.
 *                         <li> gpudb::filter_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                         <li> gpudb::filter_view_id: view this filtered-view
 *                 is part of.  The default value is ''.
 *                         <li> gpudb::filter_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 view specified in @a viewName.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterResponse& filter( const std::string& tableName,
                        const std::string& viewName,
                        const std::string& expression,
                        const std::map<std::string, std::string>& options,
                        FilterResponse& response_ ) const;

/**
 * Calculates which objects from a table are within a named area of
 * interest (NAI/polygon). The operation is synchronous, meaning that a
 * response
 * will not be returned until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set
 * (view) which satisfies the input NAI restriction specification is created
 * with
 * the name @a viewName passed in as part of the input.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByAreaResponse filterByArea( const FilterByAreaRequest& request_ ) const;

/**
 * Calculates which objects from a table are within a named area of
 * interest (NAI/polygon). The operation is synchronous, meaning that a
 * response
 * will not be returned until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set
 * (view) which satisfies the input NAI restriction specification is created
 * with
 * the name @a viewName passed in as part of the input.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByAreaResponse& filterByArea( const FilterByAreaRequest& request_,
                                    FilterByAreaResponse& response_ ) const;

/**
 * Calculates which objects from a table are within a named area of
 * interest (NAI/polygon). The operation is synchronous, meaning that a
 * response
 * will not be returned until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set
 * (view) which satisfies the input NAI restriction specification is created
 * with
 * the name @a viewName passed in as part of the input.
 * 
 * @param tableName  Name of the table to filter, in [schema_name.]table_name
 *                   format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  This may be the
 *                   name of a table or a view (when chaining queries).
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param xColumnName  Name of the column containing the x values to be
 *                     filtered.
 * @param xVector  List of x coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param yColumnName  Name of the column containing the y values to be
 *                     filtered.
 * @param yVector  List of y coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_area_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_area_true
 *                         <li> gpudb::filter_by_area_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_area_false.
 *                         <li> gpudb::filter_by_area_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema provided is non-existent, it
 *                 will be automatically created.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByAreaResponse filterByArea( const std::string& tableName,
                                   const std::string& viewName,
                                   const std::string& xColumnName,
                                   const std::vector<double>& xVector,
                                   const std::string& yColumnName,
                                   const std::vector<double>& yVector,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which objects from a table are within a named area of
 * interest (NAI/polygon). The operation is synchronous, meaning that a
 * response
 * will not be returned until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set
 * (view) which satisfies the input NAI restriction specification is created
 * with
 * the name @a viewName passed in as part of the input.
 * 
 * @param tableName  Name of the table to filter, in [schema_name.]table_name
 *                   format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  This may be the
 *                   name of a table or a view (when chaining queries).
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param xColumnName  Name of the column containing the x values to be
 *                     filtered.
 * @param xVector  List of x coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param yColumnName  Name of the column containing the y values to be
 *                     filtered.
 * @param yVector  List of y coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_area_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_area_true
 *                         <li> gpudb::filter_by_area_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_area_false.
 *                         <li> gpudb::filter_by_area_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema provided is non-existent, it
 *                 will be automatically created.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByAreaResponse& filterByArea( const std::string& tableName,
                                    const std::string& viewName,
                                    const std::string& xColumnName,
                                    const std::vector<double>& xVector,
                                    const std::string& yColumnName,
                                    const std::vector<double>& yVector,
                                    const std::map<std::string, std::string>& options,
                                    FilterByAreaResponse& response_ ) const;

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a named area of interest (NAI/polygon). The operation is synchronous,
 * meaning
 * that a response will not be returned until all the matching objects are
 * fully
 * available. The response payload provides the count of the resulting set. A
 * new
 * resultant set (view) which satisfies the input NAI restriction specification
 * is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByAreaGeometryResponse filterByAreaGeometry( const FilterByAreaGeometryRequest& request_ ) const;

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a named area of interest (NAI/polygon). The operation is synchronous,
 * meaning
 * that a response will not be returned until all the matching objects are
 * fully
 * available. The response payload provides the count of the resulting set. A
 * new
 * resultant set (view) which satisfies the input NAI restriction specification
 * is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByAreaGeometryResponse& filterByAreaGeometry( const FilterByAreaGeometryRequest& request_,
                                                    FilterByAreaGeometryResponse& response_ ) const;

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a named area of interest (NAI/polygon). The operation is synchronous,
 * meaning
 * that a response will not be returned until all the matching objects are
 * fully
 * available. The response payload provides the count of the resulting set. A
 * new
 * resultant set (view) which satisfies the input NAI restriction specification
 * is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param tableName  Name of the table to filter, in [schema_name.]table_name
 *                   format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  This may be the
 *                   name of a table or a view (when chaining queries).
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param columnName  Name of the geospatial geometry column to be filtered.
 * @param xVector  List of x coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param yVector  List of y coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::filter_by_area_geometry_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_area_geometry_true
 *                         <li> gpudb::filter_by_area_geometry_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_area_geometry_false.
 *                         <li> gpudb::filter_by_area_geometry_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  The schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByAreaGeometryResponse filterByAreaGeometry( const std::string& tableName,
                                                   const std::string& viewName,
                                                   const std::string& columnName,
                                                   const std::vector<double>& xVector,
                                                   const std::vector<double>& yVector,
                                                   const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a named area of interest (NAI/polygon). The operation is synchronous,
 * meaning
 * that a response will not be returned until all the matching objects are
 * fully
 * available. The response payload provides the count of the resulting set. A
 * new
 * resultant set (view) which satisfies the input NAI restriction specification
 * is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param tableName  Name of the table to filter, in [schema_name.]table_name
 *                   format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  This may be the
 *                   name of a table or a view (when chaining queries).
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param columnName  Name of the geospatial geometry column to be filtered.
 * @param xVector  List of x coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param yVector  List of y coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::filter_by_area_geometry_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_area_geometry_true
 *                         <li> gpudb::filter_by_area_geometry_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_area_geometry_false.
 *                         <li> gpudb::filter_by_area_geometry_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  The schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByAreaGeometryResponse& filterByAreaGeometry( const std::string& tableName,
                                                    const std::string& viewName,
                                                    const std::string& columnName,
                                                    const std::vector<double>& xVector,
                                                    const std::vector<double>& yVector,
                                                    const std::map<std::string, std::string>& options,
                                                    FilterByAreaGeometryResponse& response_ ) const;

/**
 * Calculates how many objects within the given table lie in a
 * rectangular box. The operation is synchronous, meaning that a response will
 * not
 * be returned until all the objects are fully available. The response payload
 * provides the count of the resulting set. A new resultant set which satisfies
 * the
 * input NAI restriction specification is also created when a @a viewName is
 * passed in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByBoxResponse filterByBox( const FilterByBoxRequest& request_ ) const;

/**
 * Calculates how many objects within the given table lie in a
 * rectangular box. The operation is synchronous, meaning that a response will
 * not
 * be returned until all the objects are fully available. The response payload
 * provides the count of the resulting set. A new resultant set which satisfies
 * the
 * input NAI restriction specification is also created when a @a viewName is
 * passed in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByBoxResponse& filterByBox( const FilterByBoxRequest& request_,
                                  FilterByBoxResponse& response_ ) const;

/**
 * Calculates how many objects within the given table lie in a
 * rectangular box. The operation is synchronous, meaning that a response will
 * not
 * be returned until all the objects are fully available. The response payload
 * provides the count of the resulting set. A new resultant set which satisfies
 * the
 * input NAI restriction specification is also created when a @a viewName is
 * passed in as part of the input payload.
 * 
 * @param tableName  Name of the table on which the bounding box operation will
 *                   be performed, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param xColumnName  Name of the column on which to perform the bounding box
 *                     query. Must be a valid numeric column.
 * @param minX  Lower bound for the column chosen by @a xColumnName.  Must be
 *              less than or equal to @a maxX.
 * @param maxX  Upper bound for @a xColumnName.  Must be greater than or equal
 *              to @a minX.
 * @param yColumnName  Name of a column on which to perform the bounding box
 *                     query. Must be a valid numeric column.
 * @param minY  Lower bound for @a yColumnName. Must be less than or equal to
 *              @a maxY.
 * @param maxY  Upper bound for @a yColumnName. Must be greater than or equal
 *              to @a minY.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_box_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_box_true
 *                         <li> gpudb::filter_by_box_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_box_false.
 *                         <li> gpudb::filter_by_box_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByBoxResponse filterByBox( const std::string& tableName,
                                 const std::string& viewName,
                                 const std::string& xColumnName,
                                 const double minX,
                                 const double maxX,
                                 const std::string& yColumnName,
                                 const double minY,
                                 const double maxY,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Calculates how many objects within the given table lie in a
 * rectangular box. The operation is synchronous, meaning that a response will
 * not
 * be returned until all the objects are fully available. The response payload
 * provides the count of the resulting set. A new resultant set which satisfies
 * the
 * input NAI restriction specification is also created when a @a viewName is
 * passed in as part of the input payload.
 * 
 * @param tableName  Name of the table on which the bounding box operation will
 *                   be performed, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param xColumnName  Name of the column on which to perform the bounding box
 *                     query. Must be a valid numeric column.
 * @param minX  Lower bound for the column chosen by @a xColumnName.  Must be
 *              less than or equal to @a maxX.
 * @param maxX  Upper bound for @a xColumnName.  Must be greater than or equal
 *              to @a minX.
 * @param yColumnName  Name of a column on which to perform the bounding box
 *                     query. Must be a valid numeric column.
 * @param minY  Lower bound for @a yColumnName. Must be less than or equal to
 *              @a maxY.
 * @param maxY  Upper bound for @a yColumnName. Must be greater than or equal
 *              to @a minY.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_box_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_box_true
 *                         <li> gpudb::filter_by_box_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_box_false.
 *                         <li> gpudb::filter_by_box_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByBoxResponse& filterByBox( const std::string& tableName,
                                  const std::string& viewName,
                                  const std::string& xColumnName,
                                  const double minX,
                                  const double maxX,
                                  const std::string& yColumnName,
                                  const double minY,
                                  const double maxY,
                                  const std::map<std::string, std::string>& options,
                                  FilterByBoxResponse& response_ ) const;

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a rectangular box. The operation is synchronous, meaning that a response
 * will
 * not be returned until all the objects are fully available. The response
 * payload
 * provides the count of the resulting set. A new resultant set which satisfies
 * the
 * input NAI restriction specification is also created when a @a viewName is
 * passed in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByBoxGeometryResponse filterByBoxGeometry( const FilterByBoxGeometryRequest& request_ ) const;

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a rectangular box. The operation is synchronous, meaning that a response
 * will
 * not be returned until all the objects are fully available. The response
 * payload
 * provides the count of the resulting set. A new resultant set which satisfies
 * the
 * input NAI restriction specification is also created when a @a viewName is
 * passed in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByBoxGeometryResponse& filterByBoxGeometry( const FilterByBoxGeometryRequest& request_,
                                                  FilterByBoxGeometryResponse& response_ ) const;

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a rectangular box. The operation is synchronous, meaning that a response
 * will
 * not be returned until all the objects are fully available. The response
 * payload
 * provides the count of the resulting set. A new resultant set which satisfies
 * the
 * input NAI restriction specification is also created when a @a viewName is
 * passed in as part of the input payload.
 * 
 * @param tableName  Name of the table on which the bounding box operation will
 *                   be performed, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>. Must be an
 *                   existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param columnName  Name of the geospatial geometry column to be filtered.
 * @param minX  Lower bound for the x-coordinate of the rectangular box.  Must
 *              be less than or equal to @a maxX.
 * @param maxX  Upper bound for the x-coordinate of the rectangular box.  Must
 *              be greater than or equal to @a minX.
 * @param minY  Lower bound for the y-coordinate of the rectangular box. Must
 *              be less than or equal to @a maxY.
 * @param maxY  Upper bound for the y-coordinate of the rectangular box. Must
 *              be greater than or equal to @a minY.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::filter_by_box_geometry_create_temp_table: If @a true,
 *                 a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_box_geometry_true
 *                         <li> gpudb::filter_by_box_geometry_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_box_geometry_false.
 *                         <li> gpudb::filter_by_box_geometry_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema provided is non-existent, it
 *                 will be automatically created.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByBoxGeometryResponse filterByBoxGeometry( const std::string& tableName,
                                                 const std::string& viewName,
                                                 const std::string& columnName,
                                                 const double minX,
                                                 const double maxX,
                                                 const double minY,
                                                 const double maxY,
                                                 const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a rectangular box. The operation is synchronous, meaning that a response
 * will
 * not be returned until all the objects are fully available. The response
 * payload
 * provides the count of the resulting set. A new resultant set which satisfies
 * the
 * input NAI restriction specification is also created when a @a viewName is
 * passed in as part of the input payload.
 * 
 * @param tableName  Name of the table on which the bounding box operation will
 *                   be performed, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>. Must be an
 *                   existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param columnName  Name of the geospatial geometry column to be filtered.
 * @param minX  Lower bound for the x-coordinate of the rectangular box.  Must
 *              be less than or equal to @a maxX.
 * @param maxX  Upper bound for the x-coordinate of the rectangular box.  Must
 *              be greater than or equal to @a minX.
 * @param minY  Lower bound for the y-coordinate of the rectangular box. Must
 *              be less than or equal to @a maxY.
 * @param maxY  Upper bound for the y-coordinate of the rectangular box. Must
 *              be greater than or equal to @a minY.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::filter_by_box_geometry_create_temp_table: If @a true,
 *                 a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_box_geometry_true
 *                         <li> gpudb::filter_by_box_geometry_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_box_geometry_false.
 *                         <li> gpudb::filter_by_box_geometry_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema provided is non-existent, it
 *                 will be automatically created.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByBoxGeometryResponse& filterByBoxGeometry( const std::string& tableName,
                                                  const std::string& viewName,
                                                  const std::string& columnName,
                                                  const double minX,
                                                  const double maxX,
                                                  const double minY,
                                                  const double maxY,
                                                  const std::map<std::string, std::string>& options,
                                                  FilterByBoxGeometryResponse& response_ ) const;

/**
 * Applies a geometry filter against a geospatial geometry column in a
 * given table or view. The filtering geometry is provided by @a inputWkt.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByGeometryResponse filterByGeometry( const FilterByGeometryRequest& request_ ) const;

/**
 * Applies a geometry filter against a geospatial geometry column in a
 * given table or view. The filtering geometry is provided by @a inputWkt.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByGeometryResponse& filterByGeometry( const FilterByGeometryRequest& request_,
                                            FilterByGeometryResponse& response_ ) const;

/**
 * Applies a geometry filter against a geospatial geometry column in a
 * given table or view. The filtering geometry is provided by @a inputWkt.
 * 
 * @param tableName  Name of the table on which the filter by geometry will be
 *                   performed, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table or view containing a geospatial geometry
 *                   column.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param columnName  Name of the column to be used in the filter. Must be a
 *                    geospatial geometry column.
 * @param inputWkt  A geometry in WKT format that will be used to filter the
 *                  objects in @a tableName.
 * @param operation  The geometric filtering operation to perform
 *                   <ul>
 *                           <li> gpudb::filter_by_geometry_contains: Matches
 *                   records that contain the given WKT in @a inputWkt, i.e.
 *                   the given WKT is within the bounds of a record's geometry.
 *                           <li> gpudb::filter_by_geometry_crosses: Matches
 *                   records that cross the given WKT.
 *                           <li> gpudb::filter_by_geometry_disjoint: Matches
 *                   records that are disjoint from the given WKT.
 *                           <li> gpudb::filter_by_geometry_equals: Matches
 *                   records that are the same as the given WKT.
 *                           <li> gpudb::filter_by_geometry_intersects: Matches
 *                   records that intersect the given WKT.
 *                           <li> gpudb::filter_by_geometry_overlaps: Matches
 *                   records that overlap the given WKT.
 *                           <li> gpudb::filter_by_geometry_touches: Matches
 *                   records that touch the given WKT.
 *                           <li> gpudb::filter_by_geometry_within: Matches
 *                   records that are within the given WKT.
 *                   </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_geometry_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a viewName. This
 *                 is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_geometry_true
 *                         <li> gpudb::filter_by_geometry_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_geometry_false.
 *                         <li> gpudb::filter_by_geometry_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema provided is non-existent, it
 *                 will be automatically created.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByGeometryResponse filterByGeometry( const std::string& tableName,
                                           const std::string& viewName,
                                           const std::string& columnName,
                                           const std::string& inputWkt,
                                           const std::string& operation,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * Applies a geometry filter against a geospatial geometry column in a
 * given table or view. The filtering geometry is provided by @a inputWkt.
 * 
 * @param tableName  Name of the table on which the filter by geometry will be
 *                   performed, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table or view containing a geospatial geometry
 *                   column.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param columnName  Name of the column to be used in the filter. Must be a
 *                    geospatial geometry column.
 * @param inputWkt  A geometry in WKT format that will be used to filter the
 *                  objects in @a tableName.
 * @param operation  The geometric filtering operation to perform
 *                   <ul>
 *                           <li> gpudb::filter_by_geometry_contains: Matches
 *                   records that contain the given WKT in @a inputWkt, i.e.
 *                   the given WKT is within the bounds of a record's geometry.
 *                           <li> gpudb::filter_by_geometry_crosses: Matches
 *                   records that cross the given WKT.
 *                           <li> gpudb::filter_by_geometry_disjoint: Matches
 *                   records that are disjoint from the given WKT.
 *                           <li> gpudb::filter_by_geometry_equals: Matches
 *                   records that are the same as the given WKT.
 *                           <li> gpudb::filter_by_geometry_intersects: Matches
 *                   records that intersect the given WKT.
 *                           <li> gpudb::filter_by_geometry_overlaps: Matches
 *                   records that overlap the given WKT.
 *                           <li> gpudb::filter_by_geometry_touches: Matches
 *                   records that touch the given WKT.
 *                           <li> gpudb::filter_by_geometry_within: Matches
 *                   records that are within the given WKT.
 *                   </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_geometry_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a viewName. This
 *                 is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_geometry_true
 *                         <li> gpudb::filter_by_geometry_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_geometry_false.
 *                         <li> gpudb::filter_by_geometry_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema provided is non-existent, it
 *                 will be automatically created.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByGeometryResponse& filterByGeometry( const std::string& tableName,
                                            const std::string& viewName,
                                            const std::string& columnName,
                                            const std::string& inputWkt,
                                            const std::string& operation,
                                            const std::map<std::string, std::string>& options,
                                            FilterByGeometryResponse& response_ ) const;

/**
 * Calculates which records from a table have values in the given list
 * for the corresponding column. The operation is synchronous, meaning that a
 * response will not be returned until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set
 * (view) which satisfies the input filter specification is also created if a
 * @a viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by
 * list query with the column map
 * {"x":["10.1", "2.3"], "y":["0.0", "-31.5", "42.0"]} will return
 * the count of all data points whose x and y values match both in the
 * respective
 * x- and y-lists, e.g., "x = 10.1 and y = 0.0", "x = 2.3 and y = -31.5", etc.
 * However, a record with "x = 10.1 and y = -31.5" or "x = 2.3 and y = 0.0"
 * would not be returned because the values in the given lists do not
 * correspond.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByListResponse filterByList( const FilterByListRequest& request_ ) const;

/**
 * Calculates which records from a table have values in the given list
 * for the corresponding column. The operation is synchronous, meaning that a
 * response will not be returned until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set
 * (view) which satisfies the input filter specification is also created if a
 * @a viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by
 * list query with the column map
 * {"x":["10.1", "2.3"], "y":["0.0", "-31.5", "42.0"]} will return
 * the count of all data points whose x and y values match both in the
 * respective
 * x- and y-lists, e.g., "x = 10.1 and y = 0.0", "x = 2.3 and y = -31.5", etc.
 * However, a record with "x = 10.1 and y = -31.5" or "x = 2.3 and y = 0.0"
 * would not be returned because the values in the given lists do not
 * correspond.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByListResponse& filterByList( const FilterByListRequest& request_,
                                    FilterByListResponse& response_ ) const;

/**
 * Calculates which records from a table have values in the given list
 * for the corresponding column. The operation is synchronous, meaning that a
 * response will not be returned until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set
 * (view) which satisfies the input filter specification is also created if a
 * @a viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by
 * list query with the column map
 * {"x":["10.1", "2.3"], "y":["0.0", "-31.5", "42.0"]} will return
 * the count of all data points whose x and y values match both in the
 * respective
 * x- and y-lists, e.g., "x = 10.1 and y = 0.0", "x = 2.3 and y = -31.5", etc.
 * However, a record with "x = 10.1 and y = -31.5" or "x = 2.3 and y = 0.0"
 * would not be returned because the values in the given lists do not
 * correspond.
 * 
 * @param tableName  Name of the table to filter, in [schema_name.]table_name
 *                   format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  This may be the
 *                   name of a table or a view (when chaining queries).
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param columnValuesMap  List of values for the corresponding column in the
 *                         table
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_list_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_list_true
 *                         <li> gpudb::filter_by_list_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_list_false.
 *                         <li> gpudb::filter_by_list_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema provided is non-existent, it
 *                 will be automatically created.
 *                         <li> gpudb::filter_by_list_filter_mode: String
 *                 indicating the filter mode, either 'in_list' or
 *                 'not_in_list'.
 *                 <ul>
 *                         <li> gpudb::filter_by_list_in_list: The filter will
 *                 match all items that are in the provided list(s).
 *                         <li> gpudb::filter_by_list_not_in_list: The filter
 *                 will match all items that are not in the provided list(s).
 *                 </ul>
 *                 The default value is gpudb::filter_by_list_in_list.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByListResponse filterByList( const std::string& tableName,
                                   const std::string& viewName,
                                   const std::map<std::string, std::vector<std::string> >& columnValuesMap,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which records from a table have values in the given list
 * for the corresponding column. The operation is synchronous, meaning that a
 * response will not be returned until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set
 * (view) which satisfies the input filter specification is also created if a
 * @a viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by
 * list query with the column map
 * {"x":["10.1", "2.3"], "y":["0.0", "-31.5", "42.0"]} will return
 * the count of all data points whose x and y values match both in the
 * respective
 * x- and y-lists, e.g., "x = 10.1 and y = 0.0", "x = 2.3 and y = -31.5", etc.
 * However, a record with "x = 10.1 and y = -31.5" or "x = 2.3 and y = 0.0"
 * would not be returned because the values in the given lists do not
 * correspond.
 * 
 * @param tableName  Name of the table to filter, in [schema_name.]table_name
 *                   format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  This may be the
 *                   name of a table or a view (when chaining queries).
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param columnValuesMap  List of values for the corresponding column in the
 *                         table
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_list_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_list_true
 *                         <li> gpudb::filter_by_list_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_list_false.
 *                         <li> gpudb::filter_by_list_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema provided is non-existent, it
 *                 will be automatically created.
 *                         <li> gpudb::filter_by_list_filter_mode: String
 *                 indicating the filter mode, either 'in_list' or
 *                 'not_in_list'.
 *                 <ul>
 *                         <li> gpudb::filter_by_list_in_list: The filter will
 *                 match all items that are in the provided list(s).
 *                         <li> gpudb::filter_by_list_not_in_list: The filter
 *                 will match all items that are not in the provided list(s).
 *                 </ul>
 *                 The default value is gpudb::filter_by_list_in_list.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByListResponse& filterByList( const std::string& tableName,
                                    const std::string& viewName,
                                    const std::map<std::string, std::vector<std::string> >& columnValuesMap,
                                    const std::map<std::string, std::string>& options,
                                    FilterByListResponse& response_ ) const;

/**
 * Calculates which objects from a table lie within a circle with the
 * given radius and center point (i.e. circular NAI). The operation is
 * synchronous,
 * meaning that a response will not be returned until all the objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new
 * resultant set (view) which satisfies the input circular NAI restriction
 * specification is also created if a @a viewName is passed in as part of
 * the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on
 * either side of the circle (if the track goes beyond the circle) will be
 * included
 * in the result.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRadiusResponse filterByRadius( const FilterByRadiusRequest& request_ ) const;

/**
 * Calculates which objects from a table lie within a circle with the
 * given radius and center point (i.e. circular NAI). The operation is
 * synchronous,
 * meaning that a response will not be returned until all the objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new
 * resultant set (view) which satisfies the input circular NAI restriction
 * specification is also created if a @a viewName is passed in as part of
 * the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on
 * either side of the circle (if the track goes beyond the circle) will be
 * included
 * in the result.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRadiusResponse& filterByRadius( const FilterByRadiusRequest& request_,
                                        FilterByRadiusResponse& response_ ) const;

/**
 * Calculates which objects from a table lie within a circle with the
 * given radius and center point (i.e. circular NAI). The operation is
 * synchronous,
 * meaning that a response will not be returned until all the objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new
 * resultant set (view) which satisfies the input circular NAI restriction
 * specification is also created if a @a viewName is passed in as part of
 * the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on
 * either side of the circle (if the track goes beyond the circle) will be
 * included
 * in the result.
 * 
 * @param tableName  Name of the table on which the filter by radius operation
 *                   will be performed, in [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param xColumnName  Name of the column to be used for the x-coordinate (the
 *                     longitude) of the center.
 * @param xCenter  Value of the longitude of the center. Must be within
 *                 [-180.0, 180.0].  The minimum allowed value is -180. The
 *                 maximum allowed value is 180.
 * @param yColumnName  Name of the column to be used for the y-coordinate-the
 *                     latitude-of the center.
 * @param yCenter  Value of the latitude of the center. Must be within [-90.0,
 *                 90.0].  The minimum allowed value is -90. The maximum
 *                 allowed value is 90.
 * @param radius  The radius of the circle within which the search will be
 *                performed. Must be a non-zero positive value. It is in
 *                meters; so, for example, a value of '42000' means 42 km.  The
 *                minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_radius_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a viewName. This
 *                 is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_radius_true
 *                         <li> gpudb::filter_by_radius_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_radius_false.
 *                         <li> gpudb::filter_by_radius_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema which is to
 *                 contain the newly created view. If the schema is
 *                 non-existent, it will be automatically created.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRadiusResponse filterByRadius( const std::string& tableName,
                                       const std::string& viewName,
                                       const std::string& xColumnName,
                                       const double xCenter,
                                       const std::string& yColumnName,
                                       const double yCenter,
                                       const double radius,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which objects from a table lie within a circle with the
 * given radius and center point (i.e. circular NAI). The operation is
 * synchronous,
 * meaning that a response will not be returned until all the objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new
 * resultant set (view) which satisfies the input circular NAI restriction
 * specification is also created if a @a viewName is passed in as part of
 * the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on
 * either side of the circle (if the track goes beyond the circle) will be
 * included
 * in the result.
 * 
 * @param tableName  Name of the table on which the filter by radius operation
 *                   will be performed, in [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param xColumnName  Name of the column to be used for the x-coordinate (the
 *                     longitude) of the center.
 * @param xCenter  Value of the longitude of the center. Must be within
 *                 [-180.0, 180.0].  The minimum allowed value is -180. The
 *                 maximum allowed value is 180.
 * @param yColumnName  Name of the column to be used for the y-coordinate-the
 *                     latitude-of the center.
 * @param yCenter  Value of the latitude of the center. Must be within [-90.0,
 *                 90.0].  The minimum allowed value is -90. The maximum
 *                 allowed value is 90.
 * @param radius  The radius of the circle within which the search will be
 *                performed. Must be a non-zero positive value. It is in
 *                meters; so, for example, a value of '42000' means 42 km.  The
 *                minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_radius_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a viewName. This
 *                 is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_radius_true
 *                         <li> gpudb::filter_by_radius_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_radius_false.
 *                         <li> gpudb::filter_by_radius_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema which is to
 *                 contain the newly created view. If the schema is
 *                 non-existent, it will be automatically created.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRadiusResponse& filterByRadius( const std::string& tableName,
                                        const std::string& viewName,
                                        const std::string& xColumnName,
                                        const double xCenter,
                                        const std::string& yColumnName,
                                        const double yCenter,
                                        const double radius,
                                        const std::map<std::string, std::string>& options,
                                        FilterByRadiusResponse& response_ ) const;

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a circle with the given radius and center point (i.e. circular NAI). The
 * operation is synchronous, meaning that a response will not be returned until
 * all
 * the objects are fully available. The response payload provides the count of
 * the
 * resulting set. A new resultant set (view) which satisfies the input circular
 * NAI
 * restriction specification is also created if a @a viewName is passed in
 * as part of the request.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRadiusGeometryResponse filterByRadiusGeometry( const FilterByRadiusGeometryRequest& request_ ) const;

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a circle with the given radius and center point (i.e. circular NAI). The
 * operation is synchronous, meaning that a response will not be returned until
 * all
 * the objects are fully available. The response payload provides the count of
 * the
 * resulting set. A new resultant set (view) which satisfies the input circular
 * NAI
 * restriction specification is also created if a @a viewName is passed in
 * as part of the request.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRadiusGeometryResponse& filterByRadiusGeometry( const FilterByRadiusGeometryRequest& request_,
                                                        FilterByRadiusGeometryResponse& response_ ) const;

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a circle with the given radius and center point (i.e. circular NAI). The
 * operation is synchronous, meaning that a response will not be returned until
 * all
 * the objects are fully available. The response payload provides the count of
 * the
 * resulting set. A new resultant set (view) which satisfies the input circular
 * NAI
 * restriction specification is also created if a @a viewName is passed in
 * as part of the request.
 * 
 * @param tableName  Name of the table on which the filter by radius operation
 *                   will be performed, in [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param columnName  Name of the geospatial geometry column to be filtered.
 * @param xCenter  Value of the longitude of the center. Must be within
 *                 [-180.0, 180.0].  The minimum allowed value is -180. The
 *                 maximum allowed value is 180.
 * @param yCenter  Value of the latitude of the center. Must be within [-90.0,
 *                 90.0].  The minimum allowed value is -90. The maximum
 *                 allowed value is 90.
 * @param radius  The radius of the circle within which the search will be
 *                performed. Must be a non-zero positive value. It is in
 *                meters; so, for example, a value of '42000' means 42 km.  The
 *                minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::filter_by_radius_geometry_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_radius_geometry_true
 *                         <li> gpudb::filter_by_radius_geometry_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_radius_geometry_false.
 *                         <li>
 *                 gpudb::filter_by_radius_geometry_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema provided is non-existent, it
 *                 will be automatically created.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRadiusGeometryResponse filterByRadiusGeometry( const std::string& tableName,
                                                       const std::string& viewName,
                                                       const std::string& columnName,
                                                       const double xCenter,
                                                       const double yCenter,
                                                       const double radius,
                                                       const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a circle with the given radius and center point (i.e. circular NAI). The
 * operation is synchronous, meaning that a response will not be returned until
 * all
 * the objects are fully available. The response payload provides the count of
 * the
 * resulting set. A new resultant set (view) which satisfies the input circular
 * NAI
 * restriction specification is also created if a @a viewName is passed in
 * as part of the request.
 * 
 * @param tableName  Name of the table on which the filter by radius operation
 *                   will be performed, in [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param columnName  Name of the geospatial geometry column to be filtered.
 * @param xCenter  Value of the longitude of the center. Must be within
 *                 [-180.0, 180.0].  The minimum allowed value is -180. The
 *                 maximum allowed value is 180.
 * @param yCenter  Value of the latitude of the center. Must be within [-90.0,
 *                 90.0].  The minimum allowed value is -90. The maximum
 *                 allowed value is 90.
 * @param radius  The radius of the circle within which the search will be
 *                performed. Must be a non-zero positive value. It is in
 *                meters; so, for example, a value of '42000' means 42 km.  The
 *                minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::filter_by_radius_geometry_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_radius_geometry_true
 *                         <li> gpudb::filter_by_radius_geometry_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_radius_geometry_false.
 *                         <li>
 *                 gpudb::filter_by_radius_geometry_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema provided is non-existent, it
 *                 will be automatically created.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRadiusGeometryResponse& filterByRadiusGeometry( const std::string& tableName,
                                                        const std::string& viewName,
                                                        const std::string& columnName,
                                                        const double xCenter,
                                                        const double yCenter,
                                                        const double radius,
                                                        const std::map<std::string, std::string>& options,
                                                        FilterByRadiusGeometryResponse& response_ ) const;

/**
 * Calculates which objects from a table have a column that is within
 * the given bounds. An object from the table identified by @a tableName is
 * added to the view @a viewName if its column is within
 * [@a lowerBound, @a upperBound] (inclusive). The operation is
 * synchronous. The response provides a count of the number of objects which
 * passed
 * the bound filter.  Although this functionality can also be accomplished with
 * the
 * standard filter function, it is more efficient.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRangeResponse filterByRange( const FilterByRangeRequest& request_ ) const;

/**
 * Calculates which objects from a table have a column that is within
 * the given bounds. An object from the table identified by @a tableName is
 * added to the view @a viewName if its column is within
 * [@a lowerBound, @a upperBound] (inclusive). The operation is
 * synchronous. The response provides a count of the number of objects which
 * passed
 * the bound filter.  Although this functionality can also be accomplished with
 * the
 * standard filter function, it is more efficient.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRangeResponse& filterByRange( const FilterByRangeRequest& request_,
                                      FilterByRangeResponse& response_ ) const;

/**
 * Calculates which objects from a table have a column that is within
 * the given bounds. An object from the table identified by @a tableName is
 * added to the view @a viewName if its column is within
 * [@a lowerBound, @a upperBound] (inclusive). The operation is
 * synchronous. The response provides a count of the number of objects which
 * passed
 * the bound filter.  Although this functionality can also be accomplished with
 * the
 * standard filter function, it is more efficient.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param tableName  Name of the table on which the filter by range operation
 *                   will be performed, in [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param columnName  Name of a column on which the operation would be applied.
 * @param lowerBound  Value of the lower bound (inclusive).
 * @param upperBound  Value of the upper bound (inclusive).
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_range_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_range_true
 *                         <li> gpudb::filter_by_range_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_range_false.
 *                         <li> gpudb::filter_by_range_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRangeResponse filterByRange( const std::string& tableName,
                                     const std::string& viewName,
                                     const std::string& columnName,
                                     const double lowerBound,
                                     const double upperBound,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which objects from a table have a column that is within
 * the given bounds. An object from the table identified by @a tableName is
 * added to the view @a viewName if its column is within
 * [@a lowerBound, @a upperBound] (inclusive). The operation is
 * synchronous. The response provides a count of the number of objects which
 * passed
 * the bound filter.  Although this functionality can also be accomplished with
 * the
 * standard filter function, it is more efficient.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param tableName  Name of the table on which the filter by range operation
 *                   will be performed, in [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param columnName  Name of a column on which the operation would be applied.
 * @param lowerBound  Value of the lower bound (inclusive).
 * @param upperBound  Value of the upper bound (inclusive).
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_range_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_range_true
 *                         <li> gpudb::filter_by_range_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_range_false.
 *                         <li> gpudb::filter_by_range_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRangeResponse& filterByRange( const std::string& tableName,
                                      const std::string& viewName,
                                      const std::string& columnName,
                                      const double lowerBound,
                                      const double upperBound,
                                      const std::map<std::string, std::string>& options,
                                      FilterByRangeResponse& response_ ) const;

/**
 * Filters objects matching all points of the given track (works only
 * on track type data).  It allows users to specify a particular track to find
 * all
 * other points in the table that fall within specified ranges (spatial and
 * temporal) of all points of the given track. Additionally, the user can
 * specify
 * another track to see if the two intersect (or go close to each other within
 * the
 * specified ranges). The user also has the flexibility of using different
 * metrics
 * for the spatial distance calculation: Euclidean (flat geometry) or Great
 * Circle
 * (spherical geometry to approximate the Earth's surface distances). The
 * filtered
 * points are stored in a newly created result set. The return value of the
 * function is the number of points in the resultant set (view).
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterBySeriesResponse filterBySeries( const FilterBySeriesRequest& request_ ) const;

/**
 * Filters objects matching all points of the given track (works only
 * on track type data).  It allows users to specify a particular track to find
 * all
 * other points in the table that fall within specified ranges (spatial and
 * temporal) of all points of the given track. Additionally, the user can
 * specify
 * another track to see if the two intersect (or go close to each other within
 * the
 * specified ranges). The user also has the flexibility of using different
 * metrics
 * for the spatial distance calculation: Euclidean (flat geometry) or Great
 * Circle
 * (spherical geometry to approximate the Earth's surface distances). The
 * filtered
 * points are stored in a newly created result set. The return value of the
 * function is the number of points in the resultant set (view).
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterBySeriesResponse& filterBySeries( const FilterBySeriesRequest& request_,
                                        FilterBySeriesResponse& response_ ) const;

/**
 * Filters objects matching all points of the given track (works only
 * on track type data).  It allows users to specify a particular track to find
 * all
 * other points in the table that fall within specified ranges (spatial and
 * temporal) of all points of the given track. Additionally, the user can
 * specify
 * another track to see if the two intersect (or go close to each other within
 * the
 * specified ranges). The user also has the flexibility of using different
 * metrics
 * for the spatial distance calculation: Euclidean (flat geometry) or Great
 * Circle
 * (spherical geometry to approximate the Earth's surface distances). The
 * filtered
 * points are stored in a newly created result set. The return value of the
 * function is the number of points in the resultant set (view).
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available.
 * 
 * @param tableName  Name of the table on which the filter by track operation
 *                   will be performed, in [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>. Must be a
 *                   currently existing table with a <a
 *                   href="../../../geospatial/geo_objects/"
 *                   target="_top">track</a> present.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param trackId  The ID of the track which will act as the filtering points.
 *                 Must be an existing track within the given table.
 * @param targetTrackIds  Up to one track ID to intersect with the "filter"
 *                        track. If any provided, it must be an valid track ID
 *                        within the given set.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_series_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a viewName. This
 *                 is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_series_true
 *                         <li> gpudb::filter_by_series_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_series_false.
 *                         <li> gpudb::filter_by_series_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                         <li> gpudb::filter_by_series_spatial_radius: A
 *                 positive number passed as a string representing the radius
 *                 of the search area centered around each track point's
 *                 geospatial coordinates. The value is interpreted in meters.
 *                 Required parameter.
 *                         <li> gpudb::filter_by_series_time_radius: A positive
 *                 number passed as a string representing the maximum allowable
 *                 time difference between the timestamps of a filtered object
 *                 and the given track's points. The value is interpreted in
 *                 seconds. Required parameter.
 *                         <li>
 *                 gpudb::filter_by_series_spatial_distance_metric: A string
 *                 representing the coordinate system to use for the spatial
 *                 search criteria. Acceptable values are 'euclidean' and
 *                 'great_circle'. Optional parameter; default is 'euclidean'.
 *                 <ul>
 *                         <li> gpudb::filter_by_series_euclidean
 *                         <li> gpudb::filter_by_series_great_circle
 *                 </ul>
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterBySeriesResponse filterBySeries( const std::string& tableName,
                                       const std::string& viewName,
                                       const std::string& trackId,
                                       const std::vector<std::string>& targetTrackIds,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Filters objects matching all points of the given track (works only
 * on track type data).  It allows users to specify a particular track to find
 * all
 * other points in the table that fall within specified ranges (spatial and
 * temporal) of all points of the given track. Additionally, the user can
 * specify
 * another track to see if the two intersect (or go close to each other within
 * the
 * specified ranges). The user also has the flexibility of using different
 * metrics
 * for the spatial distance calculation: Euclidean (flat geometry) or Great
 * Circle
 * (spherical geometry to approximate the Earth's surface distances). The
 * filtered
 * points are stored in a newly created result set. The return value of the
 * function is the number of points in the resultant set (view).
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available.
 * 
 * @param tableName  Name of the table on which the filter by track operation
 *                   will be performed, in [schema_name.]table_name format,
 *                   using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>. Must be a
 *                   currently existing table with a <a
 *                   href="../../../geospatial/geo_objects/"
 *                   target="_top">track</a> present.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param trackId  The ID of the track which will act as the filtering points.
 *                 Must be an existing track within the given table.
 * @param targetTrackIds  Up to one track ID to intersect with the "filter"
 *                        track. If any provided, it must be an valid track ID
 *                        within the given set.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_series_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a viewName. This
 *                 is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_series_true
 *                         <li> gpudb::filter_by_series_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_series_false.
 *                         <li> gpudb::filter_by_series_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                         <li> gpudb::filter_by_series_spatial_radius: A
 *                 positive number passed as a string representing the radius
 *                 of the search area centered around each track point's
 *                 geospatial coordinates. The value is interpreted in meters.
 *                 Required parameter.
 *                         <li> gpudb::filter_by_series_time_radius: A positive
 *                 number passed as a string representing the maximum allowable
 *                 time difference between the timestamps of a filtered object
 *                 and the given track's points. The value is interpreted in
 *                 seconds. Required parameter.
 *                         <li>
 *                 gpudb::filter_by_series_spatial_distance_metric: A string
 *                 representing the coordinate system to use for the spatial
 *                 search criteria. Acceptable values are 'euclidean' and
 *                 'great_circle'. Optional parameter; default is 'euclidean'.
 *                 <ul>
 *                         <li> gpudb::filter_by_series_euclidean
 *                         <li> gpudb::filter_by_series_great_circle
 *                 </ul>
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterBySeriesResponse& filterBySeries( const std::string& tableName,
                                        const std::string& viewName,
                                        const std::string& trackId,
                                        const std::vector<std::string>& targetTrackIds,
                                        const std::map<std::string, std::string>& options,
                                        FilterBySeriesResponse& response_ ) const;

/**
 * Calculates which objects from a table or view match a string
 * expression for the given string columns. Setting
 * @a case_sensitive can modify case sensitivity in matching
 * for all modes except @a search. For
 * @a search mode details and limitations, see
 * <a href="../../../concepts/full_text_search/" target="_top">Full Text
 * Search</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByStringResponse filterByString( const FilterByStringRequest& request_ ) const;

/**
 * Calculates which objects from a table or view match a string
 * expression for the given string columns. Setting
 * @a case_sensitive can modify case sensitivity in matching
 * for all modes except @a search. For
 * @a search mode details and limitations, see
 * <a href="../../../concepts/full_text_search/" target="_top">Full Text
 * Search</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByStringResponse& filterByString( const FilterByStringRequest& request_,
                                        FilterByStringResponse& response_ ) const;

/**
 * Calculates which objects from a table or view match a string
 * expression for the given string columns. Setting
 * @a case_sensitive can modify case sensitivity in matching
 * for all modes except @a search. For
 * @a search mode details and limitations, see
 * <a href="../../../concepts/full_text_search/" target="_top">Full Text
 * Search</a>.
 * 
 * @param tableName  Name of the table on which the filter operation will be
 *                   performed, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table or view.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param expression  The expression with which to filter the table.
 * @param mode  The string filtering mode to apply. See below for details.
 *              <ul>
 *                      <li> gpudb::filter_by_string_search: Full text search
 *              query with wildcards and boolean operators. Note that for this
 *              mode, no column can be specified in @a columnNames; all string
 *              columns of the table that have text search enabled will be
 *              searched.
 *                      <li> gpudb::filter_by_string_equals: Exact whole-string
 *              match (accelerated).
 *                      <li> gpudb::filter_by_string_contains: Partial
 *              substring match (not accelerated).  If the column is a string
 *              type (non-charN) and the number of records is too large, it
 *              will return 0.
 *                      <li> gpudb::filter_by_string_starts_with: Strings that
 *              start with the given expression (not accelerated). If the
 *              column is a string type (non-charN) and the number of records
 *              is too large, it will return 0.
 *                      <li> gpudb::filter_by_string_regex: Full regular
 *              expression search (not accelerated). If the column is a string
 *              type (non-charN) and the number of records is too large, it
 *              will return 0.
 *              </ul>
 * @param columnNames  List of columns on which to apply the filter. Ignored
 *                     for @a search mode.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_string_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a viewName. This
 *                 is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_string_true
 *                         <li> gpudb::filter_by_string_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_string_false.
 *                         <li> gpudb::filter_by_string_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                         <li> gpudb::filter_by_string_case_sensitive: If @a
 *                 false then string filtering will ignore case. Does not apply
 *                 to @a search mode.
 *                 <ul>
 *                         <li> gpudb::filter_by_string_true
 *                         <li> gpudb::filter_by_string_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_string_true.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByStringResponse filterByString( const std::string& tableName,
                                       const std::string& viewName,
                                       const std::string& expression,
                                       const std::string& mode,
                                       const std::vector<std::string>& columnNames,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which objects from a table or view match a string
 * expression for the given string columns. Setting
 * @a case_sensitive can modify case sensitivity in matching
 * for all modes except @a search. For
 * @a search mode details and limitations, see
 * <a href="../../../concepts/full_text_search/" target="_top">Full Text
 * Search</a>.
 * 
 * @param tableName  Name of the table on which the filter operation will be
 *                   performed, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table or view.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param expression  The expression with which to filter the table.
 * @param mode  The string filtering mode to apply. See below for details.
 *              <ul>
 *                      <li> gpudb::filter_by_string_search: Full text search
 *              query with wildcards and boolean operators. Note that for this
 *              mode, no column can be specified in @a columnNames; all string
 *              columns of the table that have text search enabled will be
 *              searched.
 *                      <li> gpudb::filter_by_string_equals: Exact whole-string
 *              match (accelerated).
 *                      <li> gpudb::filter_by_string_contains: Partial
 *              substring match (not accelerated).  If the column is a string
 *              type (non-charN) and the number of records is too large, it
 *              will return 0.
 *                      <li> gpudb::filter_by_string_starts_with: Strings that
 *              start with the given expression (not accelerated). If the
 *              column is a string type (non-charN) and the number of records
 *              is too large, it will return 0.
 *                      <li> gpudb::filter_by_string_regex: Full regular
 *              expression search (not accelerated). If the column is a string
 *              type (non-charN) and the number of records is too large, it
 *              will return 0.
 *              </ul>
 * @param columnNames  List of columns on which to apply the filter. Ignored
 *                     for @a search mode.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_string_create_temp_table: If
 *                 @a true, a unique temporary table name will be generated in
 *                 the sys_temp schema and used in place of @a viewName. This
 *                 is always allowed even if the caller does not have
 *                 permission to create tables. The generated name is returned
 *                 in @a qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_string_true
 *                         <li> gpudb::filter_by_string_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_string_false.
 *                         <li> gpudb::filter_by_string_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                         <li> gpudb::filter_by_string_case_sensitive: If @a
 *                 false then string filtering will ignore case. Does not apply
 *                 to @a search mode.
 *                 <ul>
 *                         <li> gpudb::filter_by_string_true
 *                         <li> gpudb::filter_by_string_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_string_true.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByStringResponse& filterByString( const std::string& tableName,
                                        const std::string& viewName,
                                        const std::string& expression,
                                        const std::string& mode,
                                        const std::vector<std::string>& columnNames,
                                        const std::map<std::string, std::string>& options,
                                        FilterByStringResponse& response_ ) const;

/**
 * Filters objects in one table based on objects in another table. The
 * user must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which
 * the filter will be created); the column names need not be the same. If a
 * @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that a response
 * will
 * not be returned until all objects are fully available in the result view.
 * The
 * return value contains the count (i.e. the size) of the resulting view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByTableResponse filterByTable( const FilterByTableRequest& request_ ) const;

/**
 * Filters objects in one table based on objects in another table. The
 * user must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which
 * the filter will be created); the column names need not be the same. If a
 * @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that a response
 * will
 * not be returned until all objects are fully available in the result view.
 * The
 * return value contains the count (i.e. the size) of the resulting view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByTableResponse& filterByTable( const FilterByTableRequest& request_,
                                      FilterByTableResponse& response_ ) const;

/**
 * Filters objects in one table based on objects in another table. The
 * user must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which
 * the filter will be created); the column names need not be the same. If a
 * @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that a response
 * will
 * not be returned until all objects are fully available in the result view.
 * The
 * return value contains the count (i.e. the size) of the resulting view.
 * 
 * @param tableName  Name of the table whose data will be filtered, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param columnName  Name of the column by whose value the data will be
 *                    filtered from the table designated by @a tableName.
 * @param sourceTableName  Name of the table whose data will be compared
 *                         against in the table called @a tableName, in
 *                         [schema_name.]table_name format, using standard <a
 *                         href="../../../concepts/tables/#table-name-resolution"
 *                         target="_top">name resolution rules</a>.  Must be an
 *                         existing table.
 * @param sourceTableColumnName  Name of the column in the @a sourceTableName
 *                               whose values will be used as the filter for
 *                               table @a tableName. Must be a geospatial
 *                               geometry column if in 'spatial' mode;
 *                               otherwise, Must match the type of the @a
 *                               columnName.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_true
 *                         <li> gpudb::filter_by_table_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_table_false.
 *                         <li> gpudb::filter_by_table_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                         <li> gpudb::filter_by_table_filter_mode: String
 *                 indicating the filter mode, either @a in_table or @a
 *                 not_in_table.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_in_table
 *                         <li> gpudb::filter_by_table_not_in_table
 *                 </ul>
 *                 The default value is gpudb::filter_by_table_in_table.
 *                         <li> gpudb::filter_by_table_mode: Mode - should be
 *                 either @a spatial or @a normal.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_normal
 *                         <li> gpudb::filter_by_table_spatial
 *                 </ul>
 *                 The default value is gpudb::filter_by_table_normal.
 *                         <li> gpudb::filter_by_table_buffer: Buffer size, in
 *                 meters. Only relevant for @a spatial mode.  The default
 *                 value is '0'.
 *                         <li> gpudb::filter_by_table_buffer_method: Method
 *                 used to buffer polygons.  Only relevant for @a spatial mode.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_normal
 *                         <li> gpudb::filter_by_table_geos: Use geos 1 edge
 *                 per corner algorithm
 *                 </ul>
 *                 The default value is gpudb::filter_by_table_normal.
 *                         <li> gpudb::filter_by_table_max_partition_size:
 *                 Maximum number of points in a partition. Only relevant for
 *                 @a spatial mode.  The default value is '0'.
 *                         <li> gpudb::filter_by_table_max_partition_score:
 *                 Maximum number of points * edges in a partition. Only
 *                 relevant for @a spatial mode.  The default value is
 *                 '8000000'.
 *                         <li> gpudb::filter_by_table_x_column_name: Name of
 *                 column containing x value of point being filtered in @a
 *                 spatial mode.  The default value is 'x'.
 *                         <li> gpudb::filter_by_table_y_column_name: Name of
 *                 column containing y value of point being filtered in @a
 *                 spatial mode.  The default value is 'y'.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByTableResponse filterByTable( const std::string& tableName,
                                     const std::string& viewName,
                                     const std::string& columnName,
                                     const std::string& sourceTableName,
                                     const std::string& sourceTableColumnName,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Filters objects in one table based on objects in another table. The
 * user must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which
 * the filter will be created); the column names need not be the same. If a
 * @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that a response
 * will
 * not be returned until all objects are fully available in the result view.
 * The
 * return value contains the count (i.e. the size) of the resulting view.
 * 
 * @param tableName  Name of the table whose data will be filtered, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param columnName  Name of the column by whose value the data will be
 *                    filtered from the table designated by @a tableName.
 * @param sourceTableName  Name of the table whose data will be compared
 *                         against in the table called @a tableName, in
 *                         [schema_name.]table_name format, using standard <a
 *                         href="../../../concepts/tables/#table-name-resolution"
 *                         target="_top">name resolution rules</a>.  Must be an
 *                         existing table.
 * @param sourceTableColumnName  Name of the column in the @a sourceTableName
 *                               whose values will be used as the filter for
 *                               table @a tableName. Must be a geospatial
 *                               geometry column if in 'spatial' mode;
 *                               otherwise, Must match the type of the @a
 *                               columnName.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_true
 *                         <li> gpudb::filter_by_table_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_table_false.
 *                         <li> gpudb::filter_by_table_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                         <li> gpudb::filter_by_table_filter_mode: String
 *                 indicating the filter mode, either @a in_table or @a
 *                 not_in_table.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_in_table
 *                         <li> gpudb::filter_by_table_not_in_table
 *                 </ul>
 *                 The default value is gpudb::filter_by_table_in_table.
 *                         <li> gpudb::filter_by_table_mode: Mode - should be
 *                 either @a spatial or @a normal.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_normal
 *                         <li> gpudb::filter_by_table_spatial
 *                 </ul>
 *                 The default value is gpudb::filter_by_table_normal.
 *                         <li> gpudb::filter_by_table_buffer: Buffer size, in
 *                 meters. Only relevant for @a spatial mode.  The default
 *                 value is '0'.
 *                         <li> gpudb::filter_by_table_buffer_method: Method
 *                 used to buffer polygons.  Only relevant for @a spatial mode.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_normal
 *                         <li> gpudb::filter_by_table_geos: Use geos 1 edge
 *                 per corner algorithm
 *                 </ul>
 *                 The default value is gpudb::filter_by_table_normal.
 *                         <li> gpudb::filter_by_table_max_partition_size:
 *                 Maximum number of points in a partition. Only relevant for
 *                 @a spatial mode.  The default value is '0'.
 *                         <li> gpudb::filter_by_table_max_partition_score:
 *                 Maximum number of points * edges in a partition. Only
 *                 relevant for @a spatial mode.  The default value is
 *                 '8000000'.
 *                         <li> gpudb::filter_by_table_x_column_name: Name of
 *                 column containing x value of point being filtered in @a
 *                 spatial mode.  The default value is 'x'.
 *                         <li> gpudb::filter_by_table_y_column_name: Name of
 *                 column containing y value of point being filtered in @a
 *                 spatial mode.  The default value is 'y'.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByTableResponse& filterByTable( const std::string& tableName,
                                      const std::string& viewName,
                                      const std::string& columnName,
                                      const std::string& sourceTableName,
                                      const std::string& sourceTableColumnName,
                                      const std::map<std::string, std::string>& options,
                                      FilterByTableResponse& response_ ) const;

/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String
 * or a Double valued column and a desired value for the column on which the
 * filter
 * is performed. The operation is synchronous, meaning that a response will not
 * be
 * returned until all the objects are fully available. The response payload
 * provides the count of the resulting set. A new result view which satisfies
 * the
 * input filter restriction specification is also created with a view name
 * passed
 * in as part of the input payload.  Although this functionality can also be
 * accomplished with the standard filter function, it is more efficient.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByValueResponse filterByValue( const FilterByValueRequest& request_ ) const;

/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String
 * or a Double valued column and a desired value for the column on which the
 * filter
 * is performed. The operation is synchronous, meaning that a response will not
 * be
 * returned until all the objects are fully available. The response payload
 * provides the count of the resulting set. A new result view which satisfies
 * the
 * input filter restriction specification is also created with a view name
 * passed
 * in as part of the input payload.  Although this functionality can also be
 * accomplished with the standard filter function, it is more efficient.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByValueResponse& filterByValue( const FilterByValueRequest& request_,
                                      FilterByValueResponse& response_ ) const;

/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String
 * or a Double valued column and a desired value for the column on which the
 * filter
 * is performed. The operation is synchronous, meaning that a response will not
 * be
 * returned until all the objects are fully available. The response payload
 * provides the count of the resulting set. A new result view which satisfies
 * the
 * input filter restriction specification is also created with a view name
 * passed
 * in as part of the input payload.  Although this functionality can also be
 * accomplished with the standard filter function, it is more efficient.
 * 
 * @param tableName  Name of an existing table on which to perform the
 *                   calculation, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param isString  Indicates whether the value being searched for is string or
 *                  numeric.
 * @param value  The value to search for.
 * @param valueStr  The string value to search for.
 * @param columnName  Name of a column on which the filter by value would be
 *                    applied.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_value_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_value_true
 *                         <li> gpudb::filter_by_value_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_value_false.
 *                         <li> gpudb::filter_by_value_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByValueResponse filterByValue( const std::string& tableName,
                                     const std::string& viewName,
                                     const bool isString,
                                     const double value,
                                     const std::string& valueStr,
                                     const std::string& columnName,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String
 * or a Double valued column and a desired value for the column on which the
 * filter
 * is performed. The operation is synchronous, meaning that a response will not
 * be
 * returned until all the objects are fully available. The response payload
 * provides the count of the resulting set. A new result view which satisfies
 * the
 * input filter restriction specification is also created with a view name
 * passed
 * in as part of the input payload.  Although this functionality can also be
 * accomplished with the standard filter function, it is more efficient.
 * 
 * @param tableName  Name of an existing table on which to perform the
 *                   calculation, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results, in [schema_name.]view_name format,
 *                  using standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a> and meeting <a
 *                  href="../../../concepts/tables/#table-naming-criteria"
 *                  target="_top">table naming criteria</a>.  Must not be an
 *                  already existing table or view.
 * @param isString  Indicates whether the value being searched for is string or
 *                  numeric.
 * @param value  The value to search for.
 * @param valueStr  The string value to search for.
 * @param columnName  Name of a column on which the filter by value would be
 *                    applied.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_value_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a viewName. This is
 *                 always allowed even if the caller does not have permission
 *                 to create tables. The generated name is returned in @a
 *                 qualified_view_name.
 *                 <ul>
 *                         <li> gpudb::filter_by_value_true
 *                         <li> gpudb::filter_by_value_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_value_false.
 *                         <li> gpudb::filter_by_value_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 view as part of @a viewName and use /create/schema to create
 *                 the schema if non-existent]  Name of a schema for the newly
 *                 created view. If the schema is non-existent, it will be
 *                 automatically created.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByValueResponse& filterByValue( const std::string& tableName,
                                      const std::string& viewName,
                                      const bool isString,
                                      const double value,
                                      const std::string& valueStr,
                                      const std::string& columnName,
                                      const std::map<std::string, std::string>& options,
                                      FilterByValueResponse& response_ ) const;

/**
 * Get the status and result of asynchronously running job.  See the {@link
 * #createJob(const CreateJobRequest&) const} for starting an asynchronous
 * job.  Some fields of the response are filled only after the submitted job
 * has finished execution.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetJobResponse getJob( const GetJobRequest& request_ ) const;

/**
 * Get the status and result of asynchronously running job.  See the {@link
 * #createJob(const CreateJobRequest&,CreateJobResponse&) const} for
 * starting an asynchronous job.  Some fields of the response are filled only
 * after the submitted job has finished execution.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetJobResponse& getJob( const GetJobRequest& request_,
                        GetJobResponse& response_ ) const;

/**
 * Get the status and result of asynchronously running job.  See the {@link
 * #createJob(const std::string&,const std::string&,const std::vector<uint8_t>&,const std::string&,const std::map<std::string, std::string>&) const}
 * for starting an asynchronous job.  Some fields of the response are filled
 * only after the submitted job has finished execution.
 * 
 * @param jobId  A unique identifier for the job whose status and result is to
 *               be fetched.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::get_job_job_tag: Job tag returned in
 *                 call to create the job
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetJobResponse getJob( const int64_t jobId,
                       const std::map<std::string, std::string>& options ) const;

/**
 * Get the status and result of asynchronously running job.  See the {@link
 * #createJob(const std::string&,const std::string&,const std::vector<uint8_t>&,const std::string&,const std::map<std::string, std::string>&,CreateJobResponse&) const}
 * for starting an asynchronous job.  Some fields of the response are filled
 * only after the submitted job has finished execution.
 * 
 * @param jobId  A unique identifier for the job whose status and result is to
 *               be fetched.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::get_job_job_tag: Job tag returned in
 *                 call to create the job
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetJobResponse& getJob( const int64_t jobId,
                        const std::map<std::string, std::string>& options,
                        GetJobResponse& response_ ) const;

/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.  Note that when paging through a table, if the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsResponse getRecordsRaw( const GetRecordsRequest& request_ ) const;

/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.  Note that when paging through a table, if the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsResponse& getRecordsRaw( const GetRecordsRequest& request_,
                                      RawGetRecordsResponse& response_ ) const;

/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.  Note that when paging through a table, if the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse> getRecords( const GetRecordsRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    GetRecordsResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.  Note that when paging through a table, if the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse>& getRecords( const GetRecordsRequest& request_,
                                           GetRecordsResponse<TResponse>& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.  Note that when paging through a table, if the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param tableName  Name of the table or view from which the records will be
 *                   fetched, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a hasMoreRecords to see if more records exist in the
 *               result to be fetched, and
 *               @a offset & @a limit to request subsequent pages of results.
 * @param options
 *                 <ul>
 *                         <li> gpudb::get_records_expression: Optional filter
 *                 expression to apply to the table.
 *                         <li> gpudb::get_records_fast_index_lookup: Indicates
 *                 if indexes should be used to perform the lookup for a given
 *                 expression if possible. Only applicable if there is no
 *                 sorting, the expression contains only equivalence
 *                 comparisons based on existing tables indexes and the range
 *                 of requested values is from [0 to END_OF_SET].
 *                 <ul>
 *                         <li> gpudb::get_records_true
 *                         <li> gpudb::get_records_false
 *                 </ul>
 *                 The default value is gpudb::get_records_true.
 *                         <li> gpudb::get_records_sort_by: Optional column
 *                 that the data should be sorted by. Empty by default (i.e. no
 *                 sorting is applied).
 *                         <li> gpudb::get_records_sort_order: String
 *                 indicating how the returned values should be sorted -
 *                 ascending or descending. If sort_order is provided, sort_by
 *                 has to be provided.
 *                 <ul>
 *                         <li> gpudb::get_records_ascending
 *                         <li> gpudb::get_records_descending
 *                 </ul>
 *                 The default value is gpudb::get_records_ascending.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse> getRecords( const std::string& tableName,
                                          const int64_t offset,
                                          const int64_t limit,
                                          const std::map<std::string, std::string>& options ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    GetRecordsResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.  Note that when paging through a table, if the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param tableName  Name of the table or view from which the records will be
 *                   fetched, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a hasMoreRecords to see if more records exist in the
 *               result to be fetched, and
 *               @a offset & @a limit to request subsequent pages of results.
 * @param options
 *                 <ul>
 *                         <li> gpudb::get_records_expression: Optional filter
 *                 expression to apply to the table.
 *                         <li> gpudb::get_records_fast_index_lookup: Indicates
 *                 if indexes should be used to perform the lookup for a given
 *                 expression if possible. Only applicable if there is no
 *                 sorting, the expression contains only equivalence
 *                 comparisons based on existing tables indexes and the range
 *                 of requested values is from [0 to END_OF_SET].
 *                 <ul>
 *                         <li> gpudb::get_records_true
 *                         <li> gpudb::get_records_false
 *                 </ul>
 *                 The default value is gpudb::get_records_true.
 *                         <li> gpudb::get_records_sort_by: Optional column
 *                 that the data should be sorted by. Empty by default (i.e. no
 *                 sorting is applied).
 *                         <li> gpudb::get_records_sort_order: String
 *                 indicating how the returned values should be sorted -
 *                 ascending or descending. If sort_order is provided, sort_by
 *                 has to be provided.
 *                 <ul>
 *                         <li> gpudb::get_records_ascending
 *                         <li> gpudb::get_records_descending
 *                 </ul>
 *                 The default value is gpudb::get_records_ascending.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse>& getRecords( const std::string& tableName,
                                           const int64_t offset,
                                           const int64_t limit,
                                           const std::map<std::string, std::string>& options,
                                           GetRecordsResponse<TResponse>& response_ ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.  Note that when paging through a table, if the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse> getRecords( const ::avro::ValidSchema& schema_,
                                          const GetRecordsRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    GetRecordsResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.  Note that when paging through a table, if the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] type_  Type object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse> getRecords( const Type& type_,
                                          const GetRecordsRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    GetRecordsResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.  Note that when paging through a table, if the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse>& getRecords( const ::avro::ValidSchema& schema_,
                                           const GetRecordsRequest& request_,
                                           GetRecordsResponse<TResponse>& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.  Note that when paging through a table, if the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] type_  Type object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse>& getRecords( const Type& type_,
                                           const GetRecordsRequest& request_,
                                           GetRecordsResponse<TResponse>& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.  Note that when paging through a table, if the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param tableName  Name of the table or view from which the records will be
 *                   fetched, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a hasMoreRecords to see if more records exist in the
 *               result to be fetched, and
 *               @a offset & @a limit to request subsequent pages of results.
 * @param options
 *                 <ul>
 *                         <li> gpudb::get_records_expression: Optional filter
 *                 expression to apply to the table.
 *                         <li> gpudb::get_records_fast_index_lookup: Indicates
 *                 if indexes should be used to perform the lookup for a given
 *                 expression if possible. Only applicable if there is no
 *                 sorting, the expression contains only equivalence
 *                 comparisons based on existing tables indexes and the range
 *                 of requested values is from [0 to END_OF_SET].
 *                 <ul>
 *                         <li> gpudb::get_records_true
 *                         <li> gpudb::get_records_false
 *                 </ul>
 *                 The default value is gpudb::get_records_true.
 *                         <li> gpudb::get_records_sort_by: Optional column
 *                 that the data should be sorted by. Empty by default (i.e. no
 *                 sorting is applied).
 *                         <li> gpudb::get_records_sort_order: String
 *                 indicating how the returned values should be sorted -
 *                 ascending or descending. If sort_order is provided, sort_by
 *                 has to be provided.
 *                 <ul>
 *                         <li> gpudb::get_records_ascending
 *                         <li> gpudb::get_records_descending
 *                 </ul>
 *                 The default value is gpudb::get_records_ascending.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse> getRecords( const ::avro::ValidSchema& schema_,
                                          const std::string& tableName,
                                          const int64_t offset,
                                          const int64_t limit,
                                          const std::map<std::string, std::string>& options ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    GetRecordsResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.  Note that when paging through a table, if the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] type_  Type object used for decoding returned objects.
 * @param tableName  Name of the table or view from which the records will be
 *                   fetched, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a hasMoreRecords to see if more records exist in the
 *               result to be fetched, and
 *               @a offset & @a limit to request subsequent pages of results.
 * @param options
 *                 <ul>
 *                         <li> gpudb::get_records_expression: Optional filter
 *                 expression to apply to the table.
 *                         <li> gpudb::get_records_fast_index_lookup: Indicates
 *                 if indexes should be used to perform the lookup for a given
 *                 expression if possible. Only applicable if there is no
 *                 sorting, the expression contains only equivalence
 *                 comparisons based on existing tables indexes and the range
 *                 of requested values is from [0 to END_OF_SET].
 *                 <ul>
 *                         <li> gpudb::get_records_true
 *                         <li> gpudb::get_records_false
 *                 </ul>
 *                 The default value is gpudb::get_records_true.
 *                         <li> gpudb::get_records_sort_by: Optional column
 *                 that the data should be sorted by. Empty by default (i.e. no
 *                 sorting is applied).
 *                         <li> gpudb::get_records_sort_order: String
 *                 indicating how the returned values should be sorted -
 *                 ascending or descending. If sort_order is provided, sort_by
 *                 has to be provided.
 *                 <ul>
 *                         <li> gpudb::get_records_ascending
 *                         <li> gpudb::get_records_descending
 *                 </ul>
 *                 The default value is gpudb::get_records_ascending.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse> getRecords( const Type& type_,
                                          const std::string& tableName,
                                          const int64_t offset,
                                          const int64_t limit,
                                          const std::map<std::string, std::string>& options ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    GetRecordsResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.  Note that when paging through a table, if the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param tableName  Name of the table or view from which the records will be
 *                   fetched, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a hasMoreRecords to see if more records exist in the
 *               result to be fetched, and
 *               @a offset & @a limit to request subsequent pages of results.
 * @param options
 *                 <ul>
 *                         <li> gpudb::get_records_expression: Optional filter
 *                 expression to apply to the table.
 *                         <li> gpudb::get_records_fast_index_lookup: Indicates
 *                 if indexes should be used to perform the lookup for a given
 *                 expression if possible. Only applicable if there is no
 *                 sorting, the expression contains only equivalence
 *                 comparisons based on existing tables indexes and the range
 *                 of requested values is from [0 to END_OF_SET].
 *                 <ul>
 *                         <li> gpudb::get_records_true
 *                         <li> gpudb::get_records_false
 *                 </ul>
 *                 The default value is gpudb::get_records_true.
 *                         <li> gpudb::get_records_sort_by: Optional column
 *                 that the data should be sorted by. Empty by default (i.e. no
 *                 sorting is applied).
 *                         <li> gpudb::get_records_sort_order: String
 *                 indicating how the returned values should be sorted -
 *                 ascending or descending. If sort_order is provided, sort_by
 *                 has to be provided.
 *                 <ul>
 *                         <li> gpudb::get_records_ascending
 *                         <li> gpudb::get_records_descending
 *                 </ul>
 *                 The default value is gpudb::get_records_ascending.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse>& getRecords( const ::avro::ValidSchema& schema_,
                                           const std::string& tableName,
                                           const int64_t offset,
                                           const int64_t limit,
                                           const std::map<std::string, std::string>& options,
                                           GetRecordsResponse<TResponse>& response_ ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.  Note that when paging through a table, if the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] type_  Type object used for decoding returned objects.
 * @param tableName  Name of the table or view from which the records will be
 *                   fetched, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a hasMoreRecords to see if more records exist in the
 *               result to be fetched, and
 *               @a offset & @a limit to request subsequent pages of results.
 * @param options
 *                 <ul>
 *                         <li> gpudb::get_records_expression: Optional filter
 *                 expression to apply to the table.
 *                         <li> gpudb::get_records_fast_index_lookup: Indicates
 *                 if indexes should be used to perform the lookup for a given
 *                 expression if possible. Only applicable if there is no
 *                 sorting, the expression contains only equivalence
 *                 comparisons based on existing tables indexes and the range
 *                 of requested values is from [0 to END_OF_SET].
 *                 <ul>
 *                         <li> gpudb::get_records_true
 *                         <li> gpudb::get_records_false
 *                 </ul>
 *                 The default value is gpudb::get_records_true.
 *                         <li> gpudb::get_records_sort_by: Optional column
 *                 that the data should be sorted by. Empty by default (i.e. no
 *                 sorting is applied).
 *                         <li> gpudb::get_records_sort_order: String
 *                 indicating how the returned values should be sorted -
 *                 ascending or descending. If sort_order is provided, sort_by
 *                 has to be provided.
 *                 <ul>
 *                         <li> gpudb::get_records_ascending
 *                         <li> gpudb::get_records_descending
 *                 </ul>
 *                 The default value is gpudb::get_records_ascending.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse>& getRecords( const Type& type_,
                                           const std::string& tableName,
                                           const int64_t offset,
                                           const int64_t limit,
                                           const std::map<std::string, std::string>& options,
                                           GetRecordsResponse<TResponse>& response_ ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * For a given table, retrieves the values from the requested
 * column(s). Maps of column name to the array of values as well as the column
 * data
 * type are returned. This endpoint supports pagination with the @a offset
 * and @a limit parameters.
 * <p>
 * <a href="../../../concepts/window/" target="_top">Window functions</a>,
 * which can perform
 * operations like moving averages, are available through this endpoint as well
 * as
 * {@link #createProjection(const CreateProjectionRequest&) const}.
 * <p>
 * When using pagination, if the table (or the underlying table in the case of
 * a
 * view) is modified (records are inserted, updated, or deleted) during a call
 * to
 * the endpoint, the records or values retrieved may differ between calls based
 * on
 * the type of the update, e.g., the contiguity across pages cannot be relied
 * upon.
 * <p>
 * If @a tableName is empty, selection is performed against a single-row
 * virtual table.  This can be useful in executing temporal
 * (<a href="../../../concepts/expressions/#date-time-functions"
 * target="_top">NOW()</a>), identity
 * (<a href="../../../concepts/expressions/#user-security-functions"
 * target="_top">USER()</a>), or
 * constant-based functions
 * (<a href="../../../concepts/expressions/#scalar-functions"
 * target="_top">GEODIST(-77.11, 38.88, -71.06, 42.36)</a>).
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsByColumnResponse getRecordsByColumnRaw( const GetRecordsByColumnRequest& request_ ) const;

/**
 * For a given table, retrieves the values from the requested
 * column(s). Maps of column name to the array of values as well as the column
 * data
 * type are returned. This endpoint supports pagination with the @a offset
 * and @a limit parameters.
 * <p>
 * <a href="../../../concepts/window/" target="_top">Window functions</a>,
 * which can perform
 * operations like moving averages, are available through this endpoint as well
 * as
 * {@link
 * #createProjection(const CreateProjectionRequest&,CreateProjectionResponse&) const}.
 * <p>
 * When using pagination, if the table (or the underlying table in the case of
 * a
 * view) is modified (records are inserted, updated, or deleted) during a call
 * to
 * the endpoint, the records or values retrieved may differ between calls based
 * on
 * the type of the update, e.g., the contiguity across pages cannot be relied
 * upon.
 * <p>
 * If @a tableName is empty, selection is performed against a single-row
 * virtual table.  This can be useful in executing temporal
 * (<a href="../../../concepts/expressions/#date-time-functions"
 * target="_top">NOW()</a>), identity
 * (<a href="../../../concepts/expressions/#user-security-functions"
 * target="_top">USER()</a>), or
 * constant-based functions
 * (<a href="../../../concepts/expressions/#scalar-functions"
 * target="_top">GEODIST(-77.11, 38.88, -71.06, 42.36)</a>).
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsByColumnResponse& getRecordsByColumnRaw( const GetRecordsByColumnRequest& request_,
                                                      RawGetRecordsByColumnResponse& response_ ) const;

/**
 * For a given table, retrieves the values from the requested
 * column(s). Maps of column name to the array of values as well as the column
 * data
 * type are returned. This endpoint supports pagination with the @a offset
 * and @a limit parameters.
 * <p>
 * <a href="../../../concepts/window/" target="_top">Window functions</a>,
 * which can perform
 * operations like moving averages, are available through this endpoint as well
 * as
 * {@link #createProjection(const CreateProjectionRequest&) const}.
 * <p>
 * When using pagination, if the table (or the underlying table in the case of
 * a
 * view) is modified (records are inserted, updated, or deleted) during a call
 * to
 * the endpoint, the records or values retrieved may differ between calls based
 * on
 * the type of the update, e.g., the contiguity across pages cannot be relied
 * upon.
 * <p>
 * If @a tableName is empty, selection is performed against a single-row
 * virtual table.  This can be useful in executing temporal
 * (<a href="../../../concepts/expressions/#date-time-functions"
 * target="_top">NOW()</a>), identity
 * (<a href="../../../concepts/expressions/#user-security-functions"
 * target="_top">USER()</a>), or
 * constant-based functions
 * (<a href="../../../concepts/expressions/#scalar-functions"
 * target="_top">GEODIST(-77.11, 38.88, -71.06, 42.36)</a>).
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetRecordsByColumnResponse getRecordsByColumn( const GetRecordsByColumnRequest& request_ ) const;

/**
 * For a given table, retrieves the values from the requested
 * column(s). Maps of column name to the array of values as well as the column
 * data
 * type are returned. This endpoint supports pagination with the @a offset
 * and @a limit parameters.
 * <p>
 * <a href="../../../concepts/window/" target="_top">Window functions</a>,
 * which can perform
 * operations like moving averages, are available through this endpoint as well
 * as
 * {@link #createProjection(const CreateProjectionRequest&) const}.
 * <p>
 * When using pagination, if the table (or the underlying table in the case of
 * a
 * view) is modified (records are inserted, updated, or deleted) during a call
 * to
 * the endpoint, the records or values retrieved may differ between calls based
 * on
 * the type of the update, e.g., the contiguity across pages cannot be relied
 * upon.
 * <p>
 * If @a tableName is empty, selection is performed against a single-row
 * virtual table.  This can be useful in executing temporal
 * (<a href="../../../concepts/expressions/#date-time-functions"
 * target="_top">NOW()</a>), identity
 * (<a href="../../../concepts/expressions/#user-security-functions"
 * target="_top">USER()</a>), or
 * constant-based functions
 * (<a href="../../../concepts/expressions/#scalar-functions"
 * target="_top">GEODIST(-77.11, 38.88, -71.06, 42.36)</a>).
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetRecordsByColumnResponse& getRecordsByColumn( const GetRecordsByColumnRequest& request_,
                                                GetRecordsByColumnResponse& response_ ) const;

/**
 * For a given table, retrieves the values from the requested
 * column(s). Maps of column name to the array of values as well as the column
 * data
 * type are returned. This endpoint supports pagination with the @a offset
 * and @a limit parameters.
 * <p>
 * <a href="../../../concepts/window/" target="_top">Window functions</a>,
 * which can perform
 * operations like moving averages, are available through this endpoint as well
 * as
 * {@link
 * #createProjection(const std::string&,const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * When using pagination, if the table (or the underlying table in the case of
 * a
 * view) is modified (records are inserted, updated, or deleted) during a call
 * to
 * the endpoint, the records or values retrieved may differ between calls based
 * on
 * the type of the update, e.g., the contiguity across pages cannot be relied
 * upon.
 * <p>
 * If @a tableName is empty, selection is performed against a single-row
 * virtual table.  This can be useful in executing temporal
 * (<a href="../../../concepts/expressions/#date-time-functions"
 * target="_top">NOW()</a>), identity
 * (<a href="../../../concepts/expressions/#user-security-functions"
 * target="_top">USER()</a>), or
 * constant-based functions
 * (<a href="../../../concepts/expressions/#scalar-functions"
 * target="_top">GEODIST(-77.11, 38.88, -71.06, 42.36)</a>).
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param tableName  Name of the table or view on which this operation will be
 *                   performed, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  An empty table
 *                   name retrieves one record from a single-row virtual table,
 *                   where columns specified should be constants or constant
 *                   expressions.
 * @param columnNames  The list of column values to retrieve.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a hasMoreRecords to see if more records exist in the
 *               result to be fetched, and
 *               @a offset & @a limit to request subsequent pages of results.
 * @param options
 *                 <ul>
 *                         <li> gpudb::get_records_by_column_expression:
 *                 Optional filter expression to apply to the table.
 *                         <li> gpudb::get_records_by_column_sort_by: Optional
 *                 column that the data should be sorted by. Used in
 *                 conjunction with @a sort_order. The @a order_by option can
 *                 be used in lieu of @a sort_by / @a sort_order.  The default
 *                 value is ''.
 *                         <li> gpudb::get_records_by_column_sort_order: String
 *                 indicating how the returned values should be sorted - @a
 *                 ascending or @a descending. If @a sort_order is provided, @a
 *                 sort_by has to be provided.
 *                 <ul>
 *                         <li> gpudb::get_records_by_column_ascending
 *                         <li> gpudb::get_records_by_column_descending
 *                 </ul>
 *                 The default value is gpudb::get_records_by_column_ascending.
 *                         <li> gpudb::get_records_by_column_order_by:
 *                 Comma-separated list of the columns to be sorted by as well
 *                 as the sort direction, e.g., 'timestamp asc, x desc'.  The
 *                 default value is ''.
 *                         <li>
 *                 gpudb::get_records_by_column_convert_wkts_to_wkbs: If @a
 *                 true, then WKT string columns will be returned as WKB bytes.
 *                 <ul>
 *                         <li> gpudb::get_records_by_column_true
 *                         <li> gpudb::get_records_by_column_false
 *                 </ul>
 *                 The default value is gpudb::get_records_by_column_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetRecordsByColumnResponse getRecordsByColumn( const std::string& tableName,
                                               const std::vector<std::string>& columnNames,
                                               const int64_t offset,
                                               const int64_t limit,
                                               const std::map<std::string, std::string>& options ) const;

/**
 * For a given table, retrieves the values from the requested
 * column(s). Maps of column name to the array of values as well as the column
 * data
 * type are returned. This endpoint supports pagination with the @a offset
 * and @a limit parameters.
 * <p>
 * <a href="../../../concepts/window/" target="_top">Window functions</a>,
 * which can perform
 * operations like moving averages, are available through this endpoint as well
 * as
 * {@link
 * #createProjection(const std::string&,const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * When using pagination, if the table (or the underlying table in the case of
 * a
 * view) is modified (records are inserted, updated, or deleted) during a call
 * to
 * the endpoint, the records or values retrieved may differ between calls based
 * on
 * the type of the update, e.g., the contiguity across pages cannot be relied
 * upon.
 * <p>
 * If @a tableName is empty, selection is performed against a single-row
 * virtual table.  This can be useful in executing temporal
 * (<a href="../../../concepts/expressions/#date-time-functions"
 * target="_top">NOW()</a>), identity
 * (<a href="../../../concepts/expressions/#user-security-functions"
 * target="_top">USER()</a>), or
 * constant-based functions
 * (<a href="../../../concepts/expressions/#scalar-functions"
 * target="_top">GEODIST(-77.11, 38.88, -71.06, 42.36)</a>).
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param tableName  Name of the table or view on which this operation will be
 *                   performed, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  An empty table
 *                   name retrieves one record from a single-row virtual table,
 *                   where columns specified should be constants or constant
 *                   expressions.
 * @param columnNames  The list of column values to retrieve.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a hasMoreRecords to see if more records exist in the
 *               result to be fetched, and
 *               @a offset & @a limit to request subsequent pages of results.
 * @param options
 *                 <ul>
 *                         <li> gpudb::get_records_by_column_expression:
 *                 Optional filter expression to apply to the table.
 *                         <li> gpudb::get_records_by_column_sort_by: Optional
 *                 column that the data should be sorted by. Used in
 *                 conjunction with @a sort_order. The @a order_by option can
 *                 be used in lieu of @a sort_by / @a sort_order.  The default
 *                 value is ''.
 *                         <li> gpudb::get_records_by_column_sort_order: String
 *                 indicating how the returned values should be sorted - @a
 *                 ascending or @a descending. If @a sort_order is provided, @a
 *                 sort_by has to be provided.
 *                 <ul>
 *                         <li> gpudb::get_records_by_column_ascending
 *                         <li> gpudb::get_records_by_column_descending
 *                 </ul>
 *                 The default value is gpudb::get_records_by_column_ascending.
 *                         <li> gpudb::get_records_by_column_order_by:
 *                 Comma-separated list of the columns to be sorted by as well
 *                 as the sort direction, e.g., 'timestamp asc, x desc'.  The
 *                 default value is ''.
 *                         <li>
 *                 gpudb::get_records_by_column_convert_wkts_to_wkbs: If @a
 *                 true, then WKT string columns will be returned as WKB bytes.
 *                 <ul>
 *                         <li> gpudb::get_records_by_column_true
 *                         <li> gpudb::get_records_by_column_false
 *                 </ul>
 *                 The default value is gpudb::get_records_by_column_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetRecordsByColumnResponse& getRecordsByColumn( const std::string& tableName,
                                                const std::vector<std::string>& columnNames,
                                                const int64_t offset,
                                                const int64_t limit,
                                                const std::map<std::string, std::string>& options,
                                                GetRecordsByColumnResponse& response_ ) const;

/**
 * Retrieves the complete series/track records from the given
 * @a worldTableName based on the partial track information contained in
 * the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * In contrast to {@link #getRecordsRaw(const GetRecordsRequest&) const}
 * this returns records grouped by
 * series/track. So if @a offset is 0 and @a limit is 5 this operation
 * would return the first 5 series/tracks in @a tableName. Each series/track
 * will be returned sorted by their TIMESTAMP column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsBySeriesResponse getRecordsBySeriesRaw( const GetRecordsBySeriesRequest& request_ ) const;

/**
 * Retrieves the complete series/track records from the given
 * @a worldTableName based on the partial track information contained in
 * the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecordsRaw(const GetRecordsRequest&,RawGetRecordsResponse&) const}
 * this returns records grouped by
 * series/track. So if @a offset is 0 and @a limit is 5 this operation
 * would return the first 5 series/tracks in @a tableName. Each series/track
 * will be returned sorted by their TIMESTAMP column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsBySeriesResponse& getRecordsBySeriesRaw( const GetRecordsBySeriesRequest& request_,
                                                      RawGetRecordsBySeriesResponse& response_ ) const;

/**
 * Retrieves the complete series/track records from the given
 * @a worldTableName based on the partial track information contained in
 * the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * In contrast to {@link #getRecords(const GetRecordsRequest&) const} this
 * returns records grouped by
 * series/track. So if @a offset is 0 and @a limit is 5 this operation
 * would return the first 5 series/tracks in @a tableName. Each series/track
 * will be returned sorted by their TIMESTAMP column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse> getRecordsBySeries( const GetRecordsBySeriesRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    GetRecordsBySeriesResponse<TResponse> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse());
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given
 * @a worldTableName based on the partial track information contained in
 * the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const GetRecordsRequest&,GetRecordsResponse<TResponse>&) const}
 * this returns records grouped by
 * series/track. So if @a offset is 0 and @a limit is 5 this operation
 * would return the first 5 series/tracks in @a tableName. Each series/track
 * will be returned sorted by their TIMESTAMP column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse>& getRecordsBySeries( const GetRecordsBySeriesRequest& request_,
                                                           GetRecordsBySeriesResponse<TResponse>& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse());
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given
 * @a worldTableName based on the partial track information contained in
 * the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const std::string&,const int64_t,const int64_t,const std::map<std::string, std::string>&) const}
 * this returns records grouped by
 * series/track. So if @a offset is 0 and @a limit is 5 this operation
 * would return the first 5 series/tracks in @a tableName. Each series/track
 * will be returned sorted by their TIMESTAMP column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param tableName  Name of the table or view for which series/tracks will be
 *                   fetched, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param worldTableName  Name of the table containing the complete
 *                        series/track information to be returned for the
 *                        tracks present in the @a tableName, in
 *                        [schema_name.]table_name format, using standard <a
 *                        href="../../../concepts/tables/#table-name-resolution"
 *                        target="_top">name resolution rules</a>.  Typically
 *                        this is used when retrieving series/tracks from a
 *                        view (which contains partial series/tracks) but the
 *                        user wants to retrieve the entire original
 *                        series/tracks. Can be blank.
 * @param offset  A positive integer indicating the number of initial
 *                series/tracks to skip (useful for paging through the
 *                results).  The minimum allowed value is 0. The maximum
 *                allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of
 *               series/tracks to be returned. Or END_OF_SET (-9999) to
 *               indicate that the max number of results should be returned.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse> getRecordsBySeries( const std::string& tableName,
                                                          const std::string& worldTableName,
                                                          const int32_t offset,
                                                          const int32_t limit,
                                                          const std::map<std::string, std::string>& options ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    GetRecordsBySeriesResponse<TResponse> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse());
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given
 * @a worldTableName based on the partial track information contained in
 * the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const std::string&,const int64_t,const int64_t,const std::map<std::string, std::string>&,GetRecordsResponse<TResponse>&) const}
 * this returns records grouped by
 * series/track. So if @a offset is 0 and @a limit is 5 this operation
 * would return the first 5 series/tracks in @a tableName. Each series/track
 * will be returned sorted by their TIMESTAMP column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param tableName  Name of the table or view for which series/tracks will be
 *                   fetched, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param worldTableName  Name of the table containing the complete
 *                        series/track information to be returned for the
 *                        tracks present in the @a tableName, in
 *                        [schema_name.]table_name format, using standard <a
 *                        href="../../../concepts/tables/#table-name-resolution"
 *                        target="_top">name resolution rules</a>.  Typically
 *                        this is used when retrieving series/tracks from a
 *                        view (which contains partial series/tracks) but the
 *                        user wants to retrieve the entire original
 *                        series/tracks. Can be blank.
 * @param offset  A positive integer indicating the number of initial
 *                series/tracks to skip (useful for paging through the
 *                results).  The minimum allowed value is 0. The maximum
 *                allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of
 *               series/tracks to be returned. Or END_OF_SET (-9999) to
 *               indicate that the max number of results should be returned.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse>& getRecordsBySeries( const std::string& tableName,
                                                           const std::string& worldTableName,
                                                           const int32_t offset,
                                                           const int32_t limit,
                                                           const std::map<std::string, std::string>& options,
                                                           GetRecordsBySeriesResponse<TResponse>& response_ ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse());
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given
 * @a worldTableName based on the partial track information contained in
 * the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const ::avro::ValidSchema&,const GetRecordsRequest&) const}
 * this returns records grouped by
 * series/track. So if @a offset is 0 and @a limit is 5 this operation
 * would return the first 5 series/tracks in @a tableName. Each series/track
 * will be returned sorted by their TIMESTAMP column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse> getRecordsBySeries( const ::avro::ValidSchema& schema_,
                                                          const GetRecordsBySeriesRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    GetRecordsBySeriesResponse<TResponse> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(schema_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given
 * @a worldTableName based on the partial track information contained in
 * the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const Type&,const GetRecordsRequest&) const} this returns
 * records grouped by
 * series/track. So if @a offset is 0 and @a limit is 5 this operation
 * would return the first 5 series/tracks in @a tableName. Each series/track
 * will be returned sorted by their TIMESTAMP column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] type_  Type object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse> getRecordsBySeries( const Type& type_,
                                                          const GetRecordsBySeriesRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    GetRecordsBySeriesResponse<TResponse> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(type_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given
 * @a worldTableName based on the partial track information contained in
 * the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const ::avro::ValidSchema&,const GetRecordsRequest&,GetRecordsResponse<TResponse>&) const}
 * this returns records grouped by
 * series/track. So if @a offset is 0 and @a limit is 5 this operation
 * would return the first 5 series/tracks in @a tableName. Each series/track
 * will be returned sorted by their TIMESTAMP column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse>& getRecordsBySeries( const ::avro::ValidSchema& schema_,
                                                           const GetRecordsBySeriesRequest& request_,
                                                           GetRecordsBySeriesResponse<TResponse>& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(schema_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given
 * @a worldTableName based on the partial track information contained in
 * the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const Type&,const GetRecordsRequest&,GetRecordsResponse<TResponse>&) const}
 * this returns records grouped by
 * series/track. So if @a offset is 0 and @a limit is 5 this operation
 * would return the first 5 series/tracks in @a tableName. Each series/track
 * will be returned sorted by their TIMESTAMP column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] type_  Type object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse>& getRecordsBySeries( const Type& type_,
                                                           const GetRecordsBySeriesRequest& request_,
                                                           GetRecordsBySeriesResponse<TResponse>& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(type_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given
 * @a worldTableName based on the partial track information contained in
 * the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const ::avro::ValidSchema&,const std::string&,const int64_t,const int64_t,const std::map<std::string, std::string>&) const}
 * this returns records grouped by
 * series/track. So if @a offset is 0 and @a limit is 5 this operation
 * would return the first 5 series/tracks in @a tableName. Each series/track
 * will be returned sorted by their TIMESTAMP column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param tableName  Name of the table or view for which series/tracks will be
 *                   fetched, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param worldTableName  Name of the table containing the complete
 *                        series/track information to be returned for the
 *                        tracks present in the @a tableName, in
 *                        [schema_name.]table_name format, using standard <a
 *                        href="../../../concepts/tables/#table-name-resolution"
 *                        target="_top">name resolution rules</a>.  Typically
 *                        this is used when retrieving series/tracks from a
 *                        view (which contains partial series/tracks) but the
 *                        user wants to retrieve the entire original
 *                        series/tracks. Can be blank.
 * @param offset  A positive integer indicating the number of initial
 *                series/tracks to skip (useful for paging through the
 *                results).  The minimum allowed value is 0. The maximum
 *                allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of
 *               series/tracks to be returned. Or END_OF_SET (-9999) to
 *               indicate that the max number of results should be returned.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse> getRecordsBySeries( const ::avro::ValidSchema& schema_,
                                                          const std::string& tableName,
                                                          const std::string& worldTableName,
                                                          const int32_t offset,
                                                          const int32_t limit,
                                                          const std::map<std::string, std::string>& options ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    GetRecordsBySeriesResponse<TResponse> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(schema_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given
 * @a worldTableName based on the partial track information contained in
 * the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const Type&,const std::string&,const int64_t,const int64_t,const std::map<std::string, std::string>&) const}
 * this returns records grouped by
 * series/track. So if @a offset is 0 and @a limit is 5 this operation
 * would return the first 5 series/tracks in @a tableName. Each series/track
 * will be returned sorted by their TIMESTAMP column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] type_  Type object used for decoding returned objects.
 * @param tableName  Name of the table or view for which series/tracks will be
 *                   fetched, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param worldTableName  Name of the table containing the complete
 *                        series/track information to be returned for the
 *                        tracks present in the @a tableName, in
 *                        [schema_name.]table_name format, using standard <a
 *                        href="../../../concepts/tables/#table-name-resolution"
 *                        target="_top">name resolution rules</a>.  Typically
 *                        this is used when retrieving series/tracks from a
 *                        view (which contains partial series/tracks) but the
 *                        user wants to retrieve the entire original
 *                        series/tracks. Can be blank.
 * @param offset  A positive integer indicating the number of initial
 *                series/tracks to skip (useful for paging through the
 *                results).  The minimum allowed value is 0. The maximum
 *                allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of
 *               series/tracks to be returned. Or END_OF_SET (-9999) to
 *               indicate that the max number of results should be returned.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse> getRecordsBySeries( const Type& type_,
                                                          const std::string& tableName,
                                                          const std::string& worldTableName,
                                                          const int32_t offset,
                                                          const int32_t limit,
                                                          const std::map<std::string, std::string>& options ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    GetRecordsBySeriesResponse<TResponse> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(type_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given
 * @a worldTableName based on the partial track information contained in
 * the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const ::avro::ValidSchema&,const std::string&,const int64_t,const int64_t,const std::map<std::string, std::string>&,GetRecordsResponse<TResponse>&) const}
 * this returns records grouped by
 * series/track. So if @a offset is 0 and @a limit is 5 this operation
 * would return the first 5 series/tracks in @a tableName. Each series/track
 * will be returned sorted by their TIMESTAMP column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param tableName  Name of the table or view for which series/tracks will be
 *                   fetched, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param worldTableName  Name of the table containing the complete
 *                        series/track information to be returned for the
 *                        tracks present in the @a tableName, in
 *                        [schema_name.]table_name format, using standard <a
 *                        href="../../../concepts/tables/#table-name-resolution"
 *                        target="_top">name resolution rules</a>.  Typically
 *                        this is used when retrieving series/tracks from a
 *                        view (which contains partial series/tracks) but the
 *                        user wants to retrieve the entire original
 *                        series/tracks. Can be blank.
 * @param offset  A positive integer indicating the number of initial
 *                series/tracks to skip (useful for paging through the
 *                results).  The minimum allowed value is 0. The maximum
 *                allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of
 *               series/tracks to be returned. Or END_OF_SET (-9999) to
 *               indicate that the max number of results should be returned.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse>& getRecordsBySeries( const ::avro::ValidSchema& schema_,
                                                           const std::string& tableName,
                                                           const std::string& worldTableName,
                                                           const int32_t offset,
                                                           const int32_t limit,
                                                           const std::map<std::string, std::string>& options,
                                                           GetRecordsBySeriesResponse<TResponse>& response_ ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(schema_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given
 * @a worldTableName based on the partial track information contained in
 * the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const Type&,const std::string&,const int64_t,const int64_t,const std::map<std::string, std::string>&,GetRecordsResponse<TResponse>&) const}
 * this returns records grouped by
 * series/track. So if @a offset is 0 and @a limit is 5 this operation
 * would return the first 5 series/tracks in @a tableName. Each series/track
 * will be returned sorted by their TIMESTAMP column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] type_  Type object used for decoding returned objects.
 * @param tableName  Name of the table or view for which series/tracks will be
 *                   fetched, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param worldTableName  Name of the table containing the complete
 *                        series/track information to be returned for the
 *                        tracks present in the @a tableName, in
 *                        [schema_name.]table_name format, using standard <a
 *                        href="../../../concepts/tables/#table-name-resolution"
 *                        target="_top">name resolution rules</a>.  Typically
 *                        this is used when retrieving series/tracks from a
 *                        view (which contains partial series/tracks) but the
 *                        user wants to retrieve the entire original
 *                        series/tracks. Can be blank.
 * @param offset  A positive integer indicating the number of initial
 *                series/tracks to skip (useful for paging through the
 *                results).  The minimum allowed value is 0. The maximum
 *                allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of
 *               series/tracks to be returned. Or END_OF_SET (-9999) to
 *               indicate that the max number of results should be returned.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse>& getRecordsBySeries( const Type& type_,
                                                           const std::string& tableName,
                                                           const std::string& worldTableName,
                                                           const int32_t offset,
                                                           const int32_t limit,
                                                           const std::map<std::string, std::string>& options,
                                                           GetRecordsBySeriesResponse<TResponse>& response_ ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(type_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@link #deleteRecords(const DeleteRecordsRequest&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsFromCollectionResponse getRecordsFromCollectionRaw( const GetRecordsFromCollectionRequest& request_ ) const;

/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@link
 * #deleteRecords(const DeleteRecordsRequest&,DeleteRecordsResponse&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsFromCollectionResponse& getRecordsFromCollectionRaw( const GetRecordsFromCollectionRequest& request_,
                                                                  RawGetRecordsFromCollectionResponse& response_ ) const;

/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@link #deleteRecords(const DeleteRecordsRequest&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection( const GetRecordsFromCollectionRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    GetRecordsFromCollectionResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@link
 * #deleteRecords(const DeleteRecordsRequest&,DeleteRecordsResponse&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse>& getRecordsFromCollection( const GetRecordsFromCollectionRequest& request_,
                                                                       GetRecordsFromCollectionResponse<TResponse>& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param tableName  Name of the collection or table from which records are to
 *                   be retrieved, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing collection or table.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a offset & @a limit to request subsequent pages of
 *               results.
 * @param options
 *                 <ul>
 *                         <li>
 *                 gpudb::get_records_from_collection_return_record_ids: If @a
 *                 true then return the internal record ID along with each
 *                 returned record.
 *                 <ul>
 *                         <li> gpudb::get_records_from_collection_true
 *                         <li> gpudb::get_records_from_collection_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::get_records_from_collection_false.
 *                         <li> gpudb::get_records_from_collection_expression:
 *                 Optional filter expression to apply to the table.  The
 *                 default value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection( const std::string& tableName,
                                                                      const int64_t offset,
                                                                      const int64_t limit,
                                                                      const std::map<std::string, std::string>& options ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    GetRecordsFromCollectionResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&,DeleteRecordsResponse&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param tableName  Name of the collection or table from which records are to
 *                   be retrieved, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing collection or table.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a offset & @a limit to request subsequent pages of
 *               results.
 * @param options
 *                 <ul>
 *                         <li>
 *                 gpudb::get_records_from_collection_return_record_ids: If @a
 *                 true then return the internal record ID along with each
 *                 returned record.
 *                 <ul>
 *                         <li> gpudb::get_records_from_collection_true
 *                         <li> gpudb::get_records_from_collection_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::get_records_from_collection_false.
 *                         <li> gpudb::get_records_from_collection_expression:
 *                 Optional filter expression to apply to the table.  The
 *                 default value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse>& getRecordsFromCollection( const std::string& tableName,
                                                                       const int64_t offset,
                                                                       const int64_t limit,
                                                                       const std::map<std::string, std::string>& options,
                                                                       GetRecordsFromCollectionResponse<TResponse>& response_ ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@link #deleteRecords(const DeleteRecordsRequest&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection( const ::avro::ValidSchema& schema_,
                                                                      const GetRecordsFromCollectionRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    GetRecordsFromCollectionResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@link #deleteRecords(const DeleteRecordsRequest&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] type_  Type object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection( const Type& type_,
                                                                      const GetRecordsFromCollectionRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    GetRecordsFromCollectionResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@link #deleteRecords(const DeleteRecordsRequest&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse>& getRecordsFromCollection( const ::avro::ValidSchema& schema_,
                                                                       const GetRecordsFromCollectionRequest& request_,
                                                                       GetRecordsFromCollectionResponse<TResponse>& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@link #deleteRecords(const DeleteRecordsRequest&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] type_  Type object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse>& getRecordsFromCollection( const Type& type_,
                                                                       const GetRecordsFromCollectionRequest& request_,
                                                                       GetRecordsFromCollectionResponse<TResponse>& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param tableName  Name of the collection or table from which records are to
 *                   be retrieved, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing collection or table.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a offset & @a limit to request subsequent pages of
 *               results.
 * @param options
 *                 <ul>
 *                         <li>
 *                 gpudb::get_records_from_collection_return_record_ids: If @a
 *                 true then return the internal record ID along with each
 *                 returned record.
 *                 <ul>
 *                         <li> gpudb::get_records_from_collection_true
 *                         <li> gpudb::get_records_from_collection_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::get_records_from_collection_false.
 *                         <li> gpudb::get_records_from_collection_expression:
 *                 Optional filter expression to apply to the table.  The
 *                 default value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection( const ::avro::ValidSchema& schema_,
                                                                      const std::string& tableName,
                                                                      const int64_t offset,
                                                                      const int64_t limit,
                                                                      const std::map<std::string, std::string>& options ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    GetRecordsFromCollectionResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] type_  Type object used for decoding returned objects.
 * @param tableName  Name of the collection or table from which records are to
 *                   be retrieved, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing collection or table.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a offset & @a limit to request subsequent pages of
 *               results.
 * @param options
 *                 <ul>
 *                         <li>
 *                 gpudb::get_records_from_collection_return_record_ids: If @a
 *                 true then return the internal record ID along with each
 *                 returned record.
 *                 <ul>
 *                         <li> gpudb::get_records_from_collection_true
 *                         <li> gpudb::get_records_from_collection_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::get_records_from_collection_false.
 *                         <li> gpudb::get_records_from_collection_expression:
 *                 Optional filter expression to apply to the table.  The
 *                 default value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection( const Type& type_,
                                                                      const std::string& tableName,
                                                                      const int64_t offset,
                                                                      const int64_t limit,
                                                                      const std::map<std::string, std::string>& options ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    GetRecordsFromCollectionResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param tableName  Name of the collection or table from which records are to
 *                   be retrieved, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing collection or table.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a offset & @a limit to request subsequent pages of
 *               results.
 * @param options
 *                 <ul>
 *                         <li>
 *                 gpudb::get_records_from_collection_return_record_ids: If @a
 *                 true then return the internal record ID along with each
 *                 returned record.
 *                 <ul>
 *                         <li> gpudb::get_records_from_collection_true
 *                         <li> gpudb::get_records_from_collection_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::get_records_from_collection_false.
 *                         <li> gpudb::get_records_from_collection_expression:
 *                 Optional filter expression to apply to the table.  The
 *                 default value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse>& getRecordsFromCollection( const ::avro::ValidSchema& schema_,
                                                                       const std::string& tableName,
                                                                       const int64_t offset,
                                                                       const int64_t limit,
                                                                       const std::map<std::string, std::string>& options,
                                                                       GetRecordsFromCollectionResponse<TResponse>& response_ ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and
 * @a limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] type_  Type object used for decoding returned objects.
 * @param tableName  Name of the collection or table from which records are to
 *                   be retrieved, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing collection or table.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be
 *               returned.  The number of records returned will never exceed
 *               the server's own limit, defined by the
 *               <a href="../../../config/#config-main-general"
 *               target="_top">max_get_records_size</a> parameter in the server
 *               configuration.
 *               Use @a offset & @a limit to request subsequent pages of
 *               results.
 * @param options
 *                 <ul>
 *                         <li>
 *                 gpudb::get_records_from_collection_return_record_ids: If @a
 *                 true then return the internal record ID along with each
 *                 returned record.
 *                 <ul>
 *                         <li> gpudb::get_records_from_collection_true
 *                         <li> gpudb::get_records_from_collection_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::get_records_from_collection_false.
 *                         <li> gpudb::get_records_from_collection_expression:
 *                 Optional filter expression to apply to the table.  The
 *                 default value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse>& getRecordsFromCollection( const Type& type_,
                                                                       const std::string& tableName,
                                                                       const int64_t offset,
                                                                       const int64_t limit,
                                                                       const std::map<std::string, std::string>& options,
                                                                       GetRecordsFromCollectionResponse<TResponse>& response_ ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetVectortileResponse getVectortile( const GetVectortileRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetVectortileResponse& getVectortile( const GetVectortileRequest& request_,
                                      GetVectortileResponse& response_ ) const;

/**
 * @private
 * 
 * @param tableNames
 * @param columnNames
 * @param layers
 * @param tileX
 * @param tileY
 * @param zoom
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetVectortileResponse getVectortile( const std::vector<std::string>& tableNames,
                                     const std::vector<std::string>& columnNames,
                                     const std::map<std::string, std::vector<std::string> >& layers,
                                     const int32_t tileX,
                                     const int32_t tileY,
                                     const int32_t zoom,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param tableNames
 * @param columnNames
 * @param layers
 * @param tileX
 * @param tileY
 * @param zoom
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetVectortileResponse& getVectortile( const std::vector<std::string>& tableNames,
                                      const std::vector<std::string>& columnNames,
                                      const std::map<std::string, std::vector<std::string> >& layers,
                                      const int32_t tileX,
                                      const int32_t tileY,
                                      const int32_t zoom,
                                      const std::map<std::string, std::string>& options,
                                      GetVectortileResponse& response_ ) const;

/**
 * Grant user or role the specified permission on the specified object.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionResponse grantPermission( const GrantPermissionRequest& request_ ) const;

/**
 * Grant user or role the specified permission on the specified object.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionResponse& grantPermission( const GrantPermissionRequest& request_,
                                          GrantPermissionResponse& response_ ) const;

/**
 * Grant user or role the specified permission on the specified object.
 * 
 * @param principal  Name of the user or role for which the permission is being
 *                   granted.  Must be an existing user or role.
 * @param object  Name of object permission is being granted to.  It is
 *                recommended to use a fully-qualified name when possible.
 * @param objectType  The type of object being granted to
 *                    <ul>
 *                            <li> gpudb::grant_permission_context: Context
 *                            <li> gpudb::grant_permission_credential:
 *                    Credential
 *                            <li> gpudb::grant_permission_datasink: Data Sink
 *                            <li> gpudb::grant_permission_datasource: Data
 *                    Source
 *                            <li> gpudb::grant_permission_directory: KIFS File
 *                    Directory
 *                            <li> gpudb::grant_permission_graph: A Graph
 *                    object
 *                            <li> gpudb::grant_permission_proc: UDF Procedure
 *                            <li> gpudb::grant_permission_schema: Schema
 *                            <li> gpudb::grant_permission_sql_proc: SQL
 *                    Procedure
 *                            <li> gpudb::grant_permission_system: System-level
 *                    access
 *                            <li> gpudb::grant_permission_table: Database
 *                    Table
 *                            <li> gpudb::grant_permission_table_monitor: Table
 *                    monitor
 *                    </ul>
 * @param permission  Permission being granted.
 *                    <ul>
 *                            <li> gpudb::grant_permission_admin: Full
 *                    read/write and administrative access on the object.
 *                            <li> gpudb::grant_permission_connect: Connect
 *                    access on the given data source or data sink.
 *                            <li> gpudb::grant_permission_delete: Delete rows
 *                    from tables.
 *                            <li> gpudb::grant_permission_execute: Ability to
 *                    Execute the Procedure object.
 *                            <li> gpudb::grant_permission_insert: Insert
 *                    access to tables.
 *                            <li> gpudb::grant_permission_read: Ability to
 *                    read, list and use the object.
 *                            <li> gpudb::grant_permission_update: Update
 *                    access to the table.
 *                            <li> gpudb::grant_permission_user_admin: Access
 *                    to administer users and roles that do not have
 *                    system_admin permission.
 *                            <li> gpudb::grant_permission_write: Access to
 *                    write, change and delete objects.
 *                    </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::grant_permission_columns: Apply table
 *                 security to these columns, comma-separated.  The default
 *                 value is ''.
 *                         <li> gpudb::grant_permission_filter_expression:
 *                 Optional filter expression to apply to this grant.  Only
 *                 rows that match the filter will be affected.  The default
 *                 value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionResponse grantPermission( const std::string& principal,
                                         const std::string& object,
                                         const std::string& objectType,
                                         const std::string& permission,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Grant user or role the specified permission on the specified object.
 * 
 * @param principal  Name of the user or role for which the permission is being
 *                   granted.  Must be an existing user or role.
 * @param object  Name of object permission is being granted to.  It is
 *                recommended to use a fully-qualified name when possible.
 * @param objectType  The type of object being granted to
 *                    <ul>
 *                            <li> gpudb::grant_permission_context: Context
 *                            <li> gpudb::grant_permission_credential:
 *                    Credential
 *                            <li> gpudb::grant_permission_datasink: Data Sink
 *                            <li> gpudb::grant_permission_datasource: Data
 *                    Source
 *                            <li> gpudb::grant_permission_directory: KIFS File
 *                    Directory
 *                            <li> gpudb::grant_permission_graph: A Graph
 *                    object
 *                            <li> gpudb::grant_permission_proc: UDF Procedure
 *                            <li> gpudb::grant_permission_schema: Schema
 *                            <li> gpudb::grant_permission_sql_proc: SQL
 *                    Procedure
 *                            <li> gpudb::grant_permission_system: System-level
 *                    access
 *                            <li> gpudb::grant_permission_table: Database
 *                    Table
 *                            <li> gpudb::grant_permission_table_monitor: Table
 *                    monitor
 *                    </ul>
 * @param permission  Permission being granted.
 *                    <ul>
 *                            <li> gpudb::grant_permission_admin: Full
 *                    read/write and administrative access on the object.
 *                            <li> gpudb::grant_permission_connect: Connect
 *                    access on the given data source or data sink.
 *                            <li> gpudb::grant_permission_delete: Delete rows
 *                    from tables.
 *                            <li> gpudb::grant_permission_execute: Ability to
 *                    Execute the Procedure object.
 *                            <li> gpudb::grant_permission_insert: Insert
 *                    access to tables.
 *                            <li> gpudb::grant_permission_read: Ability to
 *                    read, list and use the object.
 *                            <li> gpudb::grant_permission_update: Update
 *                    access to the table.
 *                            <li> gpudb::grant_permission_user_admin: Access
 *                    to administer users and roles that do not have
 *                    system_admin permission.
 *                            <li> gpudb::grant_permission_write: Access to
 *                    write, change and delete objects.
 *                    </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::grant_permission_columns: Apply table
 *                 security to these columns, comma-separated.  The default
 *                 value is ''.
 *                         <li> gpudb::grant_permission_filter_expression:
 *                 Optional filter expression to apply to this grant.  Only
 *                 rows that match the filter will be affected.  The default
 *                 value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionResponse& grantPermission( const std::string& principal,
                                          const std::string& object,
                                          const std::string& objectType,
                                          const std::string& permission,
                                          const std::map<std::string, std::string>& options,
                                          GrantPermissionResponse& response_ ) const;

/**
 * Grants a <a
 * href="../../../security/sec_concepts/#security-concepts-permissions-credential"
 * target="_top">credential-level permission</a> to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionCredentialResponse grantPermissionCredential( const GrantPermissionCredentialRequest& request_ ) const;

/**
 * Grants a <a
 * href="../../../security/sec_concepts/#security-concepts-permissions-credential"
 * target="_top">credential-level permission</a> to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionCredentialResponse& grantPermissionCredential( const GrantPermissionCredentialRequest& request_,
                                                              GrantPermissionCredentialResponse& response_ ) const;

/**
 * Grants a <a
 * href="../../../security/sec_concepts/#security-concepts-permissions-credential"
 * target="_top">credential-level permission</a> to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li>
 *                    gpudb::grant_permission_credential_credential_admin: Full
 *                    read/write and administrative access on the credential.
 *                            <li>
 *                    gpudb::grant_permission_credential_credential_read:
 *                    Ability to read and use the credential.
 *                    </ul>
 * @param credentialName  Name of the credential on which the permission will
 *                        be granted. Must be an existing credential, or an
 *                        empty string to grant access on all credentials.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionCredentialResponse grantPermissionCredential( const std::string& name,
                                                             const std::string& permission,
                                                             const std::string& credentialName,
                                                             const std::map<std::string, std::string>& options ) const;

/**
 * Grants a <a
 * href="../../../security/sec_concepts/#security-concepts-permissions-credential"
 * target="_top">credential-level permission</a> to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li>
 *                    gpudb::grant_permission_credential_credential_admin: Full
 *                    read/write and administrative access on the credential.
 *                            <li>
 *                    gpudb::grant_permission_credential_credential_read:
 *                    Ability to read and use the credential.
 *                    </ul>
 * @param credentialName  Name of the credential on which the permission will
 *                        be granted. Must be an existing credential, or an
 *                        empty string to grant access on all credentials.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionCredentialResponse& grantPermissionCredential( const std::string& name,
                                                              const std::string& permission,
                                                              const std::string& credentialName,
                                                              const std::map<std::string, std::string>& options,
                                                              GrantPermissionCredentialResponse& response_ ) const;

/**
 * Grants a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a> permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionDatasourceResponse grantPermissionDatasource( const GrantPermissionDatasourceRequest& request_ ) const;

/**
 * Grants a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a> permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionDatasourceResponse& grantPermissionDatasource( const GrantPermissionDatasourceRequest& request_,
                                                              GrantPermissionDatasourceResponse& response_ ) const;

/**
 * Grants a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a> permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role
 *                    <ul>
 *                            <li> gpudb::grant_permission_datasource_admin:
 *                    Admin access on the given data source
 *                            <li> gpudb::grant_permission_datasource_connect:
 *                    Connect access on the given data source
 *                    </ul>
 * @param datasourceName  Name of the data source on which the permission will
 *                        be granted. Must be an existing data source, or an
 *                        empty string to grant permission on all data sources.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionDatasourceResponse grantPermissionDatasource( const std::string& name,
                                                             const std::string& permission,
                                                             const std::string& datasourceName,
                                                             const std::map<std::string, std::string>& options ) const;

/**
 * Grants a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a> permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role
 *                    <ul>
 *                            <li> gpudb::grant_permission_datasource_admin:
 *                    Admin access on the given data source
 *                            <li> gpudb::grant_permission_datasource_connect:
 *                    Connect access on the given data source
 *                    </ul>
 * @param datasourceName  Name of the data source on which the permission will
 *                        be granted. Must be an existing data source, or an
 *                        empty string to grant permission on all data sources.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionDatasourceResponse& grantPermissionDatasource( const std::string& name,
                                                              const std::string& permission,
                                                              const std::string& datasourceName,
                                                              const std::map<std::string, std::string>& options,
                                                              GrantPermissionDatasourceResponse& response_ ) const;

/**
 * Grants a <a href="../../../tools/kifs/" target="_top">KiFS</a>
 * directory-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionDirectoryResponse grantPermissionDirectory( const GrantPermissionDirectoryRequest& request_ ) const;

/**
 * Grants a <a href="../../../tools/kifs/" target="_top">KiFS</a>
 * directory-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionDirectoryResponse& grantPermissionDirectory( const GrantPermissionDirectoryRequest& request_,
                                                            GrantPermissionDirectoryResponse& response_ ) const;

/**
 * Grants a <a href="../../../tools/kifs/" target="_top">KiFS</a>
 * directory-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li>
 *                    gpudb::grant_permission_directory_directory_read: For
 *                    files in the directory, access to list files, download
 *                    files, or use files in server side functions
 *                            <li>
 *                    gpudb::grant_permission_directory_directory_write: Access
 *                    to upload files to, or delete files from, the directory.
 *                    A user or role with write access automatically has read
 *                    access
 *                    </ul>
 * @param directoryName  Name of the KiFS directory to which the permission
 *                       grants access. An empty directory name grants access
 *                       to all KiFS directories
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionDirectoryResponse grantPermissionDirectory( const std::string& name,
                                                           const std::string& permission,
                                                           const std::string& directoryName,
                                                           const std::map<std::string, std::string>& options ) const;

/**
 * Grants a <a href="../../../tools/kifs/" target="_top">KiFS</a>
 * directory-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li>
 *                    gpudb::grant_permission_directory_directory_read: For
 *                    files in the directory, access to list files, download
 *                    files, or use files in server side functions
 *                            <li>
 *                    gpudb::grant_permission_directory_directory_write: Access
 *                    to upload files to, or delete files from, the directory.
 *                    A user or role with write access automatically has read
 *                    access
 *                    </ul>
 * @param directoryName  Name of the KiFS directory to which the permission
 *                       grants access. An empty directory name grants access
 *                       to all KiFS directories
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionDirectoryResponse& grantPermissionDirectory( const std::string& name,
                                                            const std::string& permission,
                                                            const std::string& directoryName,
                                                            const std::map<std::string, std::string>& options,
                                                            GrantPermissionDirectoryResponse& response_ ) const;

/**
 * Grants a proc-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionProcResponse grantPermissionProc( const GrantPermissionProcRequest& request_ ) const;

/**
 * Grants a proc-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionProcResponse& grantPermissionProc( const GrantPermissionProcRequest& request_,
                                                  GrantPermissionProcResponse& response_ ) const;

/**
 * Grants a proc-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li> gpudb::grant_permission_proc_proc_admin:
 *                    Admin access to the proc.
 *                            <li> gpudb::grant_permission_proc_proc_execute:
 *                    Execute access to the proc.
 *                    </ul>
 * @param procName  Name of the proc to which the permission grants access.
 *                  Must be an existing proc, or an empty string to grant
 *                  access to all procs.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionProcResponse grantPermissionProc( const std::string& name,
                                                 const std::string& permission,
                                                 const std::string& procName,
                                                 const std::map<std::string, std::string>& options ) const;

/**
 * Grants a proc-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li> gpudb::grant_permission_proc_proc_admin:
 *                    Admin access to the proc.
 *                            <li> gpudb::grant_permission_proc_proc_execute:
 *                    Execute access to the proc.
 *                    </ul>
 * @param procName  Name of the proc to which the permission grants access.
 *                  Must be an existing proc, or an empty string to grant
 *                  access to all procs.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionProcResponse& grantPermissionProc( const std::string& name,
                                                  const std::string& permission,
                                                  const std::string& procName,
                                                  const std::map<std::string, std::string>& options,
                                                  GrantPermissionProcResponse& response_ ) const;

/**
 * Grants a system-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionSystemResponse grantPermissionSystem( const GrantPermissionSystemRequest& request_ ) const;

/**
 * Grants a system-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionSystemResponse& grantPermissionSystem( const GrantPermissionSystemRequest& request_,
                                                      GrantPermissionSystemResponse& response_ ) const;

/**
 * Grants a system-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li> gpudb::grant_permission_system_system_admin:
 *                    Full access to all data and system functions.
 *                            <li>
 *                    gpudb::grant_permission_system_system_user_admin: Access
 *                    to administer users and roles that do not have
 *                    system_admin permission.
 *                            <li> gpudb::grant_permission_system_system_write:
 *                    Read and write access to all tables.
 *                            <li> gpudb::grant_permission_system_system_read:
 *                    Read-only access to all tables.
 *                    </ul>
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionSystemResponse grantPermissionSystem( const std::string& name,
                                                     const std::string& permission,
                                                     const std::map<std::string, std::string>& options ) const;

/**
 * Grants a system-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li> gpudb::grant_permission_system_system_admin:
 *                    Full access to all data and system functions.
 *                            <li>
 *                    gpudb::grant_permission_system_system_user_admin: Access
 *                    to administer users and roles that do not have
 *                    system_admin permission.
 *                            <li> gpudb::grant_permission_system_system_write:
 *                    Read and write access to all tables.
 *                            <li> gpudb::grant_permission_system_system_read:
 *                    Read-only access to all tables.
 *                    </ul>
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionSystemResponse& grantPermissionSystem( const std::string& name,
                                                      const std::string& permission,
                                                      const std::map<std::string, std::string>& options,
                                                      GrantPermissionSystemResponse& response_ ) const;

/**
 * Grants a table-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionTableResponse grantPermissionTable( const GrantPermissionTableRequest& request_ ) const;

/**
 * Grants a table-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionTableResponse& grantPermissionTable( const GrantPermissionTableRequest& request_,
                                                    GrantPermissionTableResponse& response_ ) const;

/**
 * Grants a table-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li> gpudb::grant_permission_table_table_admin:
 *                    Full read/write and administrative access to the table.
 *                            <li> gpudb::grant_permission_table_table_insert:
 *                    Insert access to the table.
 *                            <li> gpudb::grant_permission_table_table_update:
 *                    Update access to the table.
 *                            <li> gpudb::grant_permission_table_table_delete:
 *                    Delete access to the table.
 *                            <li> gpudb::grant_permission_table_table_read:
 *                    Read access to the table.
 *                    </ul>
 * @param tableName  Name of the table to which the permission grants access,
 *                   in [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table, view, or schema. If a schema, the
 *                   permission also applies to tables and views in the schema.
 * @param filterExpression  Optional filter expression to apply to this grant.
 *                          Only rows that match the filter will be affected.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::grant_permission_table_columns: Apply
 *                 security to these columns, comma-separated.  The default
 *                 value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionTableResponse grantPermissionTable( const std::string& name,
                                                   const std::string& permission,
                                                   const std::string& tableName,
                                                   const std::string& filterExpression,
                                                   const std::map<std::string, std::string>& options ) const;

/**
 * Grants a table-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li> gpudb::grant_permission_table_table_admin:
 *                    Full read/write and administrative access to the table.
 *                            <li> gpudb::grant_permission_table_table_insert:
 *                    Insert access to the table.
 *                            <li> gpudb::grant_permission_table_table_update:
 *                    Update access to the table.
 *                            <li> gpudb::grant_permission_table_table_delete:
 *                    Delete access to the table.
 *                            <li> gpudb::grant_permission_table_table_read:
 *                    Read access to the table.
 *                    </ul>
 * @param tableName  Name of the table to which the permission grants access,
 *                   in [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table, view, or schema. If a schema, the
 *                   permission also applies to tables and views in the schema.
 * @param filterExpression  Optional filter expression to apply to this grant.
 *                          Only rows that match the filter will be affected.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::grant_permission_table_columns: Apply
 *                 security to these columns, comma-separated.  The default
 *                 value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionTableResponse& grantPermissionTable( const std::string& name,
                                                    const std::string& permission,
                                                    const std::string& tableName,
                                                    const std::string& filterExpression,
                                                    const std::map<std::string, std::string>& options,
                                                    GrantPermissionTableResponse& response_ ) const;

/**
 * Grants membership in a role to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantRoleResponse grantRole( const GrantRoleRequest& request_ ) const;

/**
 * Grants membership in a role to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantRoleResponse& grantRole( const GrantRoleRequest& request_,
                              GrantRoleResponse& response_ ) const;

/**
 * Grants membership in a role to a user or role.
 * 
 * @param role  Name of the role in which membership will be granted. Must be
 *              an existing role.
 * @param member  Name of the user or role that will be granted membership in
 *                @a role. Must be an existing user or role.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantRoleResponse grantRole( const std::string& role,
                             const std::string& member,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Grants membership in a role to a user or role.
 * 
 * @param role  Name of the role in which membership will be granted. Must be
 *              an existing role.
 * @param member  Name of the user or role that will be granted membership in
 *                @a role. Must be an existing user or role.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantRoleResponse& grantRole( const std::string& role,
                              const std::string& member,
                              const std::map<std::string, std::string>& options,
                              GrantRoleResponse& response_ ) const;

/**
 * Checks if the specified user has the specified permission on the specified
 * object.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasPermissionResponse hasPermission( const HasPermissionRequest& request_ ) const;

/**
 * Checks if the specified user has the specified permission on the specified
 * object.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasPermissionResponse& hasPermission( const HasPermissionRequest& request_,
                                      HasPermissionResponse& response_ ) const;

/**
 * Checks if the specified user has the specified permission on the specified
 * object.
 * 
 * @param principal  Name of the user for which the permission is being
 *                   checked. Must be an existing user. If blank, will use the
 *                   current user.
 * @param object  Name of object to check for the requested permission.  It is
 *                recommended to use a fully-qualified name when possible.
 * @param objectType  The type of object being checked
 *                    <ul>
 *                            <li> gpudb::has_permission_context: Context
 *                            <li> gpudb::has_permission_credential: Credential
 *                            <li> gpudb::has_permission_datasink: Data Sink
 *                            <li> gpudb::has_permission_datasource: Data
 *                    Source
 *                            <li> gpudb::has_permission_directory: KiFS File
 *                    Directory
 *                            <li> gpudb::has_permission_graph: A Graph object
 *                            <li> gpudb::has_permission_proc: UDF Procedure
 *                            <li> gpudb::has_permission_schema: Schema
 *                            <li> gpudb::has_permission_sql_proc: SQL
 *                    Procedure
 *                            <li> gpudb::has_permission_system: System-level
 *                    access
 *                            <li> gpudb::has_permission_table: Database Table
 *                            <li> gpudb::has_permission_table_monitor: Table
 *                    monitor
 *                    </ul>
 * @param permission  Permission to check for.
 *                    <ul>
 *                            <li> gpudb::has_permission_admin: Full read/write
 *                    and administrative access on the object.
 *                            <li> gpudb::has_permission_connect: Connect
 *                    access on the given data source or data sink.
 *                            <li> gpudb::has_permission_delete: Delete rows
 *                    from tables.
 *                            <li> gpudb::has_permission_execute: Ability to
 *                    Execute the Procedure object.
 *                            <li> gpudb::has_permission_insert: Insert access
 *                    to tables.
 *                            <li> gpudb::has_permission_read: Ability to read,
 *                    list and use the object.
 *                            <li> gpudb::has_permission_update: Update access
 *                    to the table.
 *                            <li> gpudb::has_permission_user_admin: Access to
 *                    administer users and roles that do not have system_admin
 *                    permission.
 *                            <li> gpudb::has_permission_write: Access to
 *                    write, change and delete objects.
 *                    </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::has_permission_no_error_if_not_exists:
 *                 If @a false will return an error if the provided @a object
 *                 does not exist or is blank. If @a true then it will return
 *                 @a false for @a hasPermission.
 *                 <ul>
 *                         <li> gpudb::has_permission_true
 *                         <li> gpudb::has_permission_false
 *                 </ul>
 *                 The default value is gpudb::has_permission_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasPermissionResponse hasPermission( const std::string& principal,
                                     const std::string& object,
                                     const std::string& objectType,
                                     const std::string& permission,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Checks if the specified user has the specified permission on the specified
 * object.
 * 
 * @param principal  Name of the user for which the permission is being
 *                   checked. Must be an existing user. If blank, will use the
 *                   current user.
 * @param object  Name of object to check for the requested permission.  It is
 *                recommended to use a fully-qualified name when possible.
 * @param objectType  The type of object being checked
 *                    <ul>
 *                            <li> gpudb::has_permission_context: Context
 *                            <li> gpudb::has_permission_credential: Credential
 *                            <li> gpudb::has_permission_datasink: Data Sink
 *                            <li> gpudb::has_permission_datasource: Data
 *                    Source
 *                            <li> gpudb::has_permission_directory: KiFS File
 *                    Directory
 *                            <li> gpudb::has_permission_graph: A Graph object
 *                            <li> gpudb::has_permission_proc: UDF Procedure
 *                            <li> gpudb::has_permission_schema: Schema
 *                            <li> gpudb::has_permission_sql_proc: SQL
 *                    Procedure
 *                            <li> gpudb::has_permission_system: System-level
 *                    access
 *                            <li> gpudb::has_permission_table: Database Table
 *                            <li> gpudb::has_permission_table_monitor: Table
 *                    monitor
 *                    </ul>
 * @param permission  Permission to check for.
 *                    <ul>
 *                            <li> gpudb::has_permission_admin: Full read/write
 *                    and administrative access on the object.
 *                            <li> gpudb::has_permission_connect: Connect
 *                    access on the given data source or data sink.
 *                            <li> gpudb::has_permission_delete: Delete rows
 *                    from tables.
 *                            <li> gpudb::has_permission_execute: Ability to
 *                    Execute the Procedure object.
 *                            <li> gpudb::has_permission_insert: Insert access
 *                    to tables.
 *                            <li> gpudb::has_permission_read: Ability to read,
 *                    list and use the object.
 *                            <li> gpudb::has_permission_update: Update access
 *                    to the table.
 *                            <li> gpudb::has_permission_user_admin: Access to
 *                    administer users and roles that do not have system_admin
 *                    permission.
 *                            <li> gpudb::has_permission_write: Access to
 *                    write, change and delete objects.
 *                    </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::has_permission_no_error_if_not_exists:
 *                 If @a false will return an error if the provided @a object
 *                 does not exist or is blank. If @a true then it will return
 *                 @a false for @a hasPermission.
 *                 <ul>
 *                         <li> gpudb::has_permission_true
 *                         <li> gpudb::has_permission_false
 *                 </ul>
 *                 The default value is gpudb::has_permission_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasPermissionResponse& hasPermission( const std::string& principal,
                                      const std::string& object,
                                      const std::string& objectType,
                                      const std::string& permission,
                                      const std::map<std::string, std::string>& options,
                                      HasPermissionResponse& response_ ) const;

/**
 * Checks the existence of a proc with the given name.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasProcResponse hasProc( const HasProcRequest& request_ ) const;

/**
 * Checks the existence of a proc with the given name.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasProcResponse& hasProc( const HasProcRequest& request_,
                          HasProcResponse& response_ ) const;

/**
 * Checks the existence of a proc with the given name.
 * 
 * @param procName  Name of the proc to check for existence.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasProcResponse hasProc( const std::string& procName,
                         const std::map<std::string, std::string>& options ) const;

/**
 * Checks the existence of a proc with the given name.
 * 
 * @param procName  Name of the proc to check for existence.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasProcResponse& hasProc( const std::string& procName,
                          const std::map<std::string, std::string>& options,
                          HasProcResponse& response_ ) const;

/**
 * Checks if the specified user has the specified role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasRoleResponse hasRole( const HasRoleRequest& request_ ) const;

/**
 * Checks if the specified user has the specified role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasRoleResponse& hasRole( const HasRoleRequest& request_,
                          HasRoleResponse& response_ ) const;

/**
 * Checks if the specified user has the specified role.
 * 
 * @param principal  Name of the user for which role membersih is being
 *                   checked. Must be an existing user. If blank, will use the
 *                   current user.
 * @param role  Name of role to check for membership.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::has_role_no_error_if_not_exists: If @a
 *                 false will return an error if the provided @a role does not
 *                 exist or is blank. If @a true then it will return @a false
 *                 for @a hasRole.
 *                 <ul>
 *                         <li> gpudb::has_role_true
 *                         <li> gpudb::has_role_false
 *                 </ul>
 *                 The default value is gpudb::has_role_false.
 *                         <li> gpudb::has_role_only_direct: If @a false will
 *                 search recursively if the @a principal is a member of @a
 *                 role.  If @a true then @a principal must directly be a
 *                 member of @a role.
 *                 <ul>
 *                         <li> gpudb::has_role_true
 *                         <li> gpudb::has_role_false
 *                 </ul>
 *                 The default value is gpudb::has_role_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasRoleResponse hasRole( const std::string& principal,
                         const std::string& role,
                         const std::map<std::string, std::string>& options ) const;

/**
 * Checks if the specified user has the specified role.
 * 
 * @param principal  Name of the user for which role membersih is being
 *                   checked. Must be an existing user. If blank, will use the
 *                   current user.
 * @param role  Name of role to check for membership.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::has_role_no_error_if_not_exists: If @a
 *                 false will return an error if the provided @a role does not
 *                 exist or is blank. If @a true then it will return @a false
 *                 for @a hasRole.
 *                 <ul>
 *                         <li> gpudb::has_role_true
 *                         <li> gpudb::has_role_false
 *                 </ul>
 *                 The default value is gpudb::has_role_false.
 *                         <li> gpudb::has_role_only_direct: If @a false will
 *                 search recursively if the @a principal is a member of @a
 *                 role.  If @a true then @a principal must directly be a
 *                 member of @a role.
 *                 <ul>
 *                         <li> gpudb::has_role_true
 *                         <li> gpudb::has_role_false
 *                 </ul>
 *                 The default value is gpudb::has_role_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasRoleResponse& hasRole( const std::string& principal,
                          const std::string& role,
                          const std::map<std::string, std::string>& options,
                          HasRoleResponse& response_ ) const;

/**
 * Checks for the existence of a schema with the given name.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasSchemaResponse hasSchema( const HasSchemaRequest& request_ ) const;

/**
 * Checks for the existence of a schema with the given name.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasSchemaResponse& hasSchema( const HasSchemaRequest& request_,
                              HasSchemaResponse& response_ ) const;

/**
 * Checks for the existence of a schema with the given name.
 * 
 * @param schemaName  Name of the schema to check for existence, in root, using
 *                    standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasSchemaResponse hasSchema( const std::string& schemaName,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Checks for the existence of a schema with the given name.
 * 
 * @param schemaName  Name of the schema to check for existence, in root, using
 *                    standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasSchemaResponse& hasSchema( const std::string& schemaName,
                              const std::map<std::string, std::string>& options,
                              HasSchemaResponse& response_ ) const;

/**
 * Checks for the existence of a table with the given name.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTableResponse hasTable( const HasTableRequest& request_ ) const;

/**
 * Checks for the existence of a table with the given name.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTableResponse& hasTable( const HasTableRequest& request_,
                            HasTableResponse& response_ ) const;

/**
 * Checks for the existence of a table with the given name.
 * 
 * @param tableName  Name of the table to check for existence, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTableResponse hasTable( const std::string& tableName,
                           const std::map<std::string, std::string>& options ) const;

/**
 * Checks for the existence of a table with the given name.
 * 
 * @param tableName  Name of the table to check for existence, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTableResponse& hasTable( const std::string& tableName,
                            const std::map<std::string, std::string>& options,
                            HasTableResponse& response_ ) const;

/**
 * Check for the existence of a type.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTypeResponse hasType( const HasTypeRequest& request_ ) const;

/**
 * Check for the existence of a type.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTypeResponse& hasType( const HasTypeRequest& request_,
                          HasTypeResponse& response_ ) const;

/**
 * Check for the existence of a type.
 * 
 * @param typeId  Id of the type returned in response to /create/type request.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTypeResponse hasType( const std::string& typeId,
                         const std::map<std::string, std::string>& options ) const;

/**
 * Check for the existence of a type.
 * 
 * @param typeId  Id of the type returned in response to /create/type request.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTypeResponse& hasType( const std::string& typeId,
                          const std::map<std::string, std::string>& options,
                          HasTypeResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ImportModelResponse importModel( const ImportModelRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ImportModelResponse& importModel( const ImportModelRequest& request_,
                                  ImportModelResponse& response_ ) const;

/**
 * @private
 * 
 * @param modelName
 * @param registryName
 * @param container
 * @param runFunction
 * @param modelType
 * @param options
 *                 <ul>
 *                         <li> gpudb::import_model_memory_limit:   The default
 *                 value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ImportModelResponse importModel( const std::string& modelName,
                                 const std::string& registryName,
                                 const std::string& container,
                                 const std::string& runFunction,
                                 const std::string& modelType,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param modelName
 * @param registryName
 * @param container
 * @param runFunction
 * @param modelType
 * @param options
 *                 <ul>
 *                         <li> gpudb::import_model_memory_limit:   The default
 *                 value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ImportModelResponse& importModel( const std::string& modelName,
                                  const std::string& registryName,
                                  const std::string& container,
                                  const std::string& runFunction,
                                  const std::string& modelType,
                                  const std::map<std::string, std::string>& options,
                                  ImportModelResponse& response_ ) const;

/**
 * Adds multiple records to the specified table. The operation is
 * synchronous, meaning that a response will not be returned until all the
 * records
 * are fully inserted and available. The response payload provides the counts
 * of
 * the number of records actually inserted and/or updated, and can provide the
 * unique identifier of each added record.
 * <p>
 * The @a options parameter can be used to customize this function's
 * behavior.
 * <p>
 * The @a update_on_existing_pk option specifies the record
 * collision policy for inserting into a table with a
 * <a href="../../../concepts/tables/#primary-keys" target="_top">primary
 * key</a>, but is ignored if
 * no primary key exists.
 * <p>
 * The @a return_record_ids option indicates that the
 * database should return the unique identifiers of inserted records.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsResponse insertRecordsRaw( const RawInsertRecordsRequest& request_ ) const;

/**
 * Adds multiple records to the specified table. The operation is
 * synchronous, meaning that a response will not be returned until all the
 * records
 * are fully inserted and available. The response payload provides the counts
 * of
 * the number of records actually inserted and/or updated, and can provide the
 * unique identifier of each added record.
 * <p>
 * The @a options parameter can be used to customize this function's
 * behavior.
 * <p>
 * The @a update_on_existing_pk option specifies the record
 * collision policy for inserting into a table with a
 * <a href="../../../concepts/tables/#primary-keys" target="_top">primary
 * key</a>, but is ignored if
 * no primary key exists.
 * <p>
 * The @a return_record_ids option indicates that the
 * database should return the unique identifiers of inserted records.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsResponse& insertRecordsRaw( const RawInsertRecordsRequest& request_,
                                         InsertRecordsResponse& response_ ) const;

/**
 * Adds multiple records to the specified table. The operation is
 * synchronous, meaning that a response will not be returned until all the
 * records
 * are fully inserted and available. The response payload provides the counts
 * of
 * the number of records actually inserted and/or updated, and can provide the
 * unique identifier of each added record.
 * <p>
 * The @a options parameter can be used to customize this function's
 * behavior.
 * <p>
 * The @a update_on_existing_pk option specifies the record
 * collision policy for inserting into a table with a
 * <a href="../../../concepts/tables/#primary-keys" target="_top">primary
 * key</a>, but is ignored if
 * no primary key exists.
 * <p>
 * The @a return_record_ids option indicates that the
 * database should return the unique identifiers of inserted records.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TRequest> 
InsertRecordsResponse insertRecords( const InsertRecordsRequest<TRequest>& request_ ) const
{
    RawInsertRecordsRequest actualRequest_;
    actualRequest_.tableName = request_.tableName;
    avro::encode(actualRequest_.list, request_.data, this->m_threadCount, this->m_executor);
    actualRequest_.options = request_.options;
    InsertRecordsResponse actualResponse_;
    submitRequest("/insert/records", actualRequest_, actualResponse_, true);
    return actualResponse_;
}


/**
 * Adds multiple records to the specified table. The operation is
 * synchronous, meaning that a response will not be returned until all the
 * records
 * are fully inserted and available. The response payload provides the counts
 * of
 * the number of records actually inserted and/or updated, and can provide the
 * unique identifier of each added record.
 * <p>
 * The @a options parameter can be used to customize this function's
 * behavior.
 * <p>
 * The @a update_on_existing_pk option specifies the record
 * collision policy for inserting into a table with a
 * <a href="../../../concepts/tables/#primary-keys" target="_top">primary
 * key</a>, but is ignored if
 * no primary key exists.
 * <p>
 * The @a return_record_ids option indicates that the
 * database should return the unique identifiers of inserted records.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TRequest> 
InsertRecordsResponse& insertRecords( const InsertRecordsRequest<TRequest>& request_,
                                      InsertRecordsResponse& response_ ) const
{
    RawInsertRecordsRequest actualRequest_;
    actualRequest_.tableName = request_.tableName;
    avro::encode(actualRequest_.list, request_.data, this->m_threadCount, this->m_executor);
    actualRequest_.options = request_.options;
    submitRequest("/insert/records", actualRequest_, response_, true);
    return response_;
}


/**
 * Adds multiple records to the specified table. The operation is
 * synchronous, meaning that a response will not be returned until all the
 * records
 * are fully inserted and available. The response payload provides the counts
 * of
 * the number of records actually inserted and/or updated, and can provide the
 * unique identifier of each added record.
 * <p>
 * The @a options parameter can be used to customize this function's
 * behavior.
 * <p>
 * The @a update_on_existing_pk option specifies the record
 * collision policy for inserting into a table with a
 * <a href="../../../concepts/tables/#primary-keys" target="_top">primary
 * key</a>, but is ignored if
 * no primary key exists.
 * <p>
 * The @a return_record_ids option indicates that the
 * database should return the unique identifiers of inserted records.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param tableName  Name of table to which the records are to be added, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param data  An array of binary-encoded data for the records to be added.
 *              All records must be of the same type as that of the table.
 *              Empty array if @a listEncoding is @a json.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::insert_records_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting into a
 *                 table
 *                 with a <a href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>. If set to
 *                 @a true, any existing table record with primary
 *                 key values that match those of a record being inserted will
 *                 be replaced by that new record (the new
 *                 data will be "upserted"). If set to @a false,
 *                 any existing table record with primary key values that match
 *                 those of a record being inserted will
 *                 remain unchanged, while the new record will be rejected and
 *                 the error handled as determined by
 *                 @a ignore_existing_pk, @a allow_partial_batch, &
 *                 @a return_individual_errors.  If the specified table does
 *                 not have a primary
 *                 key, then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_true: Upsert new records
 *                 when primary keys match existing records
 *                         <li> gpudb::insert_records_false: Reject new records
 *                 when primary keys match existing records
 *                 </ul>
 *                 The default value is gpudb::insert_records_false.
 *                         <li> gpudb::insert_records_ignore_existing_pk:
 *                 Specifies the record collision error-suppression policy for
 *                 inserting into a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only used when
 *                 not in upsert mode (upsert mode is disabled when @a
 *                 update_on_existing_pk is
 *                 @a false).  If set to
 *                 @a true, any record being inserted that is rejected
 *                 for having primary key values that match those of an
 *                 existing table record will be ignored with no
 *                 error generated.  If @a false, the rejection of any
 *                 record for having primary key values matching an existing
 *                 record will result in an error being
 *                 reported, as determined by @a allow_partial_batch &
 *                 @a return_individual_errors.  If the specified table does
 *                 not
 *                 have a primary key or if upsert mode is in effect (@a
 *                 update_on_existing_pk is
 *                 @a true), then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_true: Ignore new records
 *                 whose primary key values collide with those of existing
 *                 records
 *                         <li> gpudb::insert_records_false: Treat as errors
 *                 any new records whose primary key values collide with those
 *                 of existing records
 *                 </ul>
 *                 The default value is gpudb::insert_records_false.
 *                         <li> gpudb::insert_records_return_record_ids: If @a
 *                 true then return the internal record id along for each
 *                 inserted record.
 *                 <ul>
 *                         <li> gpudb::insert_records_true
 *                         <li> gpudb::insert_records_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_false.
 *                         <li> gpudb::insert_records_truncate_strings: If set
 *                 to @a true, any strings which are too long for their target
 *                 charN string columns will be truncated to fit.
 *                 <ul>
 *                         <li> gpudb::insert_records_true
 *                         <li> gpudb::insert_records_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_false.
 *                         <li> gpudb::insert_records_return_individual_errors:
 *                 If set to @a true, success will always be returned, and any
 *                 errors found will be included in the info map.  The
 *                 "bad_record_indices" entry is a comma-separated list of bad
 *                 records (0-based).  And if so, there will also be an
 *                 "error_N" entry for each record with an error, where N is
 *                 the index (0-based).
 *                 <ul>
 *                         <li> gpudb::insert_records_true
 *                         <li> gpudb::insert_records_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_false.
 *                         <li> gpudb::insert_records_allow_partial_batch: If
 *                 set to @a true, all correct records will be inserted and
 *                 incorrect records will be rejected and reported.  Otherwise,
 *                 the entire batch will be rejected if any records are
 *                 incorrect.
 *                 <ul>
 *                         <li> gpudb::insert_records_true
 *                         <li> gpudb::insert_records_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_false.
 *                         <li> gpudb::insert_records_dry_run: If set to @a
 *                 true, no data will be saved and any errors will be returned.
 *                 <ul>
 *                         <li> gpudb::insert_records_true
 *                         <li> gpudb::insert_records_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TRequest> 
InsertRecordsResponse insertRecords( const std::string& tableName,
                                     const std::vector<TRequest>& data,
                                     const std::map<std::string, std::string>& options ) const
{
    RawInsertRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    avro::encode(actualRequest_.list, data, this->m_threadCount, this->m_executor);
    actualRequest_.options = options;
    InsertRecordsResponse actualResponse_;
    submitRequest("/insert/records", actualRequest_, actualResponse_, true);
    return actualResponse_;
}


/**
 * Adds multiple records to the specified table. The operation is
 * synchronous, meaning that a response will not be returned until all the
 * records
 * are fully inserted and available. The response payload provides the counts
 * of
 * the number of records actually inserted and/or updated, and can provide the
 * unique identifier of each added record.
 * <p>
 * The @a options parameter can be used to customize this function's
 * behavior.
 * <p>
 * The @a update_on_existing_pk option specifies the record
 * collision policy for inserting into a table with a
 * <a href="../../../concepts/tables/#primary-keys" target="_top">primary
 * key</a>, but is ignored if
 * no primary key exists.
 * <p>
 * The @a return_record_ids option indicates that the
 * database should return the unique identifiers of inserted records.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param tableName  Name of table to which the records are to be added, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table.
 * @param data  An array of binary-encoded data for the records to be added.
 *              All records must be of the same type as that of the table.
 *              Empty array if @a listEncoding is @a json.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::insert_records_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting into a
 *                 table
 *                 with a <a href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>. If set to
 *                 @a true, any existing table record with primary
 *                 key values that match those of a record being inserted will
 *                 be replaced by that new record (the new
 *                 data will be "upserted"). If set to @a false,
 *                 any existing table record with primary key values that match
 *                 those of a record being inserted will
 *                 remain unchanged, while the new record will be rejected and
 *                 the error handled as determined by
 *                 @a ignore_existing_pk, @a allow_partial_batch, &
 *                 @a return_individual_errors.  If the specified table does
 *                 not have a primary
 *                 key, then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_true: Upsert new records
 *                 when primary keys match existing records
 *                         <li> gpudb::insert_records_false: Reject new records
 *                 when primary keys match existing records
 *                 </ul>
 *                 The default value is gpudb::insert_records_false.
 *                         <li> gpudb::insert_records_ignore_existing_pk:
 *                 Specifies the record collision error-suppression policy for
 *                 inserting into a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only used when
 *                 not in upsert mode (upsert mode is disabled when @a
 *                 update_on_existing_pk is
 *                 @a false).  If set to
 *                 @a true, any record being inserted that is rejected
 *                 for having primary key values that match those of an
 *                 existing table record will be ignored with no
 *                 error generated.  If @a false, the rejection of any
 *                 record for having primary key values matching an existing
 *                 record will result in an error being
 *                 reported, as determined by @a allow_partial_batch &
 *                 @a return_individual_errors.  If the specified table does
 *                 not
 *                 have a primary key or if upsert mode is in effect (@a
 *                 update_on_existing_pk is
 *                 @a true), then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_true: Ignore new records
 *                 whose primary key values collide with those of existing
 *                 records
 *                         <li> gpudb::insert_records_false: Treat as errors
 *                 any new records whose primary key values collide with those
 *                 of existing records
 *                 </ul>
 *                 The default value is gpudb::insert_records_false.
 *                         <li> gpudb::insert_records_return_record_ids: If @a
 *                 true then return the internal record id along for each
 *                 inserted record.
 *                 <ul>
 *                         <li> gpudb::insert_records_true
 *                         <li> gpudb::insert_records_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_false.
 *                         <li> gpudb::insert_records_truncate_strings: If set
 *                 to @a true, any strings which are too long for their target
 *                 charN string columns will be truncated to fit.
 *                 <ul>
 *                         <li> gpudb::insert_records_true
 *                         <li> gpudb::insert_records_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_false.
 *                         <li> gpudb::insert_records_return_individual_errors:
 *                 If set to @a true, success will always be returned, and any
 *                 errors found will be included in the info map.  The
 *                 "bad_record_indices" entry is a comma-separated list of bad
 *                 records (0-based).  And if so, there will also be an
 *                 "error_N" entry for each record with an error, where N is
 *                 the index (0-based).
 *                 <ul>
 *                         <li> gpudb::insert_records_true
 *                         <li> gpudb::insert_records_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_false.
 *                         <li> gpudb::insert_records_allow_partial_batch: If
 *                 set to @a true, all correct records will be inserted and
 *                 incorrect records will be rejected and reported.  Otherwise,
 *                 the entire batch will be rejected if any records are
 *                 incorrect.
 *                 <ul>
 *                         <li> gpudb::insert_records_true
 *                         <li> gpudb::insert_records_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_false.
 *                         <li> gpudb::insert_records_dry_run: If set to @a
 *                 true, no data will be saved and any errors will be returned.
 *                 <ul>
 *                         <li> gpudb::insert_records_true
 *                         <li> gpudb::insert_records_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TRequest> 
InsertRecordsResponse& insertRecords( const std::string& tableName,
                                      const std::vector<TRequest>& data,
                                      const std::map<std::string, std::string>& options,
                                      InsertRecordsResponse& response_ ) const
{
    RawInsertRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    avro::encode(actualRequest_.list, data, this->m_threadCount, this->m_executor);
    actualRequest_.options = options;
    submitRequest("/insert/records", actualRequest_, response_, true);
    return response_;
}


/**
 * Reads from one or more files and inserts the data into a new or existing
 * table.
 * The source data can be located either in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>; on the cluster, accessible to the database; or
 * remotely, accessible via a pre-defined external <a
 * href="../../../concepts/data_sources/" target="_top">data source</a>.
 * <p>

 * For delimited text files, there are two loading schemes: positional and
 * name-based. The name-based
 * loading scheme is enabled when the file has a header present and
 * @a text_has_header is set to
 * @a true. In this scheme, the source file(s) field names
 * must match the target table's column names exactly; however, the source file
 * can have more fields
 * than the target table has columns. If @a error_handling is set to
 * @a permissive, the source file can have fewer fields
 * than the target table has columns. If the name-based loading scheme is being
 * used, names matching
 * the file header's names may be provided to @a columns_to_load instead of
 * numbers, but ranges are not supported.
 * <p>
 * Note: Due to data being loaded in parallel, there is no insertion order
 * guaranteed.  For tables with
 * primary keys, in the case of a primary key collision, this means it is
 * indeterminate which record
 * will be inserted first and remain, while the rest of the colliding key
 * records are discarded.
 * <p>
 * Returns once all files are processed.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsFromFilesResponse insertRecordsFromFiles( const InsertRecordsFromFilesRequest& request_ ) const;

/**
 * Reads from one or more files and inserts the data into a new or existing
 * table.
 * The source data can be located either in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>; on the cluster, accessible to the database; or
 * remotely, accessible via a pre-defined external <a
 * href="../../../concepts/data_sources/" target="_top">data source</a>.
 * <p>

 * For delimited text files, there are two loading schemes: positional and
 * name-based. The name-based
 * loading scheme is enabled when the file has a header present and
 * @a text_has_header is set to
 * @a true. In this scheme, the source file(s) field names
 * must match the target table's column names exactly; however, the source file
 * can have more fields
 * than the target table has columns. If @a error_handling is set to
 * @a permissive, the source file can have fewer fields
 * than the target table has columns. If the name-based loading scheme is being
 * used, names matching
 * the file header's names may be provided to @a columns_to_load instead of
 * numbers, but ranges are not supported.
 * <p>
 * Note: Due to data being loaded in parallel, there is no insertion order
 * guaranteed.  For tables with
 * primary keys, in the case of a primary key collision, this means it is
 * indeterminate which record
 * will be inserted first and remain, while the rest of the colliding key
 * records are discarded.
 * <p>
 * Returns once all files are processed.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsFromFilesResponse& insertRecordsFromFiles( const InsertRecordsFromFilesRequest& request_,
                                                        InsertRecordsFromFilesResponse& response_ ) const;

/**
 * Reads from one or more files and inserts the data into a new or existing
 * table.
 * The source data can be located either in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>; on the cluster, accessible to the database; or
 * remotely, accessible via a pre-defined external <a
 * href="../../../concepts/data_sources/" target="_top">data source</a>.
 * <p>

 * For delimited text files, there are two loading schemes: positional and
 * name-based. The name-based
 * loading scheme is enabled when the file has a header present and
 * @a text_has_header is set to
 * @a true. In this scheme, the source file(s) field names
 * must match the target table's column names exactly; however, the source file
 * can have more fields
 * than the target table has columns. If @a error_handling is set to
 * @a permissive, the source file can have fewer fields
 * than the target table has columns. If the name-based loading scheme is being
 * used, names matching
 * the file header's names may be provided to @a columns_to_load instead of
 * numbers, but ranges are not supported.
 * <p>
 * Note: Due to data being loaded in parallel, there is no insertion order
 * guaranteed.  For tables with
 * primary keys, in the case of a primary key collision, this means it is
 * indeterminate which record
 * will be inserted first and remain, while the rest of the colliding key
 * records are discarded.
 * <p>
 * Returns once all files are processed.
 * 
 * @param tableName  Name of the table into which the data will be inserted, in
 *                   [schema_name.]table_name format, using standard
 *                   <a href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 *                   If the table does not exist, the table will be created
 *                   using either an existing
 *                   @a type_id or the type inferred from the
 *                   file, and the new table name will have to meet standard
 *                   <a href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>.
 * @param filepaths  A list of file paths from which data will be sourced;
 *                   For paths in <a href="../../../tools/kifs/"
 *                   target="_top">KiFS</a>, use the uri prefix of kifs://
 *                   followed by the path to
 *                   a file or directory. File matching by prefix is supported,
 *                   e.g. kifs://dir/file would match dir/file_1
 *                   and dir/file_2. When prefix matching is used, the path
 *                   must start with a full, valid KiFS directory name.
 *                   If an external data source is specified in @a
 *                   datasource_name, these file
 *                   paths must resolve to accessible files at that data source
 *                   location. Prefix matching is supported.
 *                   If the data source is hdfs, prefixes must be aligned with
 *                   directories, i.e. partial file names will
 *                   not match.
 *                   If no data source is specified, the files are assumed to
 *                   be local to the database and must all be
 *                   accessible to the gpudb user, residing on the path (or
 *                   relative to the path) specified by the
 *                   external files directory in the Kinetica
 *                   <a href="../../../config/#config-main-external-files"
 *                   target="_top">configuration file</a>. Wildcards (*) can be
 *                   used to
 *                   specify a group of files.  Prefix matching is supported,
 *                   the prefixes must be aligned with
 *                   directories.
 *                   If the first path ends in .tsv, the text delimiter will be
 *                   defaulted to a tab character.
 *                   If the first path ends in .psv, the text delimiter will be
 *                   defaulted to a pipe character (|).
 * @param modifyColumns  Not implemented yet
 * @param createTableOptions  Options used when creating the target table.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_files_type_id: ID of a
 *                            currently registered <a
 *                            href="../../../concepts/types/"
 *                            target="_top">type</a>.  The default value is ''.
 *                                    <li>
 *                            gpudb::insert_records_from_files_no_error_if_exists:
 *                            If @a true, prevents an error from occurring if
 *                            the table already exists and is of the given
 *                            type.  If a table with the same ID but a
 *                            different type exists, it is still an error.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_files_true
 *                                    <li>
 *                            gpudb::insert_records_from_files_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_files_false.
 *                                    <li>
 *                            gpudb::insert_records_from_files_is_replicated:
 *                            Affects the <a
 *                            href="../../../concepts/tables/#distribution"
 *                            target="_top">distribution scheme</a> for the
 *                            table's data.  If @a true and the given type has
 *                            no explicit <a
 *                            href="../../../concepts/tables/#shard-key"
 *                            target="_top">shard key</a> defined, the table
 *                            will be <a
 *                            href="../../../concepts/tables/#replication"
 *                            target="_top">replicated</a>.  If @a false, the
 *                            table will be <a
 *                            href="../../../concepts/tables/#sharding"
 *                            target="_top">sharded</a> according to the shard
 *                            key specified in the given @a type_id, or <a
 *                            href="../../../concepts/tables/#random-sharding"
 *                            target="_top">randomly sharded</a>, if no shard
 *                            key is specified.  Note that a type containing a
 *                            shard key cannot be used to create a replicated
 *                            table.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_files_true
 *                                    <li>
 *                            gpudb::insert_records_from_files_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_files_false.
 *                                    <li>
 *                            gpudb::insert_records_from_files_foreign_keys:
 *                            Semicolon-separated list of <a
 *                            href="../../../concepts/tables/#foreign-keys"
 *                            target="_top">foreign keys</a>, of the format
 *                            '(source_column_name [, ...]) references
 *                            target_table_name(primary_key_column_name [,
 *                            ...]) [as foreign_key_name]'.
 *                                    <li>
 *                            gpudb::insert_records_from_files_foreign_shard_key:
 *                            Foreign shard key of the format 'source_column
 *                            references shard_by_column from
 *                            target_table(primary_key_column)'.
 *                                    <li>
 *                            gpudb::insert_records_from_files_partition_type:
 *                            <a href="../../../concepts/tables/#partitioning"
 *                            target="_top">Partitioning</a> scheme to use.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_files_RANGE: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_files_INTERVAL: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_files_LIST: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_files_HASH: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_files_SERIES: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-series"
 *                            target="_top">series partitioning</a>.
 *                            </ul>
 *                                    <li>
 *                            gpudb::insert_records_from_files_partition_keys:
 *                            Comma-separated list of partition keys, which are
 *                            the columns or column expressions by which
 *                            records will be assigned to partitions defined by
 *                            @a partition_definitions.
 *                                    <li>
 *                            gpudb::insert_records_from_files_partition_definitions:
 *                            Comma-separated list of partition definitions,
 *                            whose format depends on the choice of @a
 *                            partition_type.  See <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a>, or <a
 *                            href="../../../concepts/tables/#partitioning-by-series"
 *                            target="_top">series partitioning</a> for example
 *                            formats.
 *                                    <li>
 *                            gpudb::insert_records_from_files_is_automatic_partition:
 *                            If @a true, a new partition will be created for
 *                            values which don't fall into an existing
 *                            partition.  Currently only supported for <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitions</a>.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_files_true
 *                                    <li>
 *                            gpudb::insert_records_from_files_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_files_false.
 *                                    <li>
 *                            gpudb::insert_records_from_files_ttl: Sets the <a
 *                            href="../../../concepts/ttl/"
 *                            target="_top">TTL</a> of the table specified in
 *                            @a tableName.
 *                                    <li>
 *                            gpudb::insert_records_from_files_chunk_size:
 *                            Indicates the number of records per chunk to be
 *                            used for this table.
 *                                    <li>
 *                            gpudb::insert_records_from_files_is_result_table:
 *                            Indicates whether the table is a <a
 *                            href="../../../concepts/tables_memory_only/"
 *                            target="_top">memory-only table</a>. A result
 *                            table cannot contain columns with store_only or
 *                            text_search <a
 *                            href="../../../concepts/types/#data-handling"
 *                            target="_top">data-handling</a> or that are <a
 *                            href="../../../concepts/types/#primitive-types"
 *                            target="_top">non-charN strings</a>, and it will
 *                            not be retained if the server is restarted.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_files_true
 *                                    <li>
 *                            gpudb::insert_records_from_files_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_files_false.
 *                                    <li>
 *                            gpudb::insert_records_from_files_strategy_definition:
 *                            The <a
 *                            href="../../../rm/concepts/#tier-strategies"
 *                            target="_top">tier strategy</a> for the table and
 *                            its columns.
 *                            </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::insert_records_from_files_avro_header_bytes: Optional
 *                 number of bytes to skip when reading an avro record.
 *                         <li>
 *                 gpudb::insert_records_from_files_avro_num_records: Optional
 *                 number of avro records, if data includes only records.
 *                         <li> gpudb::insert_records_from_files_avro_schema:
 *                 Optional string representing avro schema, if data includes
 *                 only records.
 *                         <li>
 *                 gpudb::insert_records_from_files_avro_schemaless: When user
 *                 provides 'avro_schema', avro data is assumed to be
 *                 schemaless, unless specified. Default is 'true' when given
 *                 avro_schema. Igonred when avro_schema is not given.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_true
 *                         <li> gpudb::insert_records_from_files_false
 *                 </ul>
 *                         <li>
 *                 gpudb::insert_records_from_files_bad_record_table_name:
 *                 Optional name of a table to which records that were rejected
 *                 are written.  The bad-record-table has the following
 *                 columns: line_number (long), line_rejected (string),
 *                 error_message (string). When error handling is Abort, bad
 *                 records table is not populated.
 *                         <li>
 *                 gpudb::insert_records_from_files_bad_record_table_limit: A
 *                 positive integer indicating the maximum number of records
 *                 that can be  written to the bad-record-table.   Default
 *                 value is 10000
 *                         <li>
 *                 gpudb::insert_records_from_files_bad_record_table_limit_per_input:
 *                 For subscriptions: A positive integer indicating the maximum
 *                 number of records that can be written to the
 *                 bad-record-table per file/payload. Default value will be
 *                 'bad_record_table_limit' and total size of the table per
 *                 rank is limited to 'bad_record_table_limit'
 *                         <li> gpudb::insert_records_from_files_batch_size:
 *                 Internal tuning parameter--number of records per batch when
 *                 inserting data.
 *                         <li>
 *                 gpudb::insert_records_from_files_column_formats: For each
 *                 target column specified, applies the column-property-bound
 *                 format to the source data
 *                 loaded into that column.  Each column format will contain a
 *                 mapping of one or more of its column
 *                 properties to an appropriate format for each property.
 *                 Currently supported column properties
 *                 include date, time, & datetime. The parameter value must be
 *                 formatted as a JSON string of maps of
 *                 column names to maps of column properties to their
 *                 corresponding column formats, e.g.,
 *                 '{ "order_date" : { "date" : "%Y.%m.%d" }, "order_time" : {
 *                 "time" : "%H:%M:%S" } }'.
 *                 See @a default_column_formats for valid format syntax.
 *                         <li>
 *                 gpudb::insert_records_from_files_columns_to_load: Specifies
 *                 a comma-delimited list of columns from the source data to
 *                 load.  If more than one file is being loaded, this list
 *                 applies to all files.
 *                 Column numbers can be specified discretely or as a range.
 *                 For example, a value of '5,7,1..3' will
 *                 insert values from the fifth column in the source data into
 *                 the first column in the target table,
 *                 from the seventh column in the source data into the second
 *                 column in the target table, and from the
 *                 first through third columns in the source data into the
 *                 third through fifth columns in the target
 *                 table.
 *                 If the source data contains a header, column names matching
 *                 the file header names may be provided
 *                 instead of column numbers.  If the target table doesn't
 *                 exist, the table will be created with the
 *                 columns in this order.  If the target table does exist with
 *                 columns in a different order than the
 *                 source data, this list can be used to match the order of the
 *                 target table.  For example, a value of
 *                 'C, B, A' will create a three column table with column C,
 *                 followed by column B, followed by column
 *                 A; or will insert those fields in that order into a table
 *                 created with columns in that order.  If
 *                 the target table exists, the column names must match the
 *                 source data field names for a name-mapping
 *                 to be successful.
 *                 Mutually exclusive with @a columns_to_skip.
 *                         <li>
 *                 gpudb::insert_records_from_files_columns_to_skip: Specifies
 *                 a comma-delimited list of columns from the source data to
 *                 skip.  Mutually exclusive with @a columns_to_load.
 *                         <li>
 *                 gpudb::insert_records_from_files_compression_type: Optional:
 *                 compression type
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_none:
 *                 Uncompressed file
 *                         <li> gpudb::insert_records_from_files_auto: Default.
 *                 Auto detect compression type
 *                         <li> gpudb::insert_records_from_files_gzip: gzip
 *                 file compression.
 *                         <li> gpudb::insert_records_from_files_bzip2: bzip2
 *                 file compression.
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_auto.
 *                         <li>
 *                 gpudb::insert_records_from_files_datasource_name: Name of an
 *                 existing external data source from which data file(s)
 *                 specified in @a filepaths will be loaded
 *                         <li>
 *                 gpudb::insert_records_from_files_default_column_formats:
 *                 Specifies the default format to be applied to source data
 *                 loaded
 *                 into columns with the corresponding column property.
 *                 Currently supported column properties include
 *                 date, time, & datetime.  This default column-property-bound
 *                 format can be overridden by specifying a
 *                 column property & format for a given target column in @a
 *                 column_formats. For
 *                 each specified annotation, the format will apply to all
 *                 columns with that annotation unless a custom
 *                 @a column_formats for that annotation is specified.
 *                 The parameter value must be formatted as a JSON string that
 *                 is a map of column properties to their
 *                 respective column formats, e.g., '{ "date" : "%Y.%m.%d",
 *                 "time" : "%H:%M:%S" }'.  Column
 *                 formats are specified as a string of control characters and
 *                 plain text. The supported control
 *                 characters are 'Y', 'm', 'd', 'H', 'M', 'S', and 's', which
 *                 follow the Linux 'strptime()'
 *                 specification, as well as 's', which specifies seconds and
 *                 fractional seconds (though the fractional
 *                 component will be truncated past milliseconds).
 *                 Formats for the 'date' annotation must include the 'Y', 'm',
 *                 and 'd' control characters. Formats for
 *                 the 'time' annotation must include the 'H', 'M', and either
 *                 'S' or 's' (but not both) control
 *                 characters. Formats for the 'datetime' annotation meet both
 *                 the 'date' and 'time' control character
 *                 requirements. For example, '{"datetime" : "%m/%d/%Y
 *                 %H:%M:%S" }' would be used to interpret text
 *                 as "05/04/2000 12:12:11"
 *                         <li>
 *                 gpudb::insert_records_from_files_error_handling: Specifies
 *                 how errors should be handled upon insertion.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_permissive:
 *                 Records with missing columns are populated with nulls if
 *                 possible; otherwise, the malformed records are skipped.
 *                         <li>
 *                 gpudb::insert_records_from_files_ignore_bad_records:
 *                 Malformed records are skipped.
 *                         <li> gpudb::insert_records_from_files_abort: Stops
 *                 current insertion and aborts entire operation when an error
 *                 is encountered.  Primary key collisions are considered
 *                 abortable errors in this mode.
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_abort.
 *                         <li> gpudb::insert_records_from_files_file_type:
 *                 Specifies the type of the file(s) whose records will be
 *                 inserted.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_avro: Avro
 *                 file format
 *                         <li>
 *                 gpudb::insert_records_from_files_delimited_text: Delimited
 *                 text file format; e.g., CSV, TSV, PSV, etc.
 *                         <li> gpudb::insert_records_from_files_gdb: Esri/GDB
 *                 file format
 *                         <li> gpudb::insert_records_from_files_json: Json
 *                 file format
 *                         <li> gpudb::insert_records_from_files_parquet:
 *                 Apache Parquet file format
 *                         <li> gpudb::insert_records_from_files_shapefile:
 *                 ShapeFile file format
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_files_delimited_text.
 *                         <li>
 *                 gpudb::insert_records_from_files_gdal_configuration_options:
 *                 Comma separated list of gdal conf options, for the specific
 *                 requets: key=value.  The default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_files_ignore_existing_pk:
 *                 Specifies the record collision error-suppression policy for
 *                 inserting into a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only used when
 *                 not in upsert mode (upsert mode is disabled when @a
 *                 update_on_existing_pk is
 *                 @a false).  If set to
 *                 @a true, any record being inserted that is rejected
 *                 for having primary key values that match those of an
 *                 existing table record will be ignored with no
 *                 error generated.  If @a false, the rejection of any
 *                 record for having primary key values matching an existing
 *                 record will result in an error being
 *                 reported, as determined by @a error_handling.  If the
 *                 specified table does not
 *                 have a primary key or if upsert mode is in effect (@a
 *                 update_on_existing_pk is
 *                 @a true), then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_true: Ignore
 *                 new records whose primary key values collide with those of
 *                 existing records
 *                         <li> gpudb::insert_records_from_files_false: Treat
 *                 as errors any new records whose primary key values collide
 *                 with those of existing records
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_false.
 *                         <li>
 *                 gpudb::insert_records_from_files_ingestion_mode: Whether to
 *                 do a full load, dry run, or perform a type inference on the
 *                 source data.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_full: Run a
 *                 type inference on the source data (if needed) and ingest
 *                         <li> gpudb::insert_records_from_files_dry_run: Does
 *                 not load data, but walks through the source data and
 *                 determines the number of valid records, taking into account
 *                 the current mode of @a error_handling.
 *                         <li>
 *                 gpudb::insert_records_from_files_type_inference_only: Infer
 *                 the type of the source data and return, without ingesting
 *                 any data.  The inferred type is returned in the response.
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_full.
 *                         <li>
 *                 gpudb::insert_records_from_files_kafka_group_id: The group
 *                 id to be used consuming data from a kakfa topic (valid only
 *                 for kafka datasource subscriptions).
 *                         <li>
 *                 gpudb::insert_records_from_files_kafka_offset_reset_policy:
 *                 Policy to determine whether the data consumption starts
 *                 either at earliest offset or latest offset.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_earliest
 *                         <li> gpudb::insert_records_from_files_latest
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_files_earliest.
 *                         <li>
 *                 gpudb::insert_records_from_files_kafka_subscription_cancel_after:
 *                 Sets the subscription lifespan (in minutes). Expired
 *                 subscription will be cancelled automatically.
 *                         <li> gpudb::insert_records_from_files_layer:
 *                 Optional: geo files layer(s) name(s): comma separated.  The
 *                 default value is ''.
 *                         <li> gpudb::insert_records_from_files_loading_mode:
 *                 Scheme for distributing the extraction and loading of data
 *                 from the source data file(s). This option applies only when
 *                 loading files that are local to the database
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_head: The head
 *                 node loads all data. All files must be available to the head
 *                 node.
 *                         <li>
 *                 gpudb::insert_records_from_files_distributed_shared: The
 *                 head node coordinates loading data by worker
 *                 processes across all nodes from shared files available to
 *                 all workers.
 *                 NOTE:
 *                 Instead of existing on a shared source, the files can be
 *                 duplicated on a source local to each host
 *                 to improve performance, though the files must appear as the
 *                 same data set from the perspective of
 *                 all hosts performing the load.
 *                         <li>
 *                 gpudb::insert_records_from_files_distributed_local: A single
 *                 worker process on each node loads all files
 *                 that are available to it. This option works best when each
 *                 worker loads files from its own file
 *                 system, to maximize performance. In order to avoid data
 *                 duplication, either each worker performing
 *                 the load needs to have visibility to a set of files unique
 *                 to it (no file is visible to more than
 *                 one node) or the target table needs to have a primary key
 *                 (which will allow the worker to
 *                 automatically deduplicate data).
 *                 NOTE:
 *                 If the target table doesn't exist, the table structure will
 *                 be determined by the head node. If the
 *                 head node has no files local to it, it will be unable to
 *                 determine the structure and the request
 *                 will fail.
 *                 If the head node is configured to have no worker processes,
 *                 no data strictly accessible to the head
 *                 node will be loaded.
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_head.
 *                         <li>
 *                 gpudb::insert_records_from_files_local_time_offset: For Avro
 *                 local timestamp columns
 *                         <li>
 *                 gpudb::insert_records_from_files_max_records_to_load: Limit
 *                 the number of records to load in this request: If this
 *                 number is larger than a batch_size, then the number of
 *                 records loaded will be limited to the next whole number of
 *                 batch_size (per working thread).  The default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_files_num_tasks_per_rank:
 *                 Optional: number of tasks for reading file per rank. Default
 *                 will be external_file_reader_num_tasks
 *                         <li> gpudb::insert_records_from_files_poll_interval:
 *                 If @a true, the number of seconds between attempts to load
 *                 external files into the table.  If zero, polling will be
 *                 continuous as long as data is found.  If no data is found,
 *                 the interval will steadily increase to a maximum of 60
 *                 seconds.
 *                         <li> gpudb::insert_records_from_files_primary_keys:
 *                 Optional: comma separated list of column names, to set as
 *                 primary keys, when not specified in the type.  The default
 *                 value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_files_schema_registry_schema_id
 *                         <li>
 *                 gpudb::insert_records_from_files_schema_registry_schema_name
 *                         <li>
 *                 gpudb::insert_records_from_files_schema_registry_schema_version
 *                         <li> gpudb::insert_records_from_files_shard_keys:
 *                 Optional: comma separated list of column names, to set as
 *                 primary keys, when not specified in the type.  The default
 *                 value is ''.
 *                         <li> gpudb::insert_records_from_files_skip_lines:
 *                 Skip number of lines from begining of file.
 *                         <li> gpudb::insert_records_from_files_subscribe:
 *                 Continuously poll the data source to check for new data and
 *                 load it into the table.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_true
 *                         <li> gpudb::insert_records_from_files_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_false.
 *                         <li>
 *                 gpudb::insert_records_from_files_table_insert_mode:
 *                 Optional: table_insert_mode. When inserting records from
 *                 multiple files: if table_per_file then insert from each file
 *                 into a new table. Currently supported only for shapefiles.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_single
 *                         <li> gpudb::insert_records_from_files_table_per_file
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_files_single.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_comment_string:
 *                 Specifies the character string that should be interpreted as
 *                 a comment line
 *                 prefix in the source data.  All lines in the data starting
 *                 with the provided string are ignored.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '#'.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_delimiter: Specifies
 *                 the character delimiting field values in the source data
 *                 and field names in the header (if present).
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is ','.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_escape_character:
 *                 Specifies the character that is used to escape other
 *                 characters in
 *                 the source data.
 *                 An 'a', 'b', 'f', 'n', 'r', 't', or 'v' preceded by an
 *                 escape character will be interpreted as the
 *                 ASCII bell, backspace, form feed, line feed, carriage
 *                 return, horizontal tab, & vertical tab,
 *                 respectively.  For example, the escape character followed by
 *                 an 'n' will be interpreted as a newline
 *                 within a field value.
 *                 The escape character can also be used to escape the quoting
 *                 character, and will be treated as an
 *                 escape character whether it is within a quoted field value
 *                 or not.
 *                 For @a delimited_text @a file_type only.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_has_header: Indicates
 *                 whether the source data contains a header row.
 *                 For @a delimited_text @a file_type only.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_true
 *                         <li> gpudb::insert_records_from_files_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_true.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_header_property_delimiter:
 *                 Specifies the delimiter for
 *                 <a href="../../../concepts/types/#column-properties"
 *                 target="_top">column properties</a> in the header row (if
 *                 present).  Cannot be set to same value as @a text_delimiter.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '|'.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_null_string: Specifies
 *                 the character string that should be interpreted as a null
 *                 value in the source data.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '\\N'.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_quote_character:
 *                 Specifies the character that should be interpreted as a
 *                 field value
 *                 quoting character in the source data.  The character must
 *                 appear at beginning and end of field value
 *                 to take effect.  Delimiters within quoted fields are treated
 *                 as literals and not delimiters.  Within
 *                 a quoted field, two consecutive quote characters will be
 *                 interpreted as a single literal quote
 *                 character, effectively escaping it.  To not have a quote
 *                 character, specify an empty string.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '"'.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_search_columns: Add
 *                 'text_search' property to internally inferenced string
 *                 columns. Comma seperated list of column names or '*' for all
 *                 columns. To add text_search property only to string columns
 *                 of minimum size, set also the option
 *                 'text_search_min_column_length'
 *                         <li>
 *                 gpudb::insert_records_from_files_text_search_min_column_length:
 *                 Set minimum column size. Used only when
 *                 'text_search_columns' has a value.
 *                         <li>
 *                 gpudb::insert_records_from_files_truncate_strings: If set to
 *                 @a true, truncate string values that are longer than the
 *                 column's type size.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_true
 *                         <li> gpudb::insert_records_from_files_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_false.
 *                         <li>
 *                 gpudb::insert_records_from_files_truncate_table: If set to
 *                 @a true, truncates the table specified by @a tableName prior
 *                 to loading the file(s).
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_true
 *                         <li> gpudb::insert_records_from_files_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_false.
 *                         <li>
 *                 gpudb::insert_records_from_files_type_inference_mode:
 *                 optimize type inference for:
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_accuracy:
 *                 Scans data to get exactly-typed & sized columns for all data
 *                 scanned.
 *                         <li> gpudb::insert_records_from_files_speed: Scans
 *                 data and picks the widest possible column types so that
 *                 'all' values will fit with minimum data scanned
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_speed.
 *                         <li>
 *                 gpudb::insert_records_from_files_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting into a
 *                 table
 *                 with a <a href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>. If set to
 *                 @a true, any existing table record with primary
 *                 key values that match those of a record being inserted will
 *                 be replaced by that new record (the new
 *                 data will be "upserted"). If set to @a false,
 *                 any existing table record with primary key values that match
 *                 those of a record being inserted will
 *                 remain unchanged, while the new record will be rejected and
 *                 the error handled as determined by
 *                 @a ignore_existing_pk & @a error_handling.  If the
 *                 specified table does not have a primary key, then this
 *                 option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_true: Upsert
 *                 new records when primary keys match existing records
 *                         <li> gpudb::insert_records_from_files_false: Reject
 *                 new records when primary keys match existing records
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsFromFilesResponse insertRecordsFromFiles( const std::string& tableName,
                                                       const std::vector<std::string>& filepaths,
                                                       const std::map<std::string, std::map<std::string, std::string> >& modifyColumns,
                                                       const std::map<std::string, std::string>& createTableOptions,
                                                       const std::map<std::string, std::string>& options ) const;

/**
 * Reads from one or more files and inserts the data into a new or existing
 * table.
 * The source data can be located either in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>; on the cluster, accessible to the database; or
 * remotely, accessible via a pre-defined external <a
 * href="../../../concepts/data_sources/" target="_top">data source</a>.
 * <p>

 * For delimited text files, there are two loading schemes: positional and
 * name-based. The name-based
 * loading scheme is enabled when the file has a header present and
 * @a text_has_header is set to
 * @a true. In this scheme, the source file(s) field names
 * must match the target table's column names exactly; however, the source file
 * can have more fields
 * than the target table has columns. If @a error_handling is set to
 * @a permissive, the source file can have fewer fields
 * than the target table has columns. If the name-based loading scheme is being
 * used, names matching
 * the file header's names may be provided to @a columns_to_load instead of
 * numbers, but ranges are not supported.
 * <p>
 * Note: Due to data being loaded in parallel, there is no insertion order
 * guaranteed.  For tables with
 * primary keys, in the case of a primary key collision, this means it is
 * indeterminate which record
 * will be inserted first and remain, while the rest of the colliding key
 * records are discarded.
 * <p>
 * Returns once all files are processed.
 * 
 * @param tableName  Name of the table into which the data will be inserted, in
 *                   [schema_name.]table_name format, using standard
 *                   <a href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 *                   If the table does not exist, the table will be created
 *                   using either an existing
 *                   @a type_id or the type inferred from the
 *                   file, and the new table name will have to meet standard
 *                   <a href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>.
 * @param filepaths  A list of file paths from which data will be sourced;
 *                   For paths in <a href="../../../tools/kifs/"
 *                   target="_top">KiFS</a>, use the uri prefix of kifs://
 *                   followed by the path to
 *                   a file or directory. File matching by prefix is supported,
 *                   e.g. kifs://dir/file would match dir/file_1
 *                   and dir/file_2. When prefix matching is used, the path
 *                   must start with a full, valid KiFS directory name.
 *                   If an external data source is specified in @a
 *                   datasource_name, these file
 *                   paths must resolve to accessible files at that data source
 *                   location. Prefix matching is supported.
 *                   If the data source is hdfs, prefixes must be aligned with
 *                   directories, i.e. partial file names will
 *                   not match.
 *                   If no data source is specified, the files are assumed to
 *                   be local to the database and must all be
 *                   accessible to the gpudb user, residing on the path (or
 *                   relative to the path) specified by the
 *                   external files directory in the Kinetica
 *                   <a href="../../../config/#config-main-external-files"
 *                   target="_top">configuration file</a>. Wildcards (*) can be
 *                   used to
 *                   specify a group of files.  Prefix matching is supported,
 *                   the prefixes must be aligned with
 *                   directories.
 *                   If the first path ends in .tsv, the text delimiter will be
 *                   defaulted to a tab character.
 *                   If the first path ends in .psv, the text delimiter will be
 *                   defaulted to a pipe character (|).
 * @param modifyColumns  Not implemented yet
 * @param createTableOptions  Options used when creating the target table.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_files_type_id: ID of a
 *                            currently registered <a
 *                            href="../../../concepts/types/"
 *                            target="_top">type</a>.  The default value is ''.
 *                                    <li>
 *                            gpudb::insert_records_from_files_no_error_if_exists:
 *                            If @a true, prevents an error from occurring if
 *                            the table already exists and is of the given
 *                            type.  If a table with the same ID but a
 *                            different type exists, it is still an error.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_files_true
 *                                    <li>
 *                            gpudb::insert_records_from_files_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_files_false.
 *                                    <li>
 *                            gpudb::insert_records_from_files_is_replicated:
 *                            Affects the <a
 *                            href="../../../concepts/tables/#distribution"
 *                            target="_top">distribution scheme</a> for the
 *                            table's data.  If @a true and the given type has
 *                            no explicit <a
 *                            href="../../../concepts/tables/#shard-key"
 *                            target="_top">shard key</a> defined, the table
 *                            will be <a
 *                            href="../../../concepts/tables/#replication"
 *                            target="_top">replicated</a>.  If @a false, the
 *                            table will be <a
 *                            href="../../../concepts/tables/#sharding"
 *                            target="_top">sharded</a> according to the shard
 *                            key specified in the given @a type_id, or <a
 *                            href="../../../concepts/tables/#random-sharding"
 *                            target="_top">randomly sharded</a>, if no shard
 *                            key is specified.  Note that a type containing a
 *                            shard key cannot be used to create a replicated
 *                            table.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_files_true
 *                                    <li>
 *                            gpudb::insert_records_from_files_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_files_false.
 *                                    <li>
 *                            gpudb::insert_records_from_files_foreign_keys:
 *                            Semicolon-separated list of <a
 *                            href="../../../concepts/tables/#foreign-keys"
 *                            target="_top">foreign keys</a>, of the format
 *                            '(source_column_name [, ...]) references
 *                            target_table_name(primary_key_column_name [,
 *                            ...]) [as foreign_key_name]'.
 *                                    <li>
 *                            gpudb::insert_records_from_files_foreign_shard_key:
 *                            Foreign shard key of the format 'source_column
 *                            references shard_by_column from
 *                            target_table(primary_key_column)'.
 *                                    <li>
 *                            gpudb::insert_records_from_files_partition_type:
 *                            <a href="../../../concepts/tables/#partitioning"
 *                            target="_top">Partitioning</a> scheme to use.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_files_RANGE: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_files_INTERVAL: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_files_LIST: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_files_HASH: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_files_SERIES: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-series"
 *                            target="_top">series partitioning</a>.
 *                            </ul>
 *                                    <li>
 *                            gpudb::insert_records_from_files_partition_keys:
 *                            Comma-separated list of partition keys, which are
 *                            the columns or column expressions by which
 *                            records will be assigned to partitions defined by
 *                            @a partition_definitions.
 *                                    <li>
 *                            gpudb::insert_records_from_files_partition_definitions:
 *                            Comma-separated list of partition definitions,
 *                            whose format depends on the choice of @a
 *                            partition_type.  See <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a>, or <a
 *                            href="../../../concepts/tables/#partitioning-by-series"
 *                            target="_top">series partitioning</a> for example
 *                            formats.
 *                                    <li>
 *                            gpudb::insert_records_from_files_is_automatic_partition:
 *                            If @a true, a new partition will be created for
 *                            values which don't fall into an existing
 *                            partition.  Currently only supported for <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitions</a>.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_files_true
 *                                    <li>
 *                            gpudb::insert_records_from_files_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_files_false.
 *                                    <li>
 *                            gpudb::insert_records_from_files_ttl: Sets the <a
 *                            href="../../../concepts/ttl/"
 *                            target="_top">TTL</a> of the table specified in
 *                            @a tableName.
 *                                    <li>
 *                            gpudb::insert_records_from_files_chunk_size:
 *                            Indicates the number of records per chunk to be
 *                            used for this table.
 *                                    <li>
 *                            gpudb::insert_records_from_files_is_result_table:
 *                            Indicates whether the table is a <a
 *                            href="../../../concepts/tables_memory_only/"
 *                            target="_top">memory-only table</a>. A result
 *                            table cannot contain columns with store_only or
 *                            text_search <a
 *                            href="../../../concepts/types/#data-handling"
 *                            target="_top">data-handling</a> or that are <a
 *                            href="../../../concepts/types/#primitive-types"
 *                            target="_top">non-charN strings</a>, and it will
 *                            not be retained if the server is restarted.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_files_true
 *                                    <li>
 *                            gpudb::insert_records_from_files_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_files_false.
 *                                    <li>
 *                            gpudb::insert_records_from_files_strategy_definition:
 *                            The <a
 *                            href="../../../rm/concepts/#tier-strategies"
 *                            target="_top">tier strategy</a> for the table and
 *                            its columns.
 *                            </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::insert_records_from_files_avro_header_bytes: Optional
 *                 number of bytes to skip when reading an avro record.
 *                         <li>
 *                 gpudb::insert_records_from_files_avro_num_records: Optional
 *                 number of avro records, if data includes only records.
 *                         <li> gpudb::insert_records_from_files_avro_schema:
 *                 Optional string representing avro schema, if data includes
 *                 only records.
 *                         <li>
 *                 gpudb::insert_records_from_files_avro_schemaless: When user
 *                 provides 'avro_schema', avro data is assumed to be
 *                 schemaless, unless specified. Default is 'true' when given
 *                 avro_schema. Igonred when avro_schema is not given.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_true
 *                         <li> gpudb::insert_records_from_files_false
 *                 </ul>
 *                         <li>
 *                 gpudb::insert_records_from_files_bad_record_table_name:
 *                 Optional name of a table to which records that were rejected
 *                 are written.  The bad-record-table has the following
 *                 columns: line_number (long), line_rejected (string),
 *                 error_message (string). When error handling is Abort, bad
 *                 records table is not populated.
 *                         <li>
 *                 gpudb::insert_records_from_files_bad_record_table_limit: A
 *                 positive integer indicating the maximum number of records
 *                 that can be  written to the bad-record-table.   Default
 *                 value is 10000
 *                         <li>
 *                 gpudb::insert_records_from_files_bad_record_table_limit_per_input:
 *                 For subscriptions: A positive integer indicating the maximum
 *                 number of records that can be written to the
 *                 bad-record-table per file/payload. Default value will be
 *                 'bad_record_table_limit' and total size of the table per
 *                 rank is limited to 'bad_record_table_limit'
 *                         <li> gpudb::insert_records_from_files_batch_size:
 *                 Internal tuning parameter--number of records per batch when
 *                 inserting data.
 *                         <li>
 *                 gpudb::insert_records_from_files_column_formats: For each
 *                 target column specified, applies the column-property-bound
 *                 format to the source data
 *                 loaded into that column.  Each column format will contain a
 *                 mapping of one or more of its column
 *                 properties to an appropriate format for each property.
 *                 Currently supported column properties
 *                 include date, time, & datetime. The parameter value must be
 *                 formatted as a JSON string of maps of
 *                 column names to maps of column properties to their
 *                 corresponding column formats, e.g.,
 *                 '{ "order_date" : { "date" : "%Y.%m.%d" }, "order_time" : {
 *                 "time" : "%H:%M:%S" } }'.
 *                 See @a default_column_formats for valid format syntax.
 *                         <li>
 *                 gpudb::insert_records_from_files_columns_to_load: Specifies
 *                 a comma-delimited list of columns from the source data to
 *                 load.  If more than one file is being loaded, this list
 *                 applies to all files.
 *                 Column numbers can be specified discretely or as a range.
 *                 For example, a value of '5,7,1..3' will
 *                 insert values from the fifth column in the source data into
 *                 the first column in the target table,
 *                 from the seventh column in the source data into the second
 *                 column in the target table, and from the
 *                 first through third columns in the source data into the
 *                 third through fifth columns in the target
 *                 table.
 *                 If the source data contains a header, column names matching
 *                 the file header names may be provided
 *                 instead of column numbers.  If the target table doesn't
 *                 exist, the table will be created with the
 *                 columns in this order.  If the target table does exist with
 *                 columns in a different order than the
 *                 source data, this list can be used to match the order of the
 *                 target table.  For example, a value of
 *                 'C, B, A' will create a three column table with column C,
 *                 followed by column B, followed by column
 *                 A; or will insert those fields in that order into a table
 *                 created with columns in that order.  If
 *                 the target table exists, the column names must match the
 *                 source data field names for a name-mapping
 *                 to be successful.
 *                 Mutually exclusive with @a columns_to_skip.
 *                         <li>
 *                 gpudb::insert_records_from_files_columns_to_skip: Specifies
 *                 a comma-delimited list of columns from the source data to
 *                 skip.  Mutually exclusive with @a columns_to_load.
 *                         <li>
 *                 gpudb::insert_records_from_files_compression_type: Optional:
 *                 compression type
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_none:
 *                 Uncompressed file
 *                         <li> gpudb::insert_records_from_files_auto: Default.
 *                 Auto detect compression type
 *                         <li> gpudb::insert_records_from_files_gzip: gzip
 *                 file compression.
 *                         <li> gpudb::insert_records_from_files_bzip2: bzip2
 *                 file compression.
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_auto.
 *                         <li>
 *                 gpudb::insert_records_from_files_datasource_name: Name of an
 *                 existing external data source from which data file(s)
 *                 specified in @a filepaths will be loaded
 *                         <li>
 *                 gpudb::insert_records_from_files_default_column_formats:
 *                 Specifies the default format to be applied to source data
 *                 loaded
 *                 into columns with the corresponding column property.
 *                 Currently supported column properties include
 *                 date, time, & datetime.  This default column-property-bound
 *                 format can be overridden by specifying a
 *                 column property & format for a given target column in @a
 *                 column_formats. For
 *                 each specified annotation, the format will apply to all
 *                 columns with that annotation unless a custom
 *                 @a column_formats for that annotation is specified.
 *                 The parameter value must be formatted as a JSON string that
 *                 is a map of column properties to their
 *                 respective column formats, e.g., '{ "date" : "%Y.%m.%d",
 *                 "time" : "%H:%M:%S" }'.  Column
 *                 formats are specified as a string of control characters and
 *                 plain text. The supported control
 *                 characters are 'Y', 'm', 'd', 'H', 'M', 'S', and 's', which
 *                 follow the Linux 'strptime()'
 *                 specification, as well as 's', which specifies seconds and
 *                 fractional seconds (though the fractional
 *                 component will be truncated past milliseconds).
 *                 Formats for the 'date' annotation must include the 'Y', 'm',
 *                 and 'd' control characters. Formats for
 *                 the 'time' annotation must include the 'H', 'M', and either
 *                 'S' or 's' (but not both) control
 *                 characters. Formats for the 'datetime' annotation meet both
 *                 the 'date' and 'time' control character
 *                 requirements. For example, '{"datetime" : "%m/%d/%Y
 *                 %H:%M:%S" }' would be used to interpret text
 *                 as "05/04/2000 12:12:11"
 *                         <li>
 *                 gpudb::insert_records_from_files_error_handling: Specifies
 *                 how errors should be handled upon insertion.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_permissive:
 *                 Records with missing columns are populated with nulls if
 *                 possible; otherwise, the malformed records are skipped.
 *                         <li>
 *                 gpudb::insert_records_from_files_ignore_bad_records:
 *                 Malformed records are skipped.
 *                         <li> gpudb::insert_records_from_files_abort: Stops
 *                 current insertion and aborts entire operation when an error
 *                 is encountered.  Primary key collisions are considered
 *                 abortable errors in this mode.
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_abort.
 *                         <li> gpudb::insert_records_from_files_file_type:
 *                 Specifies the type of the file(s) whose records will be
 *                 inserted.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_avro: Avro
 *                 file format
 *                         <li>
 *                 gpudb::insert_records_from_files_delimited_text: Delimited
 *                 text file format; e.g., CSV, TSV, PSV, etc.
 *                         <li> gpudb::insert_records_from_files_gdb: Esri/GDB
 *                 file format
 *                         <li> gpudb::insert_records_from_files_json: Json
 *                 file format
 *                         <li> gpudb::insert_records_from_files_parquet:
 *                 Apache Parquet file format
 *                         <li> gpudb::insert_records_from_files_shapefile:
 *                 ShapeFile file format
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_files_delimited_text.
 *                         <li>
 *                 gpudb::insert_records_from_files_gdal_configuration_options:
 *                 Comma separated list of gdal conf options, for the specific
 *                 requets: key=value.  The default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_files_ignore_existing_pk:
 *                 Specifies the record collision error-suppression policy for
 *                 inserting into a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only used when
 *                 not in upsert mode (upsert mode is disabled when @a
 *                 update_on_existing_pk is
 *                 @a false).  If set to
 *                 @a true, any record being inserted that is rejected
 *                 for having primary key values that match those of an
 *                 existing table record will be ignored with no
 *                 error generated.  If @a false, the rejection of any
 *                 record for having primary key values matching an existing
 *                 record will result in an error being
 *                 reported, as determined by @a error_handling.  If the
 *                 specified table does not
 *                 have a primary key or if upsert mode is in effect (@a
 *                 update_on_existing_pk is
 *                 @a true), then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_true: Ignore
 *                 new records whose primary key values collide with those of
 *                 existing records
 *                         <li> gpudb::insert_records_from_files_false: Treat
 *                 as errors any new records whose primary key values collide
 *                 with those of existing records
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_false.
 *                         <li>
 *                 gpudb::insert_records_from_files_ingestion_mode: Whether to
 *                 do a full load, dry run, or perform a type inference on the
 *                 source data.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_full: Run a
 *                 type inference on the source data (if needed) and ingest
 *                         <li> gpudb::insert_records_from_files_dry_run: Does
 *                 not load data, but walks through the source data and
 *                 determines the number of valid records, taking into account
 *                 the current mode of @a error_handling.
 *                         <li>
 *                 gpudb::insert_records_from_files_type_inference_only: Infer
 *                 the type of the source data and return, without ingesting
 *                 any data.  The inferred type is returned in the response.
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_full.
 *                         <li>
 *                 gpudb::insert_records_from_files_kafka_group_id: The group
 *                 id to be used consuming data from a kakfa topic (valid only
 *                 for kafka datasource subscriptions).
 *                         <li>
 *                 gpudb::insert_records_from_files_kafka_offset_reset_policy:
 *                 Policy to determine whether the data consumption starts
 *                 either at earliest offset or latest offset.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_earliest
 *                         <li> gpudb::insert_records_from_files_latest
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_files_earliest.
 *                         <li>
 *                 gpudb::insert_records_from_files_kafka_subscription_cancel_after:
 *                 Sets the subscription lifespan (in minutes). Expired
 *                 subscription will be cancelled automatically.
 *                         <li> gpudb::insert_records_from_files_layer:
 *                 Optional: geo files layer(s) name(s): comma separated.  The
 *                 default value is ''.
 *                         <li> gpudb::insert_records_from_files_loading_mode:
 *                 Scheme for distributing the extraction and loading of data
 *                 from the source data file(s). This option applies only when
 *                 loading files that are local to the database
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_head: The head
 *                 node loads all data. All files must be available to the head
 *                 node.
 *                         <li>
 *                 gpudb::insert_records_from_files_distributed_shared: The
 *                 head node coordinates loading data by worker
 *                 processes across all nodes from shared files available to
 *                 all workers.
 *                 NOTE:
 *                 Instead of existing on a shared source, the files can be
 *                 duplicated on a source local to each host
 *                 to improve performance, though the files must appear as the
 *                 same data set from the perspective of
 *                 all hosts performing the load.
 *                         <li>
 *                 gpudb::insert_records_from_files_distributed_local: A single
 *                 worker process on each node loads all files
 *                 that are available to it. This option works best when each
 *                 worker loads files from its own file
 *                 system, to maximize performance. In order to avoid data
 *                 duplication, either each worker performing
 *                 the load needs to have visibility to a set of files unique
 *                 to it (no file is visible to more than
 *                 one node) or the target table needs to have a primary key
 *                 (which will allow the worker to
 *                 automatically deduplicate data).
 *                 NOTE:
 *                 If the target table doesn't exist, the table structure will
 *                 be determined by the head node. If the
 *                 head node has no files local to it, it will be unable to
 *                 determine the structure and the request
 *                 will fail.
 *                 If the head node is configured to have no worker processes,
 *                 no data strictly accessible to the head
 *                 node will be loaded.
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_head.
 *                         <li>
 *                 gpudb::insert_records_from_files_local_time_offset: For Avro
 *                 local timestamp columns
 *                         <li>
 *                 gpudb::insert_records_from_files_max_records_to_load: Limit
 *                 the number of records to load in this request: If this
 *                 number is larger than a batch_size, then the number of
 *                 records loaded will be limited to the next whole number of
 *                 batch_size (per working thread).  The default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_files_num_tasks_per_rank:
 *                 Optional: number of tasks for reading file per rank. Default
 *                 will be external_file_reader_num_tasks
 *                         <li> gpudb::insert_records_from_files_poll_interval:
 *                 If @a true, the number of seconds between attempts to load
 *                 external files into the table.  If zero, polling will be
 *                 continuous as long as data is found.  If no data is found,
 *                 the interval will steadily increase to a maximum of 60
 *                 seconds.
 *                         <li> gpudb::insert_records_from_files_primary_keys:
 *                 Optional: comma separated list of column names, to set as
 *                 primary keys, when not specified in the type.  The default
 *                 value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_files_schema_registry_schema_id
 *                         <li>
 *                 gpudb::insert_records_from_files_schema_registry_schema_name
 *                         <li>
 *                 gpudb::insert_records_from_files_schema_registry_schema_version
 *                         <li> gpudb::insert_records_from_files_shard_keys:
 *                 Optional: comma separated list of column names, to set as
 *                 primary keys, when not specified in the type.  The default
 *                 value is ''.
 *                         <li> gpudb::insert_records_from_files_skip_lines:
 *                 Skip number of lines from begining of file.
 *                         <li> gpudb::insert_records_from_files_subscribe:
 *                 Continuously poll the data source to check for new data and
 *                 load it into the table.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_true
 *                         <li> gpudb::insert_records_from_files_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_false.
 *                         <li>
 *                 gpudb::insert_records_from_files_table_insert_mode:
 *                 Optional: table_insert_mode. When inserting records from
 *                 multiple files: if table_per_file then insert from each file
 *                 into a new table. Currently supported only for shapefiles.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_single
 *                         <li> gpudb::insert_records_from_files_table_per_file
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_files_single.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_comment_string:
 *                 Specifies the character string that should be interpreted as
 *                 a comment line
 *                 prefix in the source data.  All lines in the data starting
 *                 with the provided string are ignored.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '#'.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_delimiter: Specifies
 *                 the character delimiting field values in the source data
 *                 and field names in the header (if present).
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is ','.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_escape_character:
 *                 Specifies the character that is used to escape other
 *                 characters in
 *                 the source data.
 *                 An 'a', 'b', 'f', 'n', 'r', 't', or 'v' preceded by an
 *                 escape character will be interpreted as the
 *                 ASCII bell, backspace, form feed, line feed, carriage
 *                 return, horizontal tab, & vertical tab,
 *                 respectively.  For example, the escape character followed by
 *                 an 'n' will be interpreted as a newline
 *                 within a field value.
 *                 The escape character can also be used to escape the quoting
 *                 character, and will be treated as an
 *                 escape character whether it is within a quoted field value
 *                 or not.
 *                 For @a delimited_text @a file_type only.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_has_header: Indicates
 *                 whether the source data contains a header row.
 *                 For @a delimited_text @a file_type only.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_true
 *                         <li> gpudb::insert_records_from_files_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_true.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_header_property_delimiter:
 *                 Specifies the delimiter for
 *                 <a href="../../../concepts/types/#column-properties"
 *                 target="_top">column properties</a> in the header row (if
 *                 present).  Cannot be set to same value as @a text_delimiter.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '|'.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_null_string: Specifies
 *                 the character string that should be interpreted as a null
 *                 value in the source data.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '\\N'.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_quote_character:
 *                 Specifies the character that should be interpreted as a
 *                 field value
 *                 quoting character in the source data.  The character must
 *                 appear at beginning and end of field value
 *                 to take effect.  Delimiters within quoted fields are treated
 *                 as literals and not delimiters.  Within
 *                 a quoted field, two consecutive quote characters will be
 *                 interpreted as a single literal quote
 *                 character, effectively escaping it.  To not have a quote
 *                 character, specify an empty string.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '"'.
 *                         <li>
 *                 gpudb::insert_records_from_files_text_search_columns: Add
 *                 'text_search' property to internally inferenced string
 *                 columns. Comma seperated list of column names or '*' for all
 *                 columns. To add text_search property only to string columns
 *                 of minimum size, set also the option
 *                 'text_search_min_column_length'
 *                         <li>
 *                 gpudb::insert_records_from_files_text_search_min_column_length:
 *                 Set minimum column size. Used only when
 *                 'text_search_columns' has a value.
 *                         <li>
 *                 gpudb::insert_records_from_files_truncate_strings: If set to
 *                 @a true, truncate string values that are longer than the
 *                 column's type size.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_true
 *                         <li> gpudb::insert_records_from_files_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_false.
 *                         <li>
 *                 gpudb::insert_records_from_files_truncate_table: If set to
 *                 @a true, truncates the table specified by @a tableName prior
 *                 to loading the file(s).
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_true
 *                         <li> gpudb::insert_records_from_files_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_false.
 *                         <li>
 *                 gpudb::insert_records_from_files_type_inference_mode:
 *                 optimize type inference for:
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_accuracy:
 *                 Scans data to get exactly-typed & sized columns for all data
 *                 scanned.
 *                         <li> gpudb::insert_records_from_files_speed: Scans
 *                 data and picks the widest possible column types so that
 *                 'all' values will fit with minimum data scanned
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_speed.
 *                         <li>
 *                 gpudb::insert_records_from_files_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting into a
 *                 table
 *                 with a <a href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>. If set to
 *                 @a true, any existing table record with primary
 *                 key values that match those of a record being inserted will
 *                 be replaced by that new record (the new
 *                 data will be "upserted"). If set to @a false,
 *                 any existing table record with primary key values that match
 *                 those of a record being inserted will
 *                 remain unchanged, while the new record will be rejected and
 *                 the error handled as determined by
 *                 @a ignore_existing_pk & @a error_handling.  If the
 *                 specified table does not have a primary key, then this
 *                 option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_files_true: Upsert
 *                 new records when primary keys match existing records
 *                         <li> gpudb::insert_records_from_files_false: Reject
 *                 new records when primary keys match existing records
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_files_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsFromFilesResponse& insertRecordsFromFiles( const std::string& tableName,
                                                        const std::vector<std::string>& filepaths,
                                                        const std::map<std::string, std::map<std::string, std::string> >& modifyColumns,
                                                        const std::map<std::string, std::string>& createTableOptions,
                                                        const std::map<std::string, std::string>& options,
                                                        InsertRecordsFromFilesResponse& response_ ) const;

/**
 * Reads from the given text-based or binary payload and inserts the
 * data into a new or existing table.  The table will be created if it doesn't
 * already exist.
 * <p>
 * Returns once all records are processed.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsFromPayloadResponse insertRecordsFromPayload( const InsertRecordsFromPayloadRequest& request_ ) const;

/**
 * Reads from the given text-based or binary payload and inserts the
 * data into a new or existing table.  The table will be created if it doesn't
 * already exist.
 * <p>
 * Returns once all records are processed.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsFromPayloadResponse& insertRecordsFromPayload( const InsertRecordsFromPayloadRequest& request_,
                                                            InsertRecordsFromPayloadResponse& response_ ) const;

/**
 * Reads from the given text-based or binary payload and inserts the
 * data into a new or existing table.  The table will be created if it doesn't
 * already exist.
 * <p>
 * Returns once all records are processed.
 * 
 * @param tableName  Name of the table into which the data will be inserted, in
 *                   [schema_name.]table_name format, using standard
 *                   <a href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 *                   If the table does not exist, the table will be created
 *                   using either an existing
 *                   @a type_id or the type inferred from the
 *                   payload, and the new table name will have to meet standard
 *                   <a href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>.
 * @param dataText  Records formatted as delimited text
 * @param dataBytes  Records formatted as binary data
 * @param modifyColumns  Not implemented yet
 * @param createTableOptions  Options used when creating the target table.
 *                            Includes type to use. The other options match
 *                            those in /create/table
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_payload_type_id: ID of
 *                            a currently registered <a
 *                            href="../../../concepts/types/"
 *                            target="_top">type</a>.  The default value is ''.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_no_error_if_exists:
 *                            If @a true, prevents an error from occurring if
 *                            the table already exists and is of the given
 *                            type.  If a table with the same ID but a
 *                            different type exists, it is still an error.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_payload_true
 *                                    <li>
 *                            gpudb::insert_records_from_payload_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_payload_false.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_is_replicated:
 *                            Affects the <a
 *                            href="../../../concepts/tables/#distribution"
 *                            target="_top">distribution scheme</a> for the
 *                            table's data.  If @a true and the given type has
 *                            no explicit <a
 *                            href="../../../concepts/tables/#shard-key"
 *                            target="_top">shard key</a> defined, the table
 *                            will be <a
 *                            href="../../../concepts/tables/#replication"
 *                            target="_top">replicated</a>.  If @a false, the
 *                            table will be <a
 *                            href="../../../concepts/tables/#sharding"
 *                            target="_top">sharded</a> according to the shard
 *                            key specified in the given @a type_id, or <a
 *                            href="../../../concepts/tables/#random-sharding"
 *                            target="_top">randomly sharded</a>, if no shard
 *                            key is specified.  Note that a type containing a
 *                            shard key cannot be used to create a replicated
 *                            table.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_payload_true
 *                                    <li>
 *                            gpudb::insert_records_from_payload_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_payload_false.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_foreign_keys:
 *                            Semicolon-separated list of <a
 *                            href="../../../concepts/tables/#foreign-keys"
 *                            target="_top">foreign keys</a>, of the format
 *                            '(source_column_name [, ...]) references
 *                            target_table_name(primary_key_column_name [,
 *                            ...]) [as foreign_key_name]'.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_foreign_shard_key:
 *                            Foreign shard key of the format 'source_column
 *                            references shard_by_column from
 *                            target_table(primary_key_column)'.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_partition_type:
 *                            <a href="../../../concepts/tables/#partitioning"
 *                            target="_top">Partitioning</a> scheme to use.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_payload_RANGE: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_INTERVAL: Use
 *                            <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_LIST: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_HASH: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_SERIES: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-series"
 *                            target="_top">series partitioning</a>.
 *                            </ul>
 *                                    <li>
 *                            gpudb::insert_records_from_payload_partition_keys:
 *                            Comma-separated list of partition keys, which are
 *                            the columns or column expressions by which
 *                            records will be assigned to partitions defined by
 *                            @a partition_definitions.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_partition_definitions:
 *                            Comma-separated list of partition definitions,
 *                            whose format depends on the choice of @a
 *                            partition_type.  See <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a>, or <a
 *                            href="../../../concepts/tables/#partitioning-by-series"
 *                            target="_top">series partitioning</a> for example
 *                            formats.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_is_automatic_partition:
 *                            If @a true, a new partition will be created for
 *                            values which don't fall into an existing
 *                            partition.  Currently only supported for <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitions</a>.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_payload_true
 *                                    <li>
 *                            gpudb::insert_records_from_payload_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_payload_false.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_ttl: Sets the
 *                            <a href="../../../concepts/ttl/"
 *                            target="_top">TTL</a> of the table specified in
 *                            @a tableName.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_chunk_size:
 *                            Indicates the number of records per chunk to be
 *                            used for this table.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_is_result_table:
 *                            Indicates whether the table is a <a
 *                            href="../../../concepts/tables_memory_only/"
 *                            target="_top">memory-only table</a>. A result
 *                            table cannot contain columns with store_only or
 *                            text_search <a
 *                            href="../../../concepts/types/#data-handling"
 *                            target="_top">data-handling</a> or that are <a
 *                            href="../../../concepts/types/#primitive-types"
 *                            target="_top">non-charN strings</a>, and it will
 *                            not be retained if the server is restarted.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_payload_true
 *                                    <li>
 *                            gpudb::insert_records_from_payload_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_payload_false.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_strategy_definition:
 *                            The <a
 *                            href="../../../rm/concepts/#tier-strategies"
 *                            target="_top">tier strategy</a> for the table and
 *                            its columns.
 *                            </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::insert_records_from_payload_avro_header_bytes:
 *                 Optional number of bytes to skip when reading an avro
 *                 record.
 *                         <li>
 *                 gpudb::insert_records_from_payload_avro_num_records:
 *                 Optional number of avro records, if data includes only
 *                 records.
 *                         <li> gpudb::insert_records_from_payload_avro_schema:
 *                 Optional string representing avro schema, for insert records
 *                 in avro format, that does not include is schema.
 *                         <li>
 *                 gpudb::insert_records_from_payload_avro_schemaless: When
 *                 user provides 'avro_schema', avro data is assumed to be
 *                 schemaless, unless specified. Default is 'true' when given
 *                 avro_schema. Igonred when avro_schema is not given.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_true
 *                         <li> gpudb::insert_records_from_payload_false
 *                 </ul>
 *                         <li>
 *                 gpudb::insert_records_from_payload_bad_record_table_name:
 *                 Optional name of a table to which records that were rejected
 *                 are written.  The bad-record-table has the following
 *                 columns: line_number (long), line_rejected (string),
 *                 error_message (string).
 *                         <li>
 *                 gpudb::insert_records_from_payload_bad_record_table_limit: A
 *                 positive integer indicating the maximum number of records
 *                 that can be  written to the bad-record-table.   Default
 *                 value is 10000
 *                         <li>
 *                 gpudb::insert_records_from_payload_bad_record_table_limit_per_input:
 *                 For subscriptions: A positive integer indicating the maximum
 *                 number of records that can be written to the
 *                 bad-record-table per file/payload. Default value will be
 *                 'bad_record_table_limit' and total size of the table per
 *                 rank is limited to 'bad_record_table_limit'
 *                         <li> gpudb::insert_records_from_payload_batch_size:
 *                 Internal tuning parameter--number of records per batch when
 *                 inserting data.
 *                         <li>
 *                 gpudb::insert_records_from_payload_column_formats: For each
 *                 target column specified, applies the column-property-bound
 *                 format to the source data
 *                 loaded into that column.  Each column format will contain a
 *                 mapping of one or more of its column
 *                 properties to an appropriate format for each property.
 *                 Currently supported column properties
 *                 include date, time, & datetime. The parameter value must be
 *                 formatted as a JSON string of maps of
 *                 column names to maps of column properties to their
 *                 corresponding column formats, e.g.,
 *                 '{ "order_date" : { "date" : "%Y.%m.%d" }, "order_time" : {
 *                 "time" : "%H:%M:%S" } }'.
 *                 See @a default_column_formats for valid format syntax.
 *                         <li>
 *                 gpudb::insert_records_from_payload_columns_to_load:
 *                 Specifies a comma-delimited list of columns from the source
 *                 data to
 *                 load.  If more than one file is being loaded, this list
 *                 applies to all files.
 *                 Column numbers can be specified discretely or as a range.
 *                 For example, a value of '5,7,1..3' will
 *                 insert values from the fifth column in the source data into
 *                 the first column in the target table,
 *                 from the seventh column in the source data into the second
 *                 column in the target table, and from the
 *                 first through third columns in the source data into the
 *                 third through fifth columns in the target
 *                 table.
 *                 If the source data contains a header, column names matching
 *                 the file header names may be provided
 *                 instead of column numbers.  If the target table doesn't
 *                 exist, the table will be created with the
 *                 columns in this order.  If the target table does exist with
 *                 columns in a different order than the
 *                 source data, this list can be used to match the order of the
 *                 target table.  For example, a value of
 *                 'C, B, A' will create a three column table with column C,
 *                 followed by column B, followed by column
 *                 A; or will insert those fields in that order into a table
 *                 created with columns in that order.  If
 *                 the target table exists, the column names must match the
 *                 source data field names for a name-mapping
 *                 to be successful.
 *                 Mutually exclusive with @a columns_to_skip.
 *                         <li>
 *                 gpudb::insert_records_from_payload_columns_to_skip:
 *                 Specifies a comma-delimited list of columns from the source
 *                 data to
 *                 skip.  Mutually exclusive with @a columns_to_load.
 *                         <li>
 *                 gpudb::insert_records_from_payload_compression_type:
 *                 Optional: payload compression type
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_none:
 *                 Uncompressed
 *                         <li> gpudb::insert_records_from_payload_auto:
 *                 Default. Auto detect compression type
 *                         <li> gpudb::insert_records_from_payload_gzip: gzip
 *                 file compression.
 *                         <li> gpudb::insert_records_from_payload_bzip2: bzip2
 *                 file compression.
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_auto.
 *                         <li>
 *                 gpudb::insert_records_from_payload_default_column_formats:
 *                 Specifies the default format to be applied to source data
 *                 loaded
 *                 into columns with the corresponding column property.
 *                 Currently supported column properties include
 *                 date, time, & datetime.  This default column-property-bound
 *                 format can be overridden by specifying a
 *                 column property & format for a given target column in @a
 *                 column_formats. For
 *                 each specified annotation, the format will apply to all
 *                 columns with that annotation unless a custom
 *                 @a column_formats for that annotation is specified.
 *                 The parameter value must be formatted as a JSON string that
 *                 is a map of column properties to their
 *                 respective column formats, e.g., '{ "date" : "%Y.%m.%d",
 *                 "time" : "%H:%M:%S" }'.  Column
 *                 formats are specified as a string of control characters and
 *                 plain text. The supported control
 *                 characters are 'Y', 'm', 'd', 'H', 'M', 'S', and 's', which
 *                 follow the Linux 'strptime()'
 *                 specification, as well as 's', which specifies seconds and
 *                 fractional seconds (though the fractional
 *                 component will be truncated past milliseconds).
 *                 Formats for the 'date' annotation must include the 'Y', 'm',
 *                 and 'd' control characters. Formats for
 *                 the 'time' annotation must include the 'H', 'M', and either
 *                 'S' or 's' (but not both) control
 *                 characters. Formats for the 'datetime' annotation meet both
 *                 the 'date' and 'time' control character
 *                 requirements. For example, '{"datetime" : "%m/%d/%Y
 *                 %H:%M:%S" }' would be used to interpret text
 *                 as "05/04/2000 12:12:11"
 *                         <li>
 *                 gpudb::insert_records_from_payload_error_handling: Specifies
 *                 how errors should be handled upon insertion.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_permissive:
 *                 Records with missing columns are populated with nulls if
 *                 possible; otherwise, the malformed records are skipped.
 *                         <li>
 *                 gpudb::insert_records_from_payload_ignore_bad_records:
 *                 Malformed records are skipped.
 *                         <li> gpudb::insert_records_from_payload_abort: Stops
 *                 current insertion and aborts entire operation when an error
 *                 is encountered.  Primary key collisions are considered
 *                 abortable errors in this mode.
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_abort.
 *                         <li> gpudb::insert_records_from_payload_file_type:
 *                 Specifies the type of the file(s) whose records will be
 *                 inserted.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_avro: Avro
 *                 file format
 *                         <li>
 *                 gpudb::insert_records_from_payload_delimited_text: Delimited
 *                 text file format; e.g., CSV, TSV, PSV, etc.
 *                         <li> gpudb::insert_records_from_payload_gdb:
 *                 Esri/GDB file format
 *                         <li> gpudb::insert_records_from_payload_json: Json
 *                 file format
 *                         <li> gpudb::insert_records_from_payload_parquet:
 *                 Apache Parquet file format
 *                         <li> gpudb::insert_records_from_payload_shapefile:
 *                 ShapeFile file format
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_delimited_text.
 *                         <li>
 *                 gpudb::insert_records_from_payload_gdal_configuration_options:
 *                 Comma separated list of gdal conf options, for the specific
 *                 requets: key=value.  The default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_payload_ignore_existing_pk:
 *                 Specifies the record collision error-suppression policy for
 *                 inserting into a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only used when
 *                 not in upsert mode (upsert mode is disabled when @a
 *                 update_on_existing_pk is
 *                 @a false).  If set to
 *                 @a true, any record being inserted that is rejected
 *                 for having primary key values that match those of an
 *                 existing table record will be ignored with no
 *                 error generated.  If @a false, the rejection of any
 *                 record for having primary key values matching an existing
 *                 record will result in an error being
 *                 reported, as determined by @a error_handling.  If the
 *                 specified table does not
 *                 have a primary key or if upsert mode is in effect (@a
 *                 update_on_existing_pk is
 *                 @a true), then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_true: Ignore
 *                 new records whose primary key values collide with those of
 *                 existing records
 *                         <li> gpudb::insert_records_from_payload_false: Treat
 *                 as errors any new records whose primary key values collide
 *                 with those of existing records
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_false.
 *                         <li>
 *                 gpudb::insert_records_from_payload_ingestion_mode: Whether
 *                 to do a full load, dry run, or perform a type inference on
 *                 the source data.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_full: Run a
 *                 type inference on the source data (if needed) and ingest
 *                         <li> gpudb::insert_records_from_payload_dry_run:
 *                 Does not load data, but walks through the source data and
 *                 determines the number of valid records, taking into account
 *                 the current mode of @a error_handling.
 *                         <li>
 *                 gpudb::insert_records_from_payload_type_inference_only:
 *                 Infer the type of the source data and return, without
 *                 ingesting any data.  The inferred type is returned in the
 *                 response.
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_full.
 *                         <li> gpudb::insert_records_from_payload_layer:
 *                 Optional: geo files layer(s) name(s): comma separated.  The
 *                 default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_payload_loading_mode: Scheme for
 *                 distributing the extraction and loading of data from the
 *                 source data file(s). This option applies only when loading
 *                 files that are local to the database
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_head: The
 *                 head node loads all data. All files must be available to the
 *                 head node.
 *                         <li>
 *                 gpudb::insert_records_from_payload_distributed_shared: The
 *                 head node coordinates loading data by worker
 *                 processes across all nodes from shared files available to
 *                 all workers.
 *                 NOTE:
 *                 Instead of existing on a shared source, the files can be
 *                 duplicated on a source local to each host
 *                 to improve performance, though the files must appear as the
 *                 same data set from the perspective of
 *                 all hosts performing the load.
 *                         <li>
 *                 gpudb::insert_records_from_payload_distributed_local: A
 *                 single worker process on each node loads all files
 *                 that are available to it. This option works best when each
 *                 worker loads files from its own file
 *                 system, to maximize performance. In order to avoid data
 *                 duplication, either each worker performing
 *                 the load needs to have visibility to a set of files unique
 *                 to it (no file is visible to more than
 *                 one node) or the target table needs to have a primary key
 *                 (which will allow the worker to
 *                 automatically deduplicate data).
 *                 NOTE:
 *                 If the target table doesn't exist, the table structure will
 *                 be determined by the head node. If the
 *                 head node has no files local to it, it will be unable to
 *                 determine the structure and the request
 *                 will fail.
 *                 If the head node is configured to have no worker processes,
 *                 no data strictly accessible to the head
 *                 node will be loaded.
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_head.
 *                         <li>
 *                 gpudb::insert_records_from_payload_local_time_offset: For
 *                 Avro local timestamp columns
 *                         <li>
 *                 gpudb::insert_records_from_payload_max_records_to_load:
 *                 Limit the number of records to load in this request: If this
 *                 number is larger than a batch_size, then the number of
 *                 records loaded will be limited to the next whole number of
 *                 batch_size (per working thread).  The default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_payload_num_tasks_per_rank:
 *                 Optional: number of tasks for reading file per rank. Default
 *                 will be external_file_reader_num_tasks
 *                         <li>
 *                 gpudb::insert_records_from_payload_poll_interval: If @a
 *                 true, the number of seconds between attempts to load
 *                 external files into the table.  If zero, polling will be
 *                 continuous as long as data is found.  If no data is found,
 *                 the interval will steadily increase to a maximum of 60
 *                 seconds.
 *                         <li>
 *                 gpudb::insert_records_from_payload_primary_keys: Optional:
 *                 comma separated list of column names, to set as primary
 *                 keys, when not specified in the type.  The default value is
 *                 ''.
 *                         <li>
 *                 gpudb::insert_records_from_payload_schema_registry_schema_id
 *                         <li>
 *                 gpudb::insert_records_from_payload_schema_registry_schema_name
 *                         <li>
 *                 gpudb::insert_records_from_payload_schema_registry_schema_version
 *                         <li> gpudb::insert_records_from_payload_shard_keys:
 *                 Optional: comma separated list of column names, to set as
 *                 primary keys, when not specified in the type.  The default
 *                 value is ''.
 *                         <li> gpudb::insert_records_from_payload_skip_lines:
 *                 Skip number of lines from begining of file.
 *                         <li> gpudb::insert_records_from_payload_subscribe:
 *                 Continuously poll the data source to check for new data and
 *                 load it into the table.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_true
 *                         <li> gpudb::insert_records_from_payload_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_false.
 *                         <li>
 *                 gpudb::insert_records_from_payload_table_insert_mode:
 *                 Optional: table_insert_mode. When inserting records from
 *                 multiple files: if table_per_file then insert from each file
 *                 into a new table. Currently supported only for shapefiles.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_single
 *                         <li>
 *                 gpudb::insert_records_from_payload_table_per_file
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_single.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_comment_string:
 *                 Specifies the character string that should be interpreted as
 *                 a comment line
 *                 prefix in the source data.  All lines in the data starting
 *                 with the provided string are ignored.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '#'.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_delimiter: Specifies
 *                 the character delimiting field values in the source data
 *                 and field names in the header (if present).
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is ','.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_escape_character:
 *                 Specifies the character that is used to escape other
 *                 characters in
 *                 the source data.
 *                 An 'a', 'b', 'f', 'n', 'r', 't', or 'v' preceded by an
 *                 escape character will be interpreted as the
 *                 ASCII bell, backspace, form feed, line feed, carriage
 *                 return, horizontal tab, & vertical tab,
 *                 respectively.  For example, the escape character followed by
 *                 an 'n' will be interpreted as a newline
 *                 within a field value.
 *                 The escape character can also be used to escape the quoting
 *                 character, and will be treated as an
 *                 escape character whether it is within a quoted field value
 *                 or not.
 *                 For @a delimited_text @a file_type only.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_has_header:
 *                 Indicates whether the source data contains a header row.
 *                 For @a delimited_text @a file_type only.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_true
 *                         <li> gpudb::insert_records_from_payload_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_true.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_header_property_delimiter:
 *                 Specifies the delimiter for
 *                 <a href="../../../concepts/types/#column-properties"
 *                 target="_top">column properties</a> in the header row (if
 *                 present).  Cannot be set to same value as @a text_delimiter.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '|'.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_null_string:
 *                 Specifies the character string that should be interpreted as
 *                 a null
 *                 value in the source data.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '\\N'.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_quote_character:
 *                 Specifies the character that should be interpreted as a
 *                 field value
 *                 quoting character in the source data.  The character must
 *                 appear at beginning and end of field value
 *                 to take effect.  Delimiters within quoted fields are treated
 *                 as literals and not delimiters.  Within
 *                 a quoted field, two consecutive quote characters will be
 *                 interpreted as a single literal quote
 *                 character, effectively escaping it.  To not have a quote
 *                 character, specify an empty string.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '"'.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_search_columns: Add
 *                 'text_search' property to internally inferenced string
 *                 columns. Comma seperated list of column names or '*' for all
 *                 columns. To add text_search property only to string columns
 *                 of minimum size, set also the option
 *                 'text_search_min_column_length'
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_search_min_column_length:
 *                 Set minimum column size. Used only when
 *                 'text_search_columns' has a value.
 *                         <li>
 *                 gpudb::insert_records_from_payload_truncate_strings: If set
 *                 to @a true, truncate string values that are longer than the
 *                 column's type size.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_true
 *                         <li> gpudb::insert_records_from_payload_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_false.
 *                         <li>
 *                 gpudb::insert_records_from_payload_truncate_table: If set to
 *                 @a true, truncates the table specified by @a tableName prior
 *                 to loading the file(s).
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_true
 *                         <li> gpudb::insert_records_from_payload_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_false.
 *                         <li>
 *                 gpudb::insert_records_from_payload_type_inference_mode:
 *                 optimize type inference for:
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_accuracy:
 *                 Scans data to get exactly-typed & sized columns for all data
 *                 scanned.
 *                         <li> gpudb::insert_records_from_payload_speed: Scans
 *                 data and picks the widest possible column types so that
 *                 'all' values will fit with minimum data scanned
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_speed.
 *                         <li>
 *                 gpudb::insert_records_from_payload_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting into a
 *                 table
 *                 with a <a href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>. If set to
 *                 @a true, any existing table record with primary
 *                 key values that match those of a record being inserted will
 *                 be replaced by that new record (the new
 *                 data will be "upserted"). If set to @a false,
 *                 any existing table record with primary key values that match
 *                 those of a record being inserted will
 *                 remain unchanged, while the new record will be rejected and
 *                 the error handled as determined by
 *                 @a ignore_existing_pk & @a error_handling.  If the
 *                 specified table does not have a primary key, then this
 *                 option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_true: Upsert
 *                 new records when primary keys match existing records
 *                         <li> gpudb::insert_records_from_payload_false:
 *                 Reject new records when primary keys match existing records
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsFromPayloadResponse insertRecordsFromPayload( const std::string& tableName,
                                                           const std::string& dataText,
                                                           const std::vector<uint8_t>& dataBytes,
                                                           const std::map<std::string, std::map<std::string, std::string> >& modifyColumns,
                                                           const std::map<std::string, std::string>& createTableOptions,
                                                           const std::map<std::string, std::string>& options ) const;

/**
 * Reads from the given text-based or binary payload and inserts the
 * data into a new or existing table.  The table will be created if it doesn't
 * already exist.
 * <p>
 * Returns once all records are processed.
 * 
 * @param tableName  Name of the table into which the data will be inserted, in
 *                   [schema_name.]table_name format, using standard
 *                   <a href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 *                   If the table does not exist, the table will be created
 *                   using either an existing
 *                   @a type_id or the type inferred from the
 *                   payload, and the new table name will have to meet standard
 *                   <a href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>.
 * @param dataText  Records formatted as delimited text
 * @param dataBytes  Records formatted as binary data
 * @param modifyColumns  Not implemented yet
 * @param createTableOptions  Options used when creating the target table.
 *                            Includes type to use. The other options match
 *                            those in /create/table
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_payload_type_id: ID of
 *                            a currently registered <a
 *                            href="../../../concepts/types/"
 *                            target="_top">type</a>.  The default value is ''.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_no_error_if_exists:
 *                            If @a true, prevents an error from occurring if
 *                            the table already exists and is of the given
 *                            type.  If a table with the same ID but a
 *                            different type exists, it is still an error.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_payload_true
 *                                    <li>
 *                            gpudb::insert_records_from_payload_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_payload_false.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_is_replicated:
 *                            Affects the <a
 *                            href="../../../concepts/tables/#distribution"
 *                            target="_top">distribution scheme</a> for the
 *                            table's data.  If @a true and the given type has
 *                            no explicit <a
 *                            href="../../../concepts/tables/#shard-key"
 *                            target="_top">shard key</a> defined, the table
 *                            will be <a
 *                            href="../../../concepts/tables/#replication"
 *                            target="_top">replicated</a>.  If @a false, the
 *                            table will be <a
 *                            href="../../../concepts/tables/#sharding"
 *                            target="_top">sharded</a> according to the shard
 *                            key specified in the given @a type_id, or <a
 *                            href="../../../concepts/tables/#random-sharding"
 *                            target="_top">randomly sharded</a>, if no shard
 *                            key is specified.  Note that a type containing a
 *                            shard key cannot be used to create a replicated
 *                            table.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_payload_true
 *                                    <li>
 *                            gpudb::insert_records_from_payload_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_payload_false.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_foreign_keys:
 *                            Semicolon-separated list of <a
 *                            href="../../../concepts/tables/#foreign-keys"
 *                            target="_top">foreign keys</a>, of the format
 *                            '(source_column_name [, ...]) references
 *                            target_table_name(primary_key_column_name [,
 *                            ...]) [as foreign_key_name]'.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_foreign_shard_key:
 *                            Foreign shard key of the format 'source_column
 *                            references shard_by_column from
 *                            target_table(primary_key_column)'.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_partition_type:
 *                            <a href="../../../concepts/tables/#partitioning"
 *                            target="_top">Partitioning</a> scheme to use.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_payload_RANGE: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_INTERVAL: Use
 *                            <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_LIST: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_HASH: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_SERIES: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-series"
 *                            target="_top">series partitioning</a>.
 *                            </ul>
 *                                    <li>
 *                            gpudb::insert_records_from_payload_partition_keys:
 *                            Comma-separated list of partition keys, which are
 *                            the columns or column expressions by which
 *                            records will be assigned to partitions defined by
 *                            @a partition_definitions.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_partition_definitions:
 *                            Comma-separated list of partition definitions,
 *                            whose format depends on the choice of @a
 *                            partition_type.  See <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a>, or <a
 *                            href="../../../concepts/tables/#partitioning-by-series"
 *                            target="_top">series partitioning</a> for example
 *                            formats.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_is_automatic_partition:
 *                            If @a true, a new partition will be created for
 *                            values which don't fall into an existing
 *                            partition.  Currently only supported for <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitions</a>.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_payload_true
 *                                    <li>
 *                            gpudb::insert_records_from_payload_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_payload_false.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_ttl: Sets the
 *                            <a href="../../../concepts/ttl/"
 *                            target="_top">TTL</a> of the table specified in
 *                            @a tableName.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_chunk_size:
 *                            Indicates the number of records per chunk to be
 *                            used for this table.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_is_result_table:
 *                            Indicates whether the table is a <a
 *                            href="../../../concepts/tables_memory_only/"
 *                            target="_top">memory-only table</a>. A result
 *                            table cannot contain columns with store_only or
 *                            text_search <a
 *                            href="../../../concepts/types/#data-handling"
 *                            target="_top">data-handling</a> or that are <a
 *                            href="../../../concepts/types/#primitive-types"
 *                            target="_top">non-charN strings</a>, and it will
 *                            not be retained if the server is restarted.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_payload_true
 *                                    <li>
 *                            gpudb::insert_records_from_payload_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_payload_false.
 *                                    <li>
 *                            gpudb::insert_records_from_payload_strategy_definition:
 *                            The <a
 *                            href="../../../rm/concepts/#tier-strategies"
 *                            target="_top">tier strategy</a> for the table and
 *                            its columns.
 *                            </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::insert_records_from_payload_avro_header_bytes:
 *                 Optional number of bytes to skip when reading an avro
 *                 record.
 *                         <li>
 *                 gpudb::insert_records_from_payload_avro_num_records:
 *                 Optional number of avro records, if data includes only
 *                 records.
 *                         <li> gpudb::insert_records_from_payload_avro_schema:
 *                 Optional string representing avro schema, for insert records
 *                 in avro format, that does not include is schema.
 *                         <li>
 *                 gpudb::insert_records_from_payload_avro_schemaless: When
 *                 user provides 'avro_schema', avro data is assumed to be
 *                 schemaless, unless specified. Default is 'true' when given
 *                 avro_schema. Igonred when avro_schema is not given.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_true
 *                         <li> gpudb::insert_records_from_payload_false
 *                 </ul>
 *                         <li>
 *                 gpudb::insert_records_from_payload_bad_record_table_name:
 *                 Optional name of a table to which records that were rejected
 *                 are written.  The bad-record-table has the following
 *                 columns: line_number (long), line_rejected (string),
 *                 error_message (string).
 *                         <li>
 *                 gpudb::insert_records_from_payload_bad_record_table_limit: A
 *                 positive integer indicating the maximum number of records
 *                 that can be  written to the bad-record-table.   Default
 *                 value is 10000
 *                         <li>
 *                 gpudb::insert_records_from_payload_bad_record_table_limit_per_input:
 *                 For subscriptions: A positive integer indicating the maximum
 *                 number of records that can be written to the
 *                 bad-record-table per file/payload. Default value will be
 *                 'bad_record_table_limit' and total size of the table per
 *                 rank is limited to 'bad_record_table_limit'
 *                         <li> gpudb::insert_records_from_payload_batch_size:
 *                 Internal tuning parameter--number of records per batch when
 *                 inserting data.
 *                         <li>
 *                 gpudb::insert_records_from_payload_column_formats: For each
 *                 target column specified, applies the column-property-bound
 *                 format to the source data
 *                 loaded into that column.  Each column format will contain a
 *                 mapping of one or more of its column
 *                 properties to an appropriate format for each property.
 *                 Currently supported column properties
 *                 include date, time, & datetime. The parameter value must be
 *                 formatted as a JSON string of maps of
 *                 column names to maps of column properties to their
 *                 corresponding column formats, e.g.,
 *                 '{ "order_date" : { "date" : "%Y.%m.%d" }, "order_time" : {
 *                 "time" : "%H:%M:%S" } }'.
 *                 See @a default_column_formats for valid format syntax.
 *                         <li>
 *                 gpudb::insert_records_from_payload_columns_to_load:
 *                 Specifies a comma-delimited list of columns from the source
 *                 data to
 *                 load.  If more than one file is being loaded, this list
 *                 applies to all files.
 *                 Column numbers can be specified discretely or as a range.
 *                 For example, a value of '5,7,1..3' will
 *                 insert values from the fifth column in the source data into
 *                 the first column in the target table,
 *                 from the seventh column in the source data into the second
 *                 column in the target table, and from the
 *                 first through third columns in the source data into the
 *                 third through fifth columns in the target
 *                 table.
 *                 If the source data contains a header, column names matching
 *                 the file header names may be provided
 *                 instead of column numbers.  If the target table doesn't
 *                 exist, the table will be created with the
 *                 columns in this order.  If the target table does exist with
 *                 columns in a different order than the
 *                 source data, this list can be used to match the order of the
 *                 target table.  For example, a value of
 *                 'C, B, A' will create a three column table with column C,
 *                 followed by column B, followed by column
 *                 A; or will insert those fields in that order into a table
 *                 created with columns in that order.  If
 *                 the target table exists, the column names must match the
 *                 source data field names for a name-mapping
 *                 to be successful.
 *                 Mutually exclusive with @a columns_to_skip.
 *                         <li>
 *                 gpudb::insert_records_from_payload_columns_to_skip:
 *                 Specifies a comma-delimited list of columns from the source
 *                 data to
 *                 skip.  Mutually exclusive with @a columns_to_load.
 *                         <li>
 *                 gpudb::insert_records_from_payload_compression_type:
 *                 Optional: payload compression type
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_none:
 *                 Uncompressed
 *                         <li> gpudb::insert_records_from_payload_auto:
 *                 Default. Auto detect compression type
 *                         <li> gpudb::insert_records_from_payload_gzip: gzip
 *                 file compression.
 *                         <li> gpudb::insert_records_from_payload_bzip2: bzip2
 *                 file compression.
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_auto.
 *                         <li>
 *                 gpudb::insert_records_from_payload_default_column_formats:
 *                 Specifies the default format to be applied to source data
 *                 loaded
 *                 into columns with the corresponding column property.
 *                 Currently supported column properties include
 *                 date, time, & datetime.  This default column-property-bound
 *                 format can be overridden by specifying a
 *                 column property & format for a given target column in @a
 *                 column_formats. For
 *                 each specified annotation, the format will apply to all
 *                 columns with that annotation unless a custom
 *                 @a column_formats for that annotation is specified.
 *                 The parameter value must be formatted as a JSON string that
 *                 is a map of column properties to their
 *                 respective column formats, e.g., '{ "date" : "%Y.%m.%d",
 *                 "time" : "%H:%M:%S" }'.  Column
 *                 formats are specified as a string of control characters and
 *                 plain text. The supported control
 *                 characters are 'Y', 'm', 'd', 'H', 'M', 'S', and 's', which
 *                 follow the Linux 'strptime()'
 *                 specification, as well as 's', which specifies seconds and
 *                 fractional seconds (though the fractional
 *                 component will be truncated past milliseconds).
 *                 Formats for the 'date' annotation must include the 'Y', 'm',
 *                 and 'd' control characters. Formats for
 *                 the 'time' annotation must include the 'H', 'M', and either
 *                 'S' or 's' (but not both) control
 *                 characters. Formats for the 'datetime' annotation meet both
 *                 the 'date' and 'time' control character
 *                 requirements. For example, '{"datetime" : "%m/%d/%Y
 *                 %H:%M:%S" }' would be used to interpret text
 *                 as "05/04/2000 12:12:11"
 *                         <li>
 *                 gpudb::insert_records_from_payload_error_handling: Specifies
 *                 how errors should be handled upon insertion.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_permissive:
 *                 Records with missing columns are populated with nulls if
 *                 possible; otherwise, the malformed records are skipped.
 *                         <li>
 *                 gpudb::insert_records_from_payload_ignore_bad_records:
 *                 Malformed records are skipped.
 *                         <li> gpudb::insert_records_from_payload_abort: Stops
 *                 current insertion and aborts entire operation when an error
 *                 is encountered.  Primary key collisions are considered
 *                 abortable errors in this mode.
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_abort.
 *                         <li> gpudb::insert_records_from_payload_file_type:
 *                 Specifies the type of the file(s) whose records will be
 *                 inserted.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_avro: Avro
 *                 file format
 *                         <li>
 *                 gpudb::insert_records_from_payload_delimited_text: Delimited
 *                 text file format; e.g., CSV, TSV, PSV, etc.
 *                         <li> gpudb::insert_records_from_payload_gdb:
 *                 Esri/GDB file format
 *                         <li> gpudb::insert_records_from_payload_json: Json
 *                 file format
 *                         <li> gpudb::insert_records_from_payload_parquet:
 *                 Apache Parquet file format
 *                         <li> gpudb::insert_records_from_payload_shapefile:
 *                 ShapeFile file format
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_delimited_text.
 *                         <li>
 *                 gpudb::insert_records_from_payload_gdal_configuration_options:
 *                 Comma separated list of gdal conf options, for the specific
 *                 requets: key=value.  The default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_payload_ignore_existing_pk:
 *                 Specifies the record collision error-suppression policy for
 *                 inserting into a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only used when
 *                 not in upsert mode (upsert mode is disabled when @a
 *                 update_on_existing_pk is
 *                 @a false).  If set to
 *                 @a true, any record being inserted that is rejected
 *                 for having primary key values that match those of an
 *                 existing table record will be ignored with no
 *                 error generated.  If @a false, the rejection of any
 *                 record for having primary key values matching an existing
 *                 record will result in an error being
 *                 reported, as determined by @a error_handling.  If the
 *                 specified table does not
 *                 have a primary key or if upsert mode is in effect (@a
 *                 update_on_existing_pk is
 *                 @a true), then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_true: Ignore
 *                 new records whose primary key values collide with those of
 *                 existing records
 *                         <li> gpudb::insert_records_from_payload_false: Treat
 *                 as errors any new records whose primary key values collide
 *                 with those of existing records
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_false.
 *                         <li>
 *                 gpudb::insert_records_from_payload_ingestion_mode: Whether
 *                 to do a full load, dry run, or perform a type inference on
 *                 the source data.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_full: Run a
 *                 type inference on the source data (if needed) and ingest
 *                         <li> gpudb::insert_records_from_payload_dry_run:
 *                 Does not load data, but walks through the source data and
 *                 determines the number of valid records, taking into account
 *                 the current mode of @a error_handling.
 *                         <li>
 *                 gpudb::insert_records_from_payload_type_inference_only:
 *                 Infer the type of the source data and return, without
 *                 ingesting any data.  The inferred type is returned in the
 *                 response.
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_full.
 *                         <li> gpudb::insert_records_from_payload_layer:
 *                 Optional: geo files layer(s) name(s): comma separated.  The
 *                 default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_payload_loading_mode: Scheme for
 *                 distributing the extraction and loading of data from the
 *                 source data file(s). This option applies only when loading
 *                 files that are local to the database
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_head: The
 *                 head node loads all data. All files must be available to the
 *                 head node.
 *                         <li>
 *                 gpudb::insert_records_from_payload_distributed_shared: The
 *                 head node coordinates loading data by worker
 *                 processes across all nodes from shared files available to
 *                 all workers.
 *                 NOTE:
 *                 Instead of existing on a shared source, the files can be
 *                 duplicated on a source local to each host
 *                 to improve performance, though the files must appear as the
 *                 same data set from the perspective of
 *                 all hosts performing the load.
 *                         <li>
 *                 gpudb::insert_records_from_payload_distributed_local: A
 *                 single worker process on each node loads all files
 *                 that are available to it. This option works best when each
 *                 worker loads files from its own file
 *                 system, to maximize performance. In order to avoid data
 *                 duplication, either each worker performing
 *                 the load needs to have visibility to a set of files unique
 *                 to it (no file is visible to more than
 *                 one node) or the target table needs to have a primary key
 *                 (which will allow the worker to
 *                 automatically deduplicate data).
 *                 NOTE:
 *                 If the target table doesn't exist, the table structure will
 *                 be determined by the head node. If the
 *                 head node has no files local to it, it will be unable to
 *                 determine the structure and the request
 *                 will fail.
 *                 If the head node is configured to have no worker processes,
 *                 no data strictly accessible to the head
 *                 node will be loaded.
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_head.
 *                         <li>
 *                 gpudb::insert_records_from_payload_local_time_offset: For
 *                 Avro local timestamp columns
 *                         <li>
 *                 gpudb::insert_records_from_payload_max_records_to_load:
 *                 Limit the number of records to load in this request: If this
 *                 number is larger than a batch_size, then the number of
 *                 records loaded will be limited to the next whole number of
 *                 batch_size (per working thread).  The default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_payload_num_tasks_per_rank:
 *                 Optional: number of tasks for reading file per rank. Default
 *                 will be external_file_reader_num_tasks
 *                         <li>
 *                 gpudb::insert_records_from_payload_poll_interval: If @a
 *                 true, the number of seconds between attempts to load
 *                 external files into the table.  If zero, polling will be
 *                 continuous as long as data is found.  If no data is found,
 *                 the interval will steadily increase to a maximum of 60
 *                 seconds.
 *                         <li>
 *                 gpudb::insert_records_from_payload_primary_keys: Optional:
 *                 comma separated list of column names, to set as primary
 *                 keys, when not specified in the type.  The default value is
 *                 ''.
 *                         <li>
 *                 gpudb::insert_records_from_payload_schema_registry_schema_id
 *                         <li>
 *                 gpudb::insert_records_from_payload_schema_registry_schema_name
 *                         <li>
 *                 gpudb::insert_records_from_payload_schema_registry_schema_version
 *                         <li> gpudb::insert_records_from_payload_shard_keys:
 *                 Optional: comma separated list of column names, to set as
 *                 primary keys, when not specified in the type.  The default
 *                 value is ''.
 *                         <li> gpudb::insert_records_from_payload_skip_lines:
 *                 Skip number of lines from begining of file.
 *                         <li> gpudb::insert_records_from_payload_subscribe:
 *                 Continuously poll the data source to check for new data and
 *                 load it into the table.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_true
 *                         <li> gpudb::insert_records_from_payload_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_false.
 *                         <li>
 *                 gpudb::insert_records_from_payload_table_insert_mode:
 *                 Optional: table_insert_mode. When inserting records from
 *                 multiple files: if table_per_file then insert from each file
 *                 into a new table. Currently supported only for shapefiles.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_single
 *                         <li>
 *                 gpudb::insert_records_from_payload_table_per_file
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_single.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_comment_string:
 *                 Specifies the character string that should be interpreted as
 *                 a comment line
 *                 prefix in the source data.  All lines in the data starting
 *                 with the provided string are ignored.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '#'.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_delimiter: Specifies
 *                 the character delimiting field values in the source data
 *                 and field names in the header (if present).
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is ','.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_escape_character:
 *                 Specifies the character that is used to escape other
 *                 characters in
 *                 the source data.
 *                 An 'a', 'b', 'f', 'n', 'r', 't', or 'v' preceded by an
 *                 escape character will be interpreted as the
 *                 ASCII bell, backspace, form feed, line feed, carriage
 *                 return, horizontal tab, & vertical tab,
 *                 respectively.  For example, the escape character followed by
 *                 an 'n' will be interpreted as a newline
 *                 within a field value.
 *                 The escape character can also be used to escape the quoting
 *                 character, and will be treated as an
 *                 escape character whether it is within a quoted field value
 *                 or not.
 *                 For @a delimited_text @a file_type only.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_has_header:
 *                 Indicates whether the source data contains a header row.
 *                 For @a delimited_text @a file_type only.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_true
 *                         <li> gpudb::insert_records_from_payload_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_true.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_header_property_delimiter:
 *                 Specifies the delimiter for
 *                 <a href="../../../concepts/types/#column-properties"
 *                 target="_top">column properties</a> in the header row (if
 *                 present).  Cannot be set to same value as @a text_delimiter.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '|'.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_null_string:
 *                 Specifies the character string that should be interpreted as
 *                 a null
 *                 value in the source data.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '\\N'.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_quote_character:
 *                 Specifies the character that should be interpreted as a
 *                 field value
 *                 quoting character in the source data.  The character must
 *                 appear at beginning and end of field value
 *                 to take effect.  Delimiters within quoted fields are treated
 *                 as literals and not delimiters.  Within
 *                 a quoted field, two consecutive quote characters will be
 *                 interpreted as a single literal quote
 *                 character, effectively escaping it.  To not have a quote
 *                 character, specify an empty string.
 *                 For @a delimited_text @a file_type only.  The default value
 *                 is '"'.
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_search_columns: Add
 *                 'text_search' property to internally inferenced string
 *                 columns. Comma seperated list of column names or '*' for all
 *                 columns. To add text_search property only to string columns
 *                 of minimum size, set also the option
 *                 'text_search_min_column_length'
 *                         <li>
 *                 gpudb::insert_records_from_payload_text_search_min_column_length:
 *                 Set minimum column size. Used only when
 *                 'text_search_columns' has a value.
 *                         <li>
 *                 gpudb::insert_records_from_payload_truncate_strings: If set
 *                 to @a true, truncate string values that are longer than the
 *                 column's type size.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_true
 *                         <li> gpudb::insert_records_from_payload_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_false.
 *                         <li>
 *                 gpudb::insert_records_from_payload_truncate_table: If set to
 *                 @a true, truncates the table specified by @a tableName prior
 *                 to loading the file(s).
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_true
 *                         <li> gpudb::insert_records_from_payload_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_false.
 *                         <li>
 *                 gpudb::insert_records_from_payload_type_inference_mode:
 *                 optimize type inference for:
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_accuracy:
 *                 Scans data to get exactly-typed & sized columns for all data
 *                 scanned.
 *                         <li> gpudb::insert_records_from_payload_speed: Scans
 *                 data and picks the widest possible column types so that
 *                 'all' values will fit with minimum data scanned
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_speed.
 *                         <li>
 *                 gpudb::insert_records_from_payload_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting into a
 *                 table
 *                 with a <a href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>. If set to
 *                 @a true, any existing table record with primary
 *                 key values that match those of a record being inserted will
 *                 be replaced by that new record (the new
 *                 data will be "upserted"). If set to @a false,
 *                 any existing table record with primary key values that match
 *                 those of a record being inserted will
 *                 remain unchanged, while the new record will be rejected and
 *                 the error handled as determined by
 *                 @a ignore_existing_pk & @a error_handling.  If the
 *                 specified table does not have a primary key, then this
 *                 option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_payload_true: Upsert
 *                 new records when primary keys match existing records
 *                         <li> gpudb::insert_records_from_payload_false:
 *                 Reject new records when primary keys match existing records
 *                 </ul>
 *                 The default value is
 *                 gpudb::insert_records_from_payload_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsFromPayloadResponse& insertRecordsFromPayload( const std::string& tableName,
                                                            const std::string& dataText,
                                                            const std::vector<uint8_t>& dataBytes,
                                                            const std::map<std::string, std::map<std::string, std::string> >& modifyColumns,
                                                            const std::map<std::string, std::string>& createTableOptions,
                                                            const std::map<std::string, std::string>& options,
                                                            InsertRecordsFromPayloadResponse& response_ ) const;

/**
 * Computes remote query result and inserts the result data into a new or
 * existing table
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsFromQueryResponse insertRecordsFromQuery( const InsertRecordsFromQueryRequest& request_ ) const;

/**
 * Computes remote query result and inserts the result data into a new or
 * existing table
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsFromQueryResponse& insertRecordsFromQuery( const InsertRecordsFromQueryRequest& request_,
                                                        InsertRecordsFromQueryResponse& response_ ) const;

/**
 * Computes remote query result and inserts the result data into a new or
 * existing table
 * 
 * @param tableName  Name of the table into which the data will be inserted, in
 *                   [schema_name.]table_name format, using standard
 *                   <a href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 *                   If the table does not exist, the table will be created
 *                   using either an existing
 *                   @a type_id or the type inferred from the
 *                   remote query, and the new table name will have to meet
 *                   standard
 *                   <a href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>.
 * @param remoteQuery  Query for which result data needs to be imported
 * @param modifyColumns  Not implemented yet
 * @param createTableOptions  Options used when creating the target table.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_query_type_id: ID of a
 *                            currently registered <a
 *                            href="../../../concepts/types/"
 *                            target="_top">type</a>.  The default value is ''.
 *                                    <li>
 *                            gpudb::insert_records_from_query_no_error_if_exists:
 *                            If @a true, prevents an error from occurring if
 *                            the table already exists and is of the given
 *                            type.  If a table with the same ID but a
 *                            different type exists, it is still an error.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_query_true
 *                                    <li>
 *                            gpudb::insert_records_from_query_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_query_false.
 *                                    <li>
 *                            gpudb::insert_records_from_query_is_replicated:
 *                            Affects the <a
 *                            href="../../../concepts/tables/#distribution"
 *                            target="_top">distribution scheme</a> for the
 *                            table's data.  If @a true and the given type has
 *                            no explicit <a
 *                            href="../../../concepts/tables/#shard-key"
 *                            target="_top">shard key</a> defined, the table
 *                            will be <a
 *                            href="../../../concepts/tables/#replication"
 *                            target="_top">replicated</a>.  If @a false, the
 *                            table will be <a
 *                            href="../../../concepts/tables/#sharding"
 *                            target="_top">sharded</a> according to the shard
 *                            key specified in the given @a type_id, or <a
 *                            href="../../../concepts/tables/#random-sharding"
 *                            target="_top">randomly sharded</a>, if no shard
 *                            key is specified.  Note that a type containing a
 *                            shard key cannot be used to create a replicated
 *                            table.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_query_true
 *                                    <li>
 *                            gpudb::insert_records_from_query_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_query_false.
 *                                    <li>
 *                            gpudb::insert_records_from_query_foreign_keys:
 *                            Semicolon-separated list of <a
 *                            href="../../../concepts/tables/#foreign-keys"
 *                            target="_top">foreign keys</a>, of the format
 *                            '(source_column_name [, ...]) references
 *                            target_table_name(primary_key_column_name [,
 *                            ...]) [as foreign_key_name]'.
 *                                    <li>
 *                            gpudb::insert_records_from_query_foreign_shard_key:
 *                            Foreign shard key of the format 'source_column
 *                            references shard_by_column from
 *                            target_table(primary_key_column)'.
 *                                    <li>
 *                            gpudb::insert_records_from_query_partition_type:
 *                            <a href="../../../concepts/tables/#partitioning"
 *                            target="_top">Partitioning</a> scheme to use.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_query_RANGE: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_query_INTERVAL: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_query_LIST: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_query_HASH: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_query_SERIES: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-series"
 *                            target="_top">series partitioning</a>.
 *                            </ul>
 *                                    <li>
 *                            gpudb::insert_records_from_query_partition_keys:
 *                            Comma-separated list of partition keys, which are
 *                            the columns or column expressions by which
 *                            records will be assigned to partitions defined by
 *                            @a partition_definitions.
 *                                    <li>
 *                            gpudb::insert_records_from_query_partition_definitions:
 *                            Comma-separated list of partition definitions,
 *                            whose format depends on the choice of @a
 *                            partition_type.  See <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a>, or <a
 *                            href="../../../concepts/tables/#partitioning-by-series"
 *                            target="_top">series partitioning</a> for example
 *                            formats.
 *                                    <li>
 *                            gpudb::insert_records_from_query_is_automatic_partition:
 *                            If @a true, a new partition will be created for
 *                            values which don't fall into an existing
 *                            partition.  Currently only supported for <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitions</a>.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_query_true
 *                                    <li>
 *                            gpudb::insert_records_from_query_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_query_false.
 *                                    <li>
 *                            gpudb::insert_records_from_query_ttl: Sets the <a
 *                            href="../../../concepts/ttl/"
 *                            target="_top">TTL</a> of the table specified in
 *                            @a tableName.
 *                                    <li>
 *                            gpudb::insert_records_from_query_chunk_size:
 *                            Indicates the number of records per chunk to be
 *                            used for this table.
 *                                    <li>
 *                            gpudb::insert_records_from_query_is_result_table:
 *                            Indicates whether the table is a <a
 *                            href="../../../concepts/tables_memory_only/"
 *                            target="_top">memory-only table</a>. A result
 *                            table cannot contain columns with store_only or
 *                            text_search <a
 *                            href="../../../concepts/types/#data-handling"
 *                            target="_top">data-handling</a> or that are <a
 *                            href="../../../concepts/types/#primitive-types"
 *                            target="_top">non-charN strings</a>, and it will
 *                            not be retained if the server is restarted.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_query_true
 *                                    <li>
 *                            gpudb::insert_records_from_query_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_query_false.
 *                                    <li>
 *                            gpudb::insert_records_from_query_strategy_definition:
 *                            The <a
 *                            href="../../../rm/concepts/#tier-strategies"
 *                            target="_top">tier strategy</a> for the table and
 *                            its columns.
 *                            </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::insert_records_from_query_bad_record_table_name:
 *                 Optional name of a table to which records that were rejected
 *                 are written.  The bad-record-table has the following
 *                 columns: line_number (long), line_rejected (string),
 *                 error_message (string). When error handling is Abort, bad
 *                 records table is not populated.
 *                         <li>
 *                 gpudb::insert_records_from_query_bad_record_table_limit: A
 *                 positive integer indicating the maximum number of records
 *                 that can be  written to the bad-record-table.   Default
 *                 value is 10000
 *                         <li> gpudb::insert_records_from_query_batch_size:
 *                 Number of records per batch when inserting data.
 *                         <li>
 *                 gpudb::insert_records_from_query_datasource_name: Name of an
 *                 existing external data source from which table will be
 *                 loaded
 *                         <li>
 *                 gpudb::insert_records_from_query_error_handling: Specifies
 *                 how errors should be handled upon insertion.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_query_permissive:
 *                 Records with missing columns are populated with nulls if
 *                 possible; otherwise, the malformed records are skipped.
 *                         <li>
 *                 gpudb::insert_records_from_query_ignore_bad_records:
 *                 Malformed records are skipped.
 *                         <li> gpudb::insert_records_from_query_abort: Stops
 *                 current insertion and aborts entire operation when an error
 *                 is encountered.  Primary key collisions are considered
 *                 abortable errors in this mode.
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_query_abort.
 *                         <li>
 *                 gpudb::insert_records_from_query_ignore_existing_pk:
 *                 Specifies the record collision error-suppression policy for
 *                 inserting into a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only used when
 *                 not in upsert mode (upsert mode is disabled when @a
 *                 update_on_existing_pk is
 *                 @a false).  If set to
 *                 @a true, any record being inserted that is rejected
 *                 for having primary key values that match those of an
 *                 existing table record will be ignored with no
 *                 error generated.  If @a false, the rejection of any
 *                 record for having primary key values matching an existing
 *                 record will result in an error being
 *                 reported, as determined by @a error_handling.  If the
 *                 specified table does not
 *                 have a primary key or if upsert mode is in effect (@a
 *                 update_on_existing_pk is
 *                 @a true), then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_query_true: Ignore
 *                 new records whose primary key values collide with those of
 *                 existing records
 *                         <li> gpudb::insert_records_from_query_false: Treat
 *                 as errors any new records whose primary key values collide
 *                 with those of existing records
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_query_false.
 *                         <li>
 *                 gpudb::insert_records_from_query_ingestion_mode: Whether to
 *                 do a full load, dry run, or perform a type inference on the
 *                 source data.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_query_full: Run a
 *                 type inference on the source data (if needed) and ingest
 *                         <li> gpudb::insert_records_from_query_dry_run: Does
 *                 not load data, but walks through the source data and
 *                 determines the number of valid records, taking into account
 *                 the current mode of @a error_handling.
 *                         <li>
 *                 gpudb::insert_records_from_query_type_inference_only: Infer
 *                 the type of the source data and return, without ingesting
 *                 any data.  The inferred type is returned in the response.
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_query_full.
 *                         <li>
 *                 gpudb::insert_records_from_query_jdbc_fetch_size: The JDBC
 *                 fetch size, which determines how many rows to fetch per
 *                 round trip.
 *                         <li>
 *                 gpudb::insert_records_from_query_jdbc_session_init_statement:
 *                 Executes the statement per each jdbc session before doing
 *                 actual load.  The default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_query_num_splits_per_rank:
 *                 Optional: number of splits for reading data per rank.
 *                 Default will be external_file_reader_num_tasks.  The default
 *                 value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_query_num_tasks_per_rank:
 *                 Optional: number of tasks for reading data per rank. Default
 *                 will be external_file_reader_num_tasks
 *                         <li> gpudb::insert_records_from_query_primary_keys:
 *                 Optional: comma separated list of column names, to set as
 *                 primary keys, when not specified in the type.  The default
 *                 value is ''.
 *                         <li> gpudb::insert_records_from_query_shard_keys:
 *                 Optional: comma separated list of column names, to set as
 *                 primary keys, when not specified in the type.  The default
 *                 value is ''.
 *                         <li> gpudb::insert_records_from_query_subscribe:
 *                 Continuously poll the data source to check for new data and
 *                 load it into the table.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_query_true
 *                         <li> gpudb::insert_records_from_query_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_query_false.
 *                         <li>
 *                 gpudb::insert_records_from_query_truncate_table: If set to
 *                 @a true, truncates the table specified by @a tableName prior
 *                 to loading the data.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_query_true
 *                         <li> gpudb::insert_records_from_query_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_query_false.
 *                         <li> gpudb::insert_records_from_query_remote_query:
 *                 Remote SQL query from which data will be sourced
 *                         <li>
 *                 gpudb::insert_records_from_query_remote_query_order_by: Name
 *                 of column to be used for splitting the query into multiple
 *                 sub-queries using ordering of given column.  The default
 *                 value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_query_remote_query_filter_column:
 *                 Name of column to be used for splitting the query into
 *                 multiple sub-queries using the data distribution of given
 *                 column.  The default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_query_remote_query_increasing_column:
 *                 Column on subscribed remote query result that will increase
 *                 for new records (e.g., TIMESTAMP).  The default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_query_remote_query_partition_column:
 *                 Alias name for remote_query_filter_column.  The default
 *                 value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_query_truncate_strings: If set to
 *                 @a true, truncate string values that are longer than the
 *                 column's type size.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_query_true
 *                         <li> gpudb::insert_records_from_query_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_query_false.
 *                         <li>
 *                 gpudb::insert_records_from_query_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting into a
 *                 table
 *                 with a <a href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>. If set to
 *                 @a true, any existing table record with primary
 *                 key values that match those of a record being inserted will
 *                 be replaced by that new record (the new
 *                 data will be "upserted"). If set to @a false,
 *                 any existing table record with primary key values that match
 *                 those of a record being inserted will
 *                 remain unchanged, while the new record will be rejected and
 *                 the error handled as determined by
 *                 @a ignore_existing_pk & @a error_handling.  If the
 *                 specified table does not have a primary key, then this
 *                 option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_query_true: Upsert
 *                 new records when primary keys match existing records
 *                         <li> gpudb::insert_records_from_query_false: Reject
 *                 new records when primary keys match existing records
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_query_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsFromQueryResponse insertRecordsFromQuery( const std::string& tableName,
                                                       const std::string& remoteQuery,
                                                       const std::map<std::string, std::map<std::string, std::string> >& modifyColumns,
                                                       const std::map<std::string, std::string>& createTableOptions,
                                                       const std::map<std::string, std::string>& options ) const;

/**
 * Computes remote query result and inserts the result data into a new or
 * existing table
 * 
 * @param tableName  Name of the table into which the data will be inserted, in
 *                   [schema_name.]table_name format, using standard
 *                   <a href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 *                   If the table does not exist, the table will be created
 *                   using either an existing
 *                   @a type_id or the type inferred from the
 *                   remote query, and the new table name will have to meet
 *                   standard
 *                   <a href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>.
 * @param remoteQuery  Query for which result data needs to be imported
 * @param modifyColumns  Not implemented yet
 * @param createTableOptions  Options used when creating the target table.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_query_type_id: ID of a
 *                            currently registered <a
 *                            href="../../../concepts/types/"
 *                            target="_top">type</a>.  The default value is ''.
 *                                    <li>
 *                            gpudb::insert_records_from_query_no_error_if_exists:
 *                            If @a true, prevents an error from occurring if
 *                            the table already exists and is of the given
 *                            type.  If a table with the same ID but a
 *                            different type exists, it is still an error.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_query_true
 *                                    <li>
 *                            gpudb::insert_records_from_query_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_query_false.
 *                                    <li>
 *                            gpudb::insert_records_from_query_is_replicated:
 *                            Affects the <a
 *                            href="../../../concepts/tables/#distribution"
 *                            target="_top">distribution scheme</a> for the
 *                            table's data.  If @a true and the given type has
 *                            no explicit <a
 *                            href="../../../concepts/tables/#shard-key"
 *                            target="_top">shard key</a> defined, the table
 *                            will be <a
 *                            href="../../../concepts/tables/#replication"
 *                            target="_top">replicated</a>.  If @a false, the
 *                            table will be <a
 *                            href="../../../concepts/tables/#sharding"
 *                            target="_top">sharded</a> according to the shard
 *                            key specified in the given @a type_id, or <a
 *                            href="../../../concepts/tables/#random-sharding"
 *                            target="_top">randomly sharded</a>, if no shard
 *                            key is specified.  Note that a type containing a
 *                            shard key cannot be used to create a replicated
 *                            table.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_query_true
 *                                    <li>
 *                            gpudb::insert_records_from_query_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_query_false.
 *                                    <li>
 *                            gpudb::insert_records_from_query_foreign_keys:
 *                            Semicolon-separated list of <a
 *                            href="../../../concepts/tables/#foreign-keys"
 *                            target="_top">foreign keys</a>, of the format
 *                            '(source_column_name [, ...]) references
 *                            target_table_name(primary_key_column_name [,
 *                            ...]) [as foreign_key_name]'.
 *                                    <li>
 *                            gpudb::insert_records_from_query_foreign_shard_key:
 *                            Foreign shard key of the format 'source_column
 *                            references shard_by_column from
 *                            target_table(primary_key_column)'.
 *                                    <li>
 *                            gpudb::insert_records_from_query_partition_type:
 *                            <a href="../../../concepts/tables/#partitioning"
 *                            target="_top">Partitioning</a> scheme to use.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_query_RANGE: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_query_INTERVAL: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_query_LIST: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_query_HASH: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a>.
 *                                    <li>
 *                            gpudb::insert_records_from_query_SERIES: Use <a
 *                            href="../../../concepts/tables/#partitioning-by-series"
 *                            target="_top">series partitioning</a>.
 *                            </ul>
 *                                    <li>
 *                            gpudb::insert_records_from_query_partition_keys:
 *                            Comma-separated list of partition keys, which are
 *                            the columns or column expressions by which
 *                            records will be assigned to partitions defined by
 *                            @a partition_definitions.
 *                                    <li>
 *                            gpudb::insert_records_from_query_partition_definitions:
 *                            Comma-separated list of partition definitions,
 *                            whose format depends on the choice of @a
 *                            partition_type.  See <a
 *                            href="../../../concepts/tables/#partitioning-by-range"
 *                            target="_top">range partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-interval"
 *                            target="_top">interval partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitioning</a>, <a
 *                            href="../../../concepts/tables/#partitioning-by-hash"
 *                            target="_top">hash partitioning</a>, or <a
 *                            href="../../../concepts/tables/#partitioning-by-series"
 *                            target="_top">series partitioning</a> for example
 *                            formats.
 *                                    <li>
 *                            gpudb::insert_records_from_query_is_automatic_partition:
 *                            If @a true, a new partition will be created for
 *                            values which don't fall into an existing
 *                            partition.  Currently only supported for <a
 *                            href="../../../concepts/tables/#partitioning-by-list"
 *                            target="_top">list partitions</a>.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_query_true
 *                                    <li>
 *                            gpudb::insert_records_from_query_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_query_false.
 *                                    <li>
 *                            gpudb::insert_records_from_query_ttl: Sets the <a
 *                            href="../../../concepts/ttl/"
 *                            target="_top">TTL</a> of the table specified in
 *                            @a tableName.
 *                                    <li>
 *                            gpudb::insert_records_from_query_chunk_size:
 *                            Indicates the number of records per chunk to be
 *                            used for this table.
 *                                    <li>
 *                            gpudb::insert_records_from_query_is_result_table:
 *                            Indicates whether the table is a <a
 *                            href="../../../concepts/tables_memory_only/"
 *                            target="_top">memory-only table</a>. A result
 *                            table cannot contain columns with store_only or
 *                            text_search <a
 *                            href="../../../concepts/types/#data-handling"
 *                            target="_top">data-handling</a> or that are <a
 *                            href="../../../concepts/types/#primitive-types"
 *                            target="_top">non-charN strings</a>, and it will
 *                            not be retained if the server is restarted.
 *                            <ul>
 *                                    <li>
 *                            gpudb::insert_records_from_query_true
 *                                    <li>
 *                            gpudb::insert_records_from_query_false
 *                            </ul>
 *                            The default value is
 *                            gpudb::insert_records_from_query_false.
 *                                    <li>
 *                            gpudb::insert_records_from_query_strategy_definition:
 *                            The <a
 *                            href="../../../rm/concepts/#tier-strategies"
 *                            target="_top">tier strategy</a> for the table and
 *                            its columns.
 *                            </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::insert_records_from_query_bad_record_table_name:
 *                 Optional name of a table to which records that were rejected
 *                 are written.  The bad-record-table has the following
 *                 columns: line_number (long), line_rejected (string),
 *                 error_message (string). When error handling is Abort, bad
 *                 records table is not populated.
 *                         <li>
 *                 gpudb::insert_records_from_query_bad_record_table_limit: A
 *                 positive integer indicating the maximum number of records
 *                 that can be  written to the bad-record-table.   Default
 *                 value is 10000
 *                         <li> gpudb::insert_records_from_query_batch_size:
 *                 Number of records per batch when inserting data.
 *                         <li>
 *                 gpudb::insert_records_from_query_datasource_name: Name of an
 *                 existing external data source from which table will be
 *                 loaded
 *                         <li>
 *                 gpudb::insert_records_from_query_error_handling: Specifies
 *                 how errors should be handled upon insertion.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_query_permissive:
 *                 Records with missing columns are populated with nulls if
 *                 possible; otherwise, the malformed records are skipped.
 *                         <li>
 *                 gpudb::insert_records_from_query_ignore_bad_records:
 *                 Malformed records are skipped.
 *                         <li> gpudb::insert_records_from_query_abort: Stops
 *                 current insertion and aborts entire operation when an error
 *                 is encountered.  Primary key collisions are considered
 *                 abortable errors in this mode.
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_query_abort.
 *                         <li>
 *                 gpudb::insert_records_from_query_ignore_existing_pk:
 *                 Specifies the record collision error-suppression policy for
 *                 inserting into a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only used when
 *                 not in upsert mode (upsert mode is disabled when @a
 *                 update_on_existing_pk is
 *                 @a false).  If set to
 *                 @a true, any record being inserted that is rejected
 *                 for having primary key values that match those of an
 *                 existing table record will be ignored with no
 *                 error generated.  If @a false, the rejection of any
 *                 record for having primary key values matching an existing
 *                 record will result in an error being
 *                 reported, as determined by @a error_handling.  If the
 *                 specified table does not
 *                 have a primary key or if upsert mode is in effect (@a
 *                 update_on_existing_pk is
 *                 @a true), then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_query_true: Ignore
 *                 new records whose primary key values collide with those of
 *                 existing records
 *                         <li> gpudb::insert_records_from_query_false: Treat
 *                 as errors any new records whose primary key values collide
 *                 with those of existing records
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_query_false.
 *                         <li>
 *                 gpudb::insert_records_from_query_ingestion_mode: Whether to
 *                 do a full load, dry run, or perform a type inference on the
 *                 source data.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_query_full: Run a
 *                 type inference on the source data (if needed) and ingest
 *                         <li> gpudb::insert_records_from_query_dry_run: Does
 *                 not load data, but walks through the source data and
 *                 determines the number of valid records, taking into account
 *                 the current mode of @a error_handling.
 *                         <li>
 *                 gpudb::insert_records_from_query_type_inference_only: Infer
 *                 the type of the source data and return, without ingesting
 *                 any data.  The inferred type is returned in the response.
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_query_full.
 *                         <li>
 *                 gpudb::insert_records_from_query_jdbc_fetch_size: The JDBC
 *                 fetch size, which determines how many rows to fetch per
 *                 round trip.
 *                         <li>
 *                 gpudb::insert_records_from_query_jdbc_session_init_statement:
 *                 Executes the statement per each jdbc session before doing
 *                 actual load.  The default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_query_num_splits_per_rank:
 *                 Optional: number of splits for reading data per rank.
 *                 Default will be external_file_reader_num_tasks.  The default
 *                 value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_query_num_tasks_per_rank:
 *                 Optional: number of tasks for reading data per rank. Default
 *                 will be external_file_reader_num_tasks
 *                         <li> gpudb::insert_records_from_query_primary_keys:
 *                 Optional: comma separated list of column names, to set as
 *                 primary keys, when not specified in the type.  The default
 *                 value is ''.
 *                         <li> gpudb::insert_records_from_query_shard_keys:
 *                 Optional: comma separated list of column names, to set as
 *                 primary keys, when not specified in the type.  The default
 *                 value is ''.
 *                         <li> gpudb::insert_records_from_query_subscribe:
 *                 Continuously poll the data source to check for new data and
 *                 load it into the table.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_query_true
 *                         <li> gpudb::insert_records_from_query_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_query_false.
 *                         <li>
 *                 gpudb::insert_records_from_query_truncate_table: If set to
 *                 @a true, truncates the table specified by @a tableName prior
 *                 to loading the data.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_query_true
 *                         <li> gpudb::insert_records_from_query_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_query_false.
 *                         <li> gpudb::insert_records_from_query_remote_query:
 *                 Remote SQL query from which data will be sourced
 *                         <li>
 *                 gpudb::insert_records_from_query_remote_query_order_by: Name
 *                 of column to be used for splitting the query into multiple
 *                 sub-queries using ordering of given column.  The default
 *                 value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_query_remote_query_filter_column:
 *                 Name of column to be used for splitting the query into
 *                 multiple sub-queries using the data distribution of given
 *                 column.  The default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_query_remote_query_increasing_column:
 *                 Column on subscribed remote query result that will increase
 *                 for new records (e.g., TIMESTAMP).  The default value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_query_remote_query_partition_column:
 *                 Alias name for remote_query_filter_column.  The default
 *                 value is ''.
 *                         <li>
 *                 gpudb::insert_records_from_query_truncate_strings: If set to
 *                 @a true, truncate string values that are longer than the
 *                 column's type size.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_query_true
 *                         <li> gpudb::insert_records_from_query_false
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_query_false.
 *                         <li>
 *                 gpudb::insert_records_from_query_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting into a
 *                 table
 *                 with a <a href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>. If set to
 *                 @a true, any existing table record with primary
 *                 key values that match those of a record being inserted will
 *                 be replaced by that new record (the new
 *                 data will be "upserted"). If set to @a false,
 *                 any existing table record with primary key values that match
 *                 those of a record being inserted will
 *                 remain unchanged, while the new record will be rejected and
 *                 the error handled as determined by
 *                 @a ignore_existing_pk & @a error_handling.  If the
 *                 specified table does not have a primary key, then this
 *                 option has no effect.
 *                 <ul>
 *                         <li> gpudb::insert_records_from_query_true: Upsert
 *                 new records when primary keys match existing records
 *                         <li> gpudb::insert_records_from_query_false: Reject
 *                 new records when primary keys match existing records
 *                 </ul>
 *                 The default value is gpudb::insert_records_from_query_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsFromQueryResponse& insertRecordsFromQuery( const std::string& tableName,
                                                        const std::string& remoteQuery,
                                                        const std::map<std::string, std::map<std::string, std::string> >& modifyColumns,
                                                        const std::map<std::string, std::string>& createTableOptions,
                                                        const std::map<std::string, std::string>& options,
                                                        InsertRecordsFromQueryResponse& response_ ) const;

/**
 * Generates a specified number of random records and adds them to the given
 * table.
 * There is an optional parameter that allows the user to customize the ranges
 * of
 * the column values. It also allows the user to specify linear profiles for
 * some
 * or all columns in which case linear values are generated rather than random
 * ones. Only individual tables are supported for this operation.
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all random records are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsRandomResponse insertRecordsRandom( const InsertRecordsRandomRequest& request_ ) const;

/**
 * Generates a specified number of random records and adds them to the given
 * table.
 * There is an optional parameter that allows the user to customize the ranges
 * of
 * the column values. It also allows the user to specify linear profiles for
 * some
 * or all columns in which case linear values are generated rather than random
 * ones. Only individual tables are supported for this operation.
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all random records are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsRandomResponse& insertRecordsRandom( const InsertRecordsRandomRequest& request_,
                                                  InsertRecordsRandomResponse& response_ ) const;

/**
 * Generates a specified number of random records and adds them to the given
 * table.
 * There is an optional parameter that allows the user to customize the ranges
 * of
 * the column values. It also allows the user to specify linear profiles for
 * some
 * or all columns in which case linear values are generated rather than random
 * ones. Only individual tables are supported for this operation.
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all random records are fully available.
 * 
 * @param tableName  Table to which random records will be added, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table, not a view.
 * @param count  Number of records to generate.
 * @param options  Optional parameter to pass in specifications for the
 *                 randomness of the values.  This map is different from the
 *                 *options* parameter of most other endpoints in that it is a
 *                 map of string to map of string to doubles, while most others
 *                 are maps of string to string.  In this map, the top level
 *                 keys represent which column's parameters are being
 *                 specified, while the internal keys represents which
 *                 parameter is being specified.  These parameters take on
 *                 different meanings depending on the type of the column.
 *                 Below follows a more detailed description of the map:
 *                 <ul>
 *                         <li> gpudb::insert_records_random_seed: If provided,
 *                 the internal random number generator will be initialized
 *                 with the given value.  The minimum is 0.  This allows for
 *                 the same set of random numbers to be generated across
 *                 invocation of this endpoint in case the user wants to repeat
 *                 the test.  Since @a options, is a map of maps, we need an
 *                 internal map to provide the seed value.  For example, to
 *                 pass 100 as the seed value through this parameter, you need
 *                 something equivalent to: 'options' = {'seed': { 'value': 100
 *                 } }
 *                 <ul>
 *                         <li> gpudb::insert_records_random_value: The seed
 *                 value to use
 *                 </ul>
 *                         <li> gpudb::insert_records_random_all: This key
 *                 indicates that the specifications relayed in the internal
 *                 map are to be applied to all columns of the records.
 *                 <ul>
 *                         <li> gpudb::insert_records_random_min: For numerical
 *                 columns, the minimum of the generated values is set to this
 *                 value.  Default is -99999.  For point, shape, and track
 *                 columns, min for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 -180.0 and -90.0. For the 'TIMESTAMP' column, the default
 *                 minimum corresponds to Jan 1, 2010.
 *                 For string columns, the minimum length of the randomly
 *                 generated strings is set to this value (default is 0). If
 *                 both minimum and maximum are provided, minimum must be less
 *                 than or equal to max. Value needs to be within [0, 200].
 *                 If the min is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_max: For numerical
 *                 columns, the maximum of the generated values is set to this
 *                 value. Default is 99999. For point, shape, and track
 *                 columns, max for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 180.0 and 90.0.
 *                 For string columns, the maximum length of the randomly
 *                 generated strings is set to this value (default is 200). If
 *                 both minimum and maximum are provided, *max* must be greater
 *                 than or equal to *min*. Value needs to be within [0, 200].
 *                 If the *max* is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_interval: If
 *                 specified, generate values for all columns evenly spaced
 *                 with the given interval value. If a max value is specified
 *                 for a given column the data is randomly generated between
 *                 min and max and decimated down to the interval. If no max is
 *                 provided the data is linerally generated starting at the
 *                 minimum value (instead of generating random data). For
 *                 non-decimated string-type columns the interval value is
 *                 ignored. Instead the values are generated following the
 *                 pattern: 'attrname_creationIndex#', i.e. the column name
 *                 suffixed with an underscore and a running counter (starting
 *                 at 0). For string types with limited size (eg char4) the
 *                 prefix is dropped. No nulls will be generated for nullable
 *                 columns.
 *                         <li> gpudb::insert_records_random_null_percentage:
 *                 If specified, then generate the given percentage of the
 *                 count as nulls for all nullable columns.  This option will
 *                 be ignored for non-nullable columns.  The value must be
 *                 within the range [0, 1.0].  The default value is 5% (0.05).
 *                         <li> gpudb::insert_records_random_cardinality: If
 *                 specified, limit the randomly generated values to a fixed
 *                 set. Not allowed on a column with interval specified, and is
 *                 not applicable to WKT or Track-specific columns. The value
 *                 must be greater than 0. This option is disabled by default.
 *                 </ul>
 *                         <li> gpudb::insert_records_random_attr_name: Use the
 *                 desired column name in place of @a attr_name, and set the
 *                 following parameters for the column specified. This
 *                 overrides any parameter set by @a all.
 *                 <ul>
 *                         <li> gpudb::insert_records_random_min: For numerical
 *                 columns, the minimum of the generated values is set to this
 *                 value.  Default is -99999.  For point, shape, and track
 *                 columns, min for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 -180.0 and -90.0. For the 'TIMESTAMP' column, the default
 *                 minimum corresponds to Jan 1, 2010.
 *                 For string columns, the minimum length of the randomly
 *                 generated strings is set to this value (default is 0). If
 *                 both minimum and maximum are provided, minimum must be less
 *                 than or equal to max. Value needs to be within [0, 200].
 *                 If the min is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_max: For numerical
 *                 columns, the maximum of the generated values is set to this
 *                 value. Default is 99999. For point, shape, and track
 *                 columns, max for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 180.0 and 90.0.
 *                 For string columns, the maximum length of the randomly
 *                 generated strings is set to this value (default is 200). If
 *                 both minimum and maximum are provided, *max* must be greater
 *                 than or equal to *min*. Value needs to be within [0, 200].
 *                 If the *max* is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_interval: If
 *                 specified, generate values for all columns evenly spaced
 *                 with the given interval value. If a max value is specified
 *                 for a given column the data is randomly generated between
 *                 min and max and decimated down to the interval. If no max is
 *                 provided the data is linerally generated starting at the
 *                 minimum value (instead of generating random data). For
 *                 non-decimated string-type columns the interval value is
 *                 ignored. Instead the values are generated following the
 *                 pattern: 'attrname_creationIndex#', i.e. the column name
 *                 suffixed with an underscore and a running counter (starting
 *                 at 0). For string types with limited size (eg char4) the
 *                 prefix is dropped. No nulls will be generated for nullable
 *                 columns.
 *                         <li> gpudb::insert_records_random_null_percentage:
 *                 If specified and if this column is nullable, then generate
 *                 the given percentage of the count as nulls.  This option
 *                 will result in an error if the column is not nullable.  The
 *                 value must be within the range [0, 1.0].  The default value
 *                 is 5% (0.05).
 *                         <li> gpudb::insert_records_random_cardinality: If
 *                 specified, limit the randomly generated values to a fixed
 *                 set. Not allowed on a column with interval specified, and is
 *                 not applicable to WKT or Track-specific columns. The value
 *                 must be greater than 0. This option is disabled by default.
 *                 </ul>
 *                         <li> gpudb::insert_records_random_track_length: This
 *                 key-map pair is only valid for track data sets (an error is
 *                 thrown otherwise).  No nulls would be generated for nullable
 *                 columns.
 *                 <ul>
 *                         <li> gpudb::insert_records_random_min: Minimum
 *                 possible length for generated series; default is 100 records
 *                 per series. Must be an integral value within the range [1,
 *                 500]. If both min and max are specified, min must be less
 *                 than or equal to max.
 *                         <li> gpudb::insert_records_random_max: Maximum
 *                 possible length for generated series; default is 500 records
 *                 per series. Must be an integral value within the range [1,
 *                 500]. If both min and max are specified, max must be greater
 *                 than or equal to min.
 *                 </ul>
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsRandomResponse insertRecordsRandom( const std::string& tableName,
                                                 const int64_t count,
                                                 const std::map<std::string, std::map<std::string, double> >& options ) const;

/**
 * Generates a specified number of random records and adds them to the given
 * table.
 * There is an optional parameter that allows the user to customize the ranges
 * of
 * the column values. It also allows the user to specify linear profiles for
 * some
 * or all columns in which case linear values are generated rather than random
 * ones. Only individual tables are supported for this operation.
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all random records are fully available.
 * 
 * @param tableName  Table to which random records will be added, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table, not a view.
 * @param count  Number of records to generate.
 * @param options  Optional parameter to pass in specifications for the
 *                 randomness of the values.  This map is different from the
 *                 *options* parameter of most other endpoints in that it is a
 *                 map of string to map of string to doubles, while most others
 *                 are maps of string to string.  In this map, the top level
 *                 keys represent which column's parameters are being
 *                 specified, while the internal keys represents which
 *                 parameter is being specified.  These parameters take on
 *                 different meanings depending on the type of the column.
 *                 Below follows a more detailed description of the map:
 *                 <ul>
 *                         <li> gpudb::insert_records_random_seed: If provided,
 *                 the internal random number generator will be initialized
 *                 with the given value.  The minimum is 0.  This allows for
 *                 the same set of random numbers to be generated across
 *                 invocation of this endpoint in case the user wants to repeat
 *                 the test.  Since @a options, is a map of maps, we need an
 *                 internal map to provide the seed value.  For example, to
 *                 pass 100 as the seed value through this parameter, you need
 *                 something equivalent to: 'options' = {'seed': { 'value': 100
 *                 } }
 *                 <ul>
 *                         <li> gpudb::insert_records_random_value: The seed
 *                 value to use
 *                 </ul>
 *                         <li> gpudb::insert_records_random_all: This key
 *                 indicates that the specifications relayed in the internal
 *                 map are to be applied to all columns of the records.
 *                 <ul>
 *                         <li> gpudb::insert_records_random_min: For numerical
 *                 columns, the minimum of the generated values is set to this
 *                 value.  Default is -99999.  For point, shape, and track
 *                 columns, min for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 -180.0 and -90.0. For the 'TIMESTAMP' column, the default
 *                 minimum corresponds to Jan 1, 2010.
 *                 For string columns, the minimum length of the randomly
 *                 generated strings is set to this value (default is 0). If
 *                 both minimum and maximum are provided, minimum must be less
 *                 than or equal to max. Value needs to be within [0, 200].
 *                 If the min is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_max: For numerical
 *                 columns, the maximum of the generated values is set to this
 *                 value. Default is 99999. For point, shape, and track
 *                 columns, max for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 180.0 and 90.0.
 *                 For string columns, the maximum length of the randomly
 *                 generated strings is set to this value (default is 200). If
 *                 both minimum and maximum are provided, *max* must be greater
 *                 than or equal to *min*. Value needs to be within [0, 200].
 *                 If the *max* is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_interval: If
 *                 specified, generate values for all columns evenly spaced
 *                 with the given interval value. If a max value is specified
 *                 for a given column the data is randomly generated between
 *                 min and max and decimated down to the interval. If no max is
 *                 provided the data is linerally generated starting at the
 *                 minimum value (instead of generating random data). For
 *                 non-decimated string-type columns the interval value is
 *                 ignored. Instead the values are generated following the
 *                 pattern: 'attrname_creationIndex#', i.e. the column name
 *                 suffixed with an underscore and a running counter (starting
 *                 at 0). For string types with limited size (eg char4) the
 *                 prefix is dropped. No nulls will be generated for nullable
 *                 columns.
 *                         <li> gpudb::insert_records_random_null_percentage:
 *                 If specified, then generate the given percentage of the
 *                 count as nulls for all nullable columns.  This option will
 *                 be ignored for non-nullable columns.  The value must be
 *                 within the range [0, 1.0].  The default value is 5% (0.05).
 *                         <li> gpudb::insert_records_random_cardinality: If
 *                 specified, limit the randomly generated values to a fixed
 *                 set. Not allowed on a column with interval specified, and is
 *                 not applicable to WKT or Track-specific columns. The value
 *                 must be greater than 0. This option is disabled by default.
 *                 </ul>
 *                         <li> gpudb::insert_records_random_attr_name: Use the
 *                 desired column name in place of @a attr_name, and set the
 *                 following parameters for the column specified. This
 *                 overrides any parameter set by @a all.
 *                 <ul>
 *                         <li> gpudb::insert_records_random_min: For numerical
 *                 columns, the minimum of the generated values is set to this
 *                 value.  Default is -99999.  For point, shape, and track
 *                 columns, min for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 -180.0 and -90.0. For the 'TIMESTAMP' column, the default
 *                 minimum corresponds to Jan 1, 2010.
 *                 For string columns, the minimum length of the randomly
 *                 generated strings is set to this value (default is 0). If
 *                 both minimum and maximum are provided, minimum must be less
 *                 than or equal to max. Value needs to be within [0, 200].
 *                 If the min is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_max: For numerical
 *                 columns, the maximum of the generated values is set to this
 *                 value. Default is 99999. For point, shape, and track
 *                 columns, max for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 180.0 and 90.0.
 *                 For string columns, the maximum length of the randomly
 *                 generated strings is set to this value (default is 200). If
 *                 both minimum and maximum are provided, *max* must be greater
 *                 than or equal to *min*. Value needs to be within [0, 200].
 *                 If the *max* is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_interval: If
 *                 specified, generate values for all columns evenly spaced
 *                 with the given interval value. If a max value is specified
 *                 for a given column the data is randomly generated between
 *                 min and max and decimated down to the interval. If no max is
 *                 provided the data is linerally generated starting at the
 *                 minimum value (instead of generating random data). For
 *                 non-decimated string-type columns the interval value is
 *                 ignored. Instead the values are generated following the
 *                 pattern: 'attrname_creationIndex#', i.e. the column name
 *                 suffixed with an underscore and a running counter (starting
 *                 at 0). For string types with limited size (eg char4) the
 *                 prefix is dropped. No nulls will be generated for nullable
 *                 columns.
 *                         <li> gpudb::insert_records_random_null_percentage:
 *                 If specified and if this column is nullable, then generate
 *                 the given percentage of the count as nulls.  This option
 *                 will result in an error if the column is not nullable.  The
 *                 value must be within the range [0, 1.0].  The default value
 *                 is 5% (0.05).
 *                         <li> gpudb::insert_records_random_cardinality: If
 *                 specified, limit the randomly generated values to a fixed
 *                 set. Not allowed on a column with interval specified, and is
 *                 not applicable to WKT or Track-specific columns. The value
 *                 must be greater than 0. This option is disabled by default.
 *                 </ul>
 *                         <li> gpudb::insert_records_random_track_length: This
 *                 key-map pair is only valid for track data sets (an error is
 *                 thrown otherwise).  No nulls would be generated for nullable
 *                 columns.
 *                 <ul>
 *                         <li> gpudb::insert_records_random_min: Minimum
 *                 possible length for generated series; default is 100 records
 *                 per series. Must be an integral value within the range [1,
 *                 500]. If both min and max are specified, min must be less
 *                 than or equal to max.
 *                         <li> gpudb::insert_records_random_max: Maximum
 *                 possible length for generated series; default is 500 records
 *                 per series. Must be an integral value within the range [1,
 *                 500]. If both min and max are specified, max must be greater
 *                 than or equal to min.
 *                 </ul>
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsRandomResponse& insertRecordsRandom( const std::string& tableName,
                                                  const int64_t count,
                                                  const std::map<std::string, std::map<std::string, double> >& options,
                                                  InsertRecordsRandomResponse& response_ ) const;

/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../../../api/rest/wms_rest/" target="_top">WMS</a>) if the
 * 'dosymbology' parameter is 'true' then the value of the 'SYMBOLCODE' column
 * is used to pick the symbol displayed for each point.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertSymbolResponse insertSymbol( const InsertSymbolRequest& request_ ) const;

/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../../../api/rest/wms_rest/" target="_top">WMS</a>) if the
 * 'dosymbology' parameter is 'true' then the value of the 'SYMBOLCODE' column
 * is used to pick the symbol displayed for each point.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertSymbolResponse& insertSymbol( const InsertSymbolRequest& request_,
                                    InsertSymbolResponse& response_ ) const;

/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../../../api/rest/wms_rest/" target="_top">WMS</a>) if the
 * 'dosymbology' parameter is 'true' then the value of the 'SYMBOLCODE' column
 * is used to pick the symbol displayed for each point.
 * 
 * @param symbolId  The id of the symbol being added. This is the same id that
 *                  should be in the 'SYMBOLCODE' column for objects using this
 *                  symbol
 * @param symbolFormat  Specifies the symbol format. Must be either 'svg' or
 *                      'svg_path'.
 *                      <ul>
 *                              <li> gpudb::insert_symbol_svg
 *                              <li> gpudb::insert_symbol_svg_path
 *                      </ul>
 * @param symbolData  The actual symbol data. If @a symbolFormat is 'svg' then
 *                    this should be the raw bytes representing an svg file. If
 *                    @a symbolFormat is svg path then this should be an svg
 *                    path string, for example:
 *                    'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z'
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::insert_symbol_color: If @a symbolFormat
 *                 is 'svg' this is ignored. If @a symbolFormat is 'svg_path'
 *                 then this option specifies the color (in RRGGBB hex format)
 *                 of the path. For example, to have the path rendered in red,
 *                 used 'FF0000'. If 'color' is not provided then '00FF00'
 *                 (i.e. green) is used by default.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertSymbolResponse insertSymbol( const std::string& symbolId,
                                   const std::string& symbolFormat,
                                   const std::vector<uint8_t>& symbolData,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../../../api/rest/wms_rest/" target="_top">WMS</a>) if the
 * 'dosymbology' parameter is 'true' then the value of the 'SYMBOLCODE' column
 * is used to pick the symbol displayed for each point.
 * 
 * @param symbolId  The id of the symbol being added. This is the same id that
 *                  should be in the 'SYMBOLCODE' column for objects using this
 *                  symbol
 * @param symbolFormat  Specifies the symbol format. Must be either 'svg' or
 *                      'svg_path'.
 *                      <ul>
 *                              <li> gpudb::insert_symbol_svg
 *                              <li> gpudb::insert_symbol_svg_path
 *                      </ul>
 * @param symbolData  The actual symbol data. If @a symbolFormat is 'svg' then
 *                    this should be the raw bytes representing an svg file. If
 *                    @a symbolFormat is svg path then this should be an svg
 *                    path string, for example:
 *                    'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z'
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::insert_symbol_color: If @a symbolFormat
 *                 is 'svg' this is ignored. If @a symbolFormat is 'svg_path'
 *                 then this option specifies the color (in RRGGBB hex format)
 *                 of the path. For example, to have the path rendered in red,
 *                 used 'FF0000'. If 'color' is not provided then '00FF00'
 *                 (i.e. green) is used by default.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertSymbolResponse& insertSymbol( const std::string& symbolId,
                                    const std::string& symbolFormat,
                                    const std::vector<uint8_t>& symbolData,
                                    const std::map<std::string, std::string>& options,
                                    InsertSymbolResponse& response_ ) const;

/**
 * Kills a running proc instance.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

KillProcResponse killProc( const KillProcRequest& request_ ) const;

/**
 * Kills a running proc instance.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

KillProcResponse& killProc( const KillProcRequest& request_,
                            KillProcResponse& response_ ) const;

/**
 * Kills a running proc instance.
 * 
 * @param runId  The run ID of a running proc instance. If a proc with a
 *               matching run ID is not found or the proc instance has already
 *               completed, no procs will be killed. If not specified, all
 *               running proc instances will be killed.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::kill_proc_run_tag: If @a runId is
 *                 specified, kill the proc instance that has a matching run ID
 *                 and a matching run tag that was provided to /execute/proc.
 *                 If @a runId is not specified, kill the proc instance(s)
 *                 where a matching run tag was provided to /execute/proc.  The
 *                 default value is ''.
 *                         <li> gpudb::kill_proc_clear_execute_at_startup: If
 *                 @a true, kill and remove the instance of the proc matching
 *                 the auto-start run ID that was created to run when the
 *                 database is started. The auto-start run ID was returned from
 *                 /execute/proc and can be retrieved using /show/proc.
 *                 <ul>
 *                         <li> gpudb::kill_proc_true
 *                         <li> gpudb::kill_proc_false
 *                 </ul>
 *                 The default value is gpudb::kill_proc_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

KillProcResponse killProc( const std::string& runId,
                           const std::map<std::string, std::string>& options ) const;

/**
 * Kills a running proc instance.
 * 
 * @param runId  The run ID of a running proc instance. If a proc with a
 *               matching run ID is not found or the proc instance has already
 *               completed, no procs will be killed. If not specified, all
 *               running proc instances will be killed.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::kill_proc_run_tag: If @a runId is
 *                 specified, kill the proc instance that has a matching run ID
 *                 and a matching run tag that was provided to /execute/proc.
 *                 If @a runId is not specified, kill the proc instance(s)
 *                 where a matching run tag was provided to /execute/proc.  The
 *                 default value is ''.
 *                         <li> gpudb::kill_proc_clear_execute_at_startup: If
 *                 @a true, kill and remove the instance of the proc matching
 *                 the auto-start run ID that was created to run when the
 *                 database is started. The auto-start run ID was returned from
 *                 /execute/proc and can be retrieved using /show/proc.
 *                 <ul>
 *                         <li> gpudb::kill_proc_true
 *                         <li> gpudb::kill_proc_false
 *                 </ul>
 *                 The default value is gpudb::kill_proc_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

KillProcResponse& killProc( const std::string& runId,
                            const std::map<std::string, std::string>& options,
                            KillProcResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ListGraphResponse listGraph( const ListGraphRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ListGraphResponse& listGraph( const ListGraphRequest& request_,
                              ListGraphResponse& response_ ) const;

/**
 * @private
 * 
 * @param graphName
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ListGraphResponse listGraph( const std::string& graphName,
                             const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param graphName
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ListGraphResponse& listGraph( const std::string& graphName,
                              const std::map<std::string, std::string>& options,
                              ListGraphResponse& response_ ) const;

/**
 * Manages global access to a table's data.  By default a table has a @a
 * lockType of @a read_write, indicating all operations are permitted.  A user
 * may request a @a read_only or a @a write_only lock, after which only read or
 * write operations, respectively, are permitted on the table until the lock is
 * removed.  When @a lockType is @a no_access then no operations are permitted
 * on the table.  The lock status can be queried by setting @a lockType to @a
 * status.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

LockTableResponse lockTable( const LockTableRequest& request_ ) const;

/**
 * Manages global access to a table's data.  By default a table has a @a
 * lockType of @a read_write, indicating all operations are permitted.  A user
 * may request a @a read_only or a @a write_only lock, after which only read or
 * write operations, respectively, are permitted on the table until the lock is
 * removed.  When @a lockType is @a no_access then no operations are permitted
 * on the table.  The lock status can be queried by setting @a lockType to @a
 * status.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

LockTableResponse& lockTable( const LockTableRequest& request_,
                              LockTableResponse& response_ ) const;

/**
 * Manages global access to a table's data.  By default a table has a @a
 * lockType of @a read_write, indicating all operations are permitted.  A user
 * may request a @a read_only or a @a write_only lock, after which only read or
 * write operations, respectively, are permitted on the table until the lock is
 * removed.  When @a lockType is @a no_access then no operations are permitted
 * on the table.  The lock status can be queried by setting @a lockType to @a
 * status.
 * 
 * @param tableName  Name of the table to be locked, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  It must be a
 *                   currently existing table or view.
 * @param lockType  The type of lock being applied to the table. Setting it to
 *                  @a status will return the current lock status of the table
 *                  without changing it.
 *                  <ul>
 *                          <li> gpudb::lock_table_status: Show locked status
 *                          <li> gpudb::lock_table_no_access: Allow no
 *                  read/write operations
 *                          <li> gpudb::lock_table_read_only: Allow only read
 *                  operations
 *                          <li> gpudb::lock_table_write_only: Allow only write
 *                  operations
 *                          <li> gpudb::lock_table_read_write: Allow all
 *                  read/write operations
 *                  </ul>
 *                  The default value is gpudb::lock_table_status.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

LockTableResponse lockTable( const std::string& tableName,
                             const std::string& lockType,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Manages global access to a table's data.  By default a table has a @a
 * lockType of @a read_write, indicating all operations are permitted.  A user
 * may request a @a read_only or a @a write_only lock, after which only read or
 * write operations, respectively, are permitted on the table until the lock is
 * removed.  When @a lockType is @a no_access then no operations are permitted
 * on the table.  The lock status can be queried by setting @a lockType to @a
 * status.
 * 
 * @param tableName  Name of the table to be locked, in
 *                   [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  It must be a
 *                   currently existing table or view.
 * @param lockType  The type of lock being applied to the table. Setting it to
 *                  @a status will return the current lock status of the table
 *                  without changing it.
 *                  <ul>
 *                          <li> gpudb::lock_table_status: Show locked status
 *                          <li> gpudb::lock_table_no_access: Allow no
 *                  read/write operations
 *                          <li> gpudb::lock_table_read_only: Allow only read
 *                  operations
 *                          <li> gpudb::lock_table_write_only: Allow only write
 *                  operations
 *                          <li> gpudb::lock_table_read_write: Allow all
 *                  read/write operations
 *                  </ul>
 *                  The default value is gpudb::lock_table_status.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

LockTableResponse& lockTable( const std::string& tableName,
                              const std::string& lockType,
                              const std::map<std::string, std::string>& options,
                              LockTableResponse& response_ ) const;

/**
 * Matches a directed route implied by a given set of
 * latitude/longitude points to an existing underlying road network graph using
 * a
 * given solution type.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph---match/" target="_top">/match/graph
 * examples</a>
 * before using this endpoint.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

MatchGraphResponse matchGraph( const MatchGraphRequest& request_ ) const;

/**
 * Matches a directed route implied by a given set of
 * latitude/longitude points to an existing underlying road network graph using
 * a
 * given solution type.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph---match/" target="_top">/match/graph
 * examples</a>
 * before using this endpoint.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

MatchGraphResponse& matchGraph( const MatchGraphRequest& request_,
                                MatchGraphResponse& response_ ) const;

/**
 * Matches a directed route implied by a given set of
 * latitude/longitude points to an existing underlying road network graph using
 * a
 * given solution type.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph---match/" target="_top">/match/graph
 * examples</a>
 * before using this endpoint.
 * 
 * @param graphName  Name of the underlying geospatial graph resource to match
 *                   to using @a samplePoints.
 * @param samplePoints  Sample points used to match to an underlying geospatial
 *                      graph. Sample points must be specified using
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#match-identifiers"
 *                      target="_top">identifiers</a>;
 *                      identifiers are grouped as
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#match-combinations"
 *                      target="_top">combinations</a>.
 *                      Identifiers can be used with: existing column names,
 *                      e.g.,
 *                      'table.column AS SAMPLE_X'; expressions, e.g.,
 *                      'ST_MAKEPOINT(table.x, table.y) AS SAMPLE_WKTPOINT'; or
 *                      constant values, e.g.,
 *                      '{1, 2, 10} AS SAMPLE_TRIPID'.
 * @param solveMethod  The type of solver to use for graph matching.
 *                     <ul>
 *                             <li> gpudb::match_graph_markov_chain: Matches @a
 *                     samplePoints to the graph using the Hidden Markov Model
 *                     (HMM)-based method, which conducts a range-tree
 *                     closest-edge search to find the best combinations of
 *                     possible road segments (@a num_segments) for each sample
 *                     point to create the best route. The route is secured one
 *                     point at a time while looking ahead @a chain_width
 *                     number of points, so the prediction is corrected after
 *                     each point. This solution type is the most accurate but
 *                     also the most computationally intensive. Related
 *                     options: @a num_segments and @a chain_width.
 *                             <li> gpudb::match_graph_match_od_pairs: Matches
 *                     @a samplePoints to find the most probable path between
 *                     origin and destination pairs with cost constraints.
 *                             <li> gpudb::match_graph_match_supply_demand:
 *                     Matches @a samplePoints to optimize scheduling multiple
 *                     supplies (trucks) with varying sizes to varying demand
 *                     sites with varying capacities per depot. Related
 *                     options: @a partial_loading and @a max_combinations.
 *                             <li> gpudb::match_graph_match_batch_solves:
 *                     Matches @a samplePoints source and destination pairs for
 *                     the shortest path solves in batch mode.
 *                             <li> gpudb::match_graph_match_loops: Matches
 *                     closed loops (Eulerian paths) originating and ending at
 *                     each graph node within min and max hops (levels).
 *                             <li> gpudb::match_graph_match_charging_stations:
 *                     Matches an optimal path across a number of ev-charging
 *                     stations between source and target locations.
 *                             <li> gpudb::match_graph_match_similarity:
 *                     Matches the intersection set(s) by computing the Jaccard
 *                     similarity score between node pairs.
 *                             <li> gpudb::match_graph_match_pickup_dropoff:
 *                     Matches the pickups and dropoffs by optimizing the total
 *                     trip costs
 *                             <li> gpudb::match_graph_match_clusters: Matches
 *                     the graph nodes with a cluster index using Louvain
 *                     clustering algorithm
 *                             <li> gpudb::match_graph_match_pattern: Matches a
 *                     pattern in the graph
 *                     </ul>
 *                     The default value is gpudb::match_graph_markov_chain.
 * @param solutionTable  The name of the table used to store the results, in
 *                       [schema_name.]table_name format, using standard <a
 *                       href="../../../concepts/tables/#table-name-resolution"
 *                       target="_top">name resolution rules</a> and meeting <a
 *                       href="../../../concepts/tables/#table-naming-criteria"
 *                       target="_top">table naming criteria</a>.  This table
 *                       contains a <a
 *                       href="../../../location_intelligence/geo_objects/#geospatial-tracks"
 *                       target="_top">track</a> of geospatial points for the
 *                       matched portion of the graph, a track ID, and a score
 *                       value. Also outputs a details table containing a trip
 *                       ID (that matches the track ID), the latitude/longitude
 *                       pair, the timestamp the point was recorded at, and an
 *                       edge ID corresponding to the matched road segment.
 *                       Must not be an existing table of the same name.
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::match_graph_gps_noise: GPS noise value
 *                 (in meters) to remove redundant sample points. Use -1 to
 *                 disable noise reduction. The default value accounts for 95%
 *                 of point variation (+ or -5 meters).  The default value is
 *                 '5.0'.
 *                         <li> gpudb::match_graph_num_segments: Maximum number
 *                 of potentially matching road segments for each sample point.
 *                 For the @a markov_chain solver, the default is 3.  The
 *                 default value is '3'.
 *                         <li> gpudb::match_graph_search_radius: Maximum
 *                 search radius used when snapping sample points onto
 *                 potentially matching surrounding segments. The default value
 *                 corresponds to approximately 100 meters.  The default value
 *                 is '0.001'.
 *                         <li> gpudb::match_graph_chain_width: For the @a
 *                 markov_chain solver only. Length of the sample points
 *                 lookahead window within the Markov kernel; the larger the
 *                 number, the more accurate the solution.  The default value
 *                 is '9'.
 *                         <li> gpudb::match_graph_source: Optional WKT
 *                 starting point from @a samplePoints for the solver. The
 *                 default behavior for the endpoint is to use time to
 *                 determine the starting point.  The default value is 'POINT
 *                 NULL'.
 *                         <li> gpudb::match_graph_destination: Optional WKT
 *                 ending point from @a samplePoints for the solver. The
 *                 default behavior for the endpoint is to use time to
 *                 determine the destination point.  The default value is
 *                 'POINT NULL'.
 *                         <li> gpudb::match_graph_partial_loading: For the @a
 *                 match_supply_demand solver only. When false (non-default),
 *                 trucks do not off-load at the demand (store) side if the
 *                 remainder is less than the store's need
 *                 <ul>
 *                         <li> gpudb::match_graph_true: Partial off-loading at
 *                 multiple store (demand) locations
 *                         <li> gpudb::match_graph_false: No partial
 *                 off-loading allowed if supply is less than the store's
 *                 demand.
 *                 </ul>
 *                 The default value is gpudb::match_graph_true.
 *                         <li> gpudb::match_graph_max_combinations: For the @a
 *                 match_supply_demand solver only. This is the cutoff for the
 *                 number of generated combinations for sequencing the demand
 *                 locations - can increase this up to 2M.  The default value
 *                 is '10000'.
 *                         <li> gpudb::match_graph_max_supply_combinations: For
 *                 the @a match_supply_demand solver only. This is the cutoff
 *                 for the number of generated combinations for sequencing the
 *                 supply locations if/when 'permute_supplies' is true.  The
 *                 default value is '10000'.
 *                         <li> gpudb::match_graph_left_turn_penalty: This will
 *                 add an additonal weight over the edges labelled as 'left
 *                 turn' if the 'add_turn' option parameter of the
 *                 /create/graph was invoked at graph creation.  The default
 *                 value is '0.0'.
 *                         <li> gpudb::match_graph_right_turn_penalty: This
 *                 will add an additonal weight over the edges labelled as'
 *                 right turn' if the 'add_turn' option parameter of the
 *                 /create/graph was invoked at graph creation.  The default
 *                 value is '0.0'.
 *                         <li> gpudb::match_graph_intersection_penalty: This
 *                 will add an additonal weight over the edges labelled as
 *                 'intersection' if the 'add_turn' option parameter of the
 *                 /create/graph was invoked at graph creation.  The default
 *                 value is '0.0'.
 *                         <li> gpudb::match_graph_sharp_turn_penalty: This
 *                 will add an additonal weight over the edges labelled as
 *                 'sharp turn' or 'u-turn' if the 'add_turn' option parameter
 *                 of the /create/graph was invoked at graph creation.  The
 *                 default value is '0.0'.
 *                         <li> gpudb::match_graph_aggregated_output: For the
 *                 @a match_supply_demand solver only. When it is true
 *                 (default), each record in the output table shows a
 *                 particular truck's scheduled cumulative round trip path
 *                 (MULTILINESTRING) and the corresponding aggregated cost.
 *                 Otherwise, each record shows a single scheduled truck route
 *                 (LINESTRING) towards a particular demand location (store id)
 *                 with its corresponding cost.  The default value is 'true'.
 *                         <li> gpudb::match_graph_output_tracks: For the @a
 *                 match_supply_demand solver only. When it is true
 *                 (non-default), the output will be in tracks format for all
 *                 the round trips of each truck in which the timestamps are
 *                 populated directly from the edge weights starting from their
 *                 originating depots.  The default value is 'false'.
 *                         <li> gpudb::match_graph_max_trip_cost: For the @a
 *                 match_supply_demand and @a match_pickup_dropoff solvers
 *                 only. If this constraint is greater than zero (default) then
 *                 the trucks/rides will skip travelling from one demand/pick
 *                 location to another if the cost between them is greater than
 *                 this number (distance or time). Zero (default) value means
 *                 no check is performed.  The default value is '0.0'.
 *                         <li> gpudb::match_graph_filter_folding_paths: For
 *                 the @a markov_chain solver only. When true (non-default),
 *                 the paths per sequence combination is checked for folding
 *                 over patterns and can significantly increase the execution
 *                 time depending on the chain width and the number of gps
 *                 samples.
 *                 <ul>
 *                         <li> gpudb::match_graph_true: Filter out the folded
 *                 paths.
 *                         <li> gpudb::match_graph_false: Do not filter out the
 *                 folded paths
 *                 </ul>
 *                 The default value is gpudb::match_graph_false.
 *                         <li> gpudb::match_graph_unit_unloading_cost: For the
 *                 @a match_supply_demand solver only. The unit cost per load
 *                 amount to be delivered. If this value is greater than zero
 *                 (default) then the additional cost of this unit load
 *                 multiplied by the total dropped load will be added over to
 *                 the trip cost to the demand location.  The default value is
 *                 '0.0'.
 *                         <li> gpudb::match_graph_max_num_threads: For the @a
 *                 markov_chain solver only. If specified (greater than zero),
 *                 the maximum number of threads will not be greater than the
 *                 specified value. It can be lower due to the memory and the
 *                 number cores available. Default value of zero allows the
 *                 algorithm to set the maximal number of threads within these
 *                 constraints.  The default value is '0'.
 *                         <li> gpudb::match_graph_service_limit: For the @a
 *                 match_supply_demand solver only. If specified (greater than
 *                 zero), any supply actor's total service cost (distance or
 *                 time) will be limited by the specified value including
 *                 multiple rounds (if set).  The default value is '0.0'.
 *                         <li> gpudb::match_graph_enable_reuse: For the @a
 *                 match_supply_demand solver only. If specified (true), all
 *                 supply actors can be scheduled for second rounds from their
 *                 originating depots.
 *                 <ul>
 *                         <li> gpudb::match_graph_true: Allows reusing supply
 *                 actors (trucks, e.g.) for scheduling again.
 *                         <li> gpudb::match_graph_false: Supply actors are
 *                 scheduled only once from their depots.
 *                 </ul>
 *                 The default value is gpudb::match_graph_false.
 *                         <li> gpudb::match_graph_max_stops: For the @a
 *                 match_supply_demand solver only. If specified (greater than
 *                 zero), a supply actor (truck) can at most have this many
 *                 stops (demand locations) in one round trip. Otherwise, it is
 *                 unlimited. If 'enable_truck_reuse' is on, this condition
 *                 will be applied separately at each round trip use of the
 *                 same truck.  The default value is '0'.
 *                         <li> gpudb::match_graph_service_radius: For the @a
 *                 match_supply_demand and @a match_pickup_dropoff solvers
 *                 only. If specified (greater than zero), it filters the
 *                 demands/picks outside this radius centered around the supply
 *                 actor/ride's originating location (distance or time).  The
 *                 default value is '0.0'.
 *                         <li> gpudb::match_graph_permute_supplies: For the @a
 *                 match_supply_demand solver only. If specified (true), supply
 *                 side actors are permuted for the demand combinations during
 *                 msdo optimization - note that this option increases
 *                 optimization time significantly - use of 'max_combinations'
 *                 option is recommended to prevent prohibitively long runs
 *                 <ul>
 *                         <li> gpudb::match_graph_true: Generates sequences
 *                 over supply side permutations if total supply is less than
 *                 twice the total demand
 *                         <li> gpudb::match_graph_false: Permutations are not
 *                 performed, rather a specific order of supplies based on
 *                 capacity is computed
 *                 </ul>
 *                 The default value is gpudb::match_graph_true.
 *                         <li> gpudb::match_graph_batch_tsm_mode: For the @a
 *                 match_supply_demand solver only. When enabled, it sets the
 *                 number of visits on each demand location by a single
 *                 salesman at each trip is considered to be (one) 1, otherwise
 *                 there is no bound.
 *                 <ul>
 *                         <li> gpudb::match_graph_true: Sets only one visit
 *                 per demand location by a salesman (tsm mode)
 *                         <li> gpudb::match_graph_false: No preset limit
 *                 (usual msdo mode)
 *                 </ul>
 *                 The default value is gpudb::match_graph_false.
 *                         <li> gpudb::match_graph_round_trip: For the @a
 *                 match_supply_demand solver only. When enabled, the supply
 *                 will have to return back to the origination location.
 *                 <ul>
 *                         <li> gpudb::match_graph_true: The optimization is
 *                 done for trips in round trip manner always returning to
 *                 originating locations
 *                         <li> gpudb::match_graph_false: Supplies do not have
 *                 to come back to their originating locations in their routes.
 *                 The routes are considered finished at the final dropoff.
 *                 </ul>
 *                 The default value is gpudb::match_graph_true.
 *                         <li> gpudb::match_graph_num_cycles: For the @a
 *                 match_clusters solver only. Terminates the cluster exchange
 *                 iterations across 2-step-cycles (outer loop) when quality
 *                 does not improve during iterations.  The default value is
 *                 '10'.
 *                         <li> gpudb::match_graph_num_loops_per_cycle: For the
 *                 @a match_clusters solver only. Terminates the cluster
 *                 exchanges within the first step iterations of a cycle (inner
 *                 loop) unless convergence is reached.  The default value is
 *                 '10'.
 *                         <li> gpudb::match_graph_num_output_clusters: For the
 *                 @a match_clusters solver only.  Limits the output to the top
 *                 'num_output_clusters' clusters based on density. Default
 *                 value of zero outputs all clusters.  The default value is
 *                 '0'.
 *                         <li> gpudb::match_graph_max_num_clusters: For the @a
 *                 match_clusters solver only. If set (value greater than
 *                 zero), it terminates when the number of clusters goes below
 *                 than this number.  The default value is '0'.
 *                         <li> gpudb::match_graph_cluster_quality_metric: For
 *                 the @a match_clusters solver only. The quality metric for
 *                 Louvain modularity optimization solver.
 *                 <ul>
 *                         <li> gpudb::match_graph_girvan: Uses the Newman
 *                 Girvan quality metric for cluster solver
 *                         <li> gpudb::match_graph_spectral: Applies recursive
 *                 spectral bisection (RSB) partitioning solver
 *                 </ul>
 *                 The default value is gpudb::match_graph_girvan.
 *                         <li> gpudb::match_graph_restricted_type: For the @a
 *                 match_supply_demand solver only. Optimization is performed
 *                 by restricting routes labeled by 'MSDO_ODDEVEN_RESTRICTED'
 *                 only for this supply actor (truck) type
 *                 <ul>
 *                         <li> gpudb::match_graph_odd: Applies odd/even rule
 *                 restrictions to odd tagged vehicles.
 *                         <li> gpudb::match_graph_even: Applies odd/even rule
 *                 restrictions to even tagged vehicles.
 *                         <li> gpudb::match_graph_none: Does not apply
 *                 odd/even rule restrictions to any vehicles.
 *                 </ul>
 *                 The default value is gpudb::match_graph_none.
 *                         <li> gpudb::match_graph_server_id: Indicates which
 *                 graph server(s) to send the request to. Default is to send
 *                 to the server, amongst those containing the corresponding
 *                 graph, that has the most computational bandwidth.  The
 *                 default value is ''.
 *                         <li> gpudb::match_graph_inverse_solve: For the @a
 *                 match_batch_solves solver only. Solves source-destination
 *                 pairs using inverse shortest path solver.
 *                 <ul>
 *                         <li> gpudb::match_graph_true: Solves using inverse
 *                 shortest path solver.
 *                         <li> gpudb::match_graph_false: Solves using direct
 *                 shortest path solver.
 *                 </ul>
 *                 The default value is gpudb::match_graph_false.
 *                         <li> gpudb::match_graph_min_loop_level: For the @a
 *                 match_loops solver only. Finds closed loops around each node
 *                 deducible not less than this minimal hop (level) deep.  The
 *                 default value is '0'.
 *                         <li> gpudb::match_graph_max_loop_level: For the @a
 *                 match_loops solver only. Finds closed loops around each node
 *                 deducible not more than this maximal hop (level) deep.  The
 *                 default value is '5'.
 *                         <li> gpudb::match_graph_search_limit: For the @a
 *                 match_loops solver only. Searches within this limit of nodes
 *                 per vertex to detect loops. The value zero means there is no
 *                 limit.  The default value is '10000'.
 *                         <li> gpudb::match_graph_output_batch_size: For the
 *                 @a match_loops solver only. Uses this value as the batch
 *                 size of the number of loops in flushing(inserting) to the
 *                 output table.  The default value is '1000'.
 *                         <li> gpudb::match_graph_charging_capacity: For the
 *                 @a match_charging_stations solver only. This is the maximum
 *                 ev-charging capacity of a vehicle (distance in meters or
 *                 time in seconds depending on the unit of the graph weights).
 *                 The default value is '300000.0'.
 *                         <li> gpudb::match_graph_charging_candidates: For the
 *                 @a match_charging_stations solver only. Solver searches for
 *                 this many number of stations closest around each base
 *                 charging location found by capacity.  The default value is
 *                 '10'.
 *                         <li> gpudb::match_graph_charging_penalty: For the @a
 *                 match_charging_stations solver only. This is the penalty for
 *                 full charging.  The default value is '30000.0'.
 *                         <li> gpudb::match_graph_max_hops: For the @a
 *                 match_similarity solver only. Searches within this maximum
 *                 hops for source and target node pairs to compute the Jaccard
 *                 scores.  The default value is '3'.
 *                         <li> gpudb::match_graph_traversal_node_limit: For
 *                 the @a match_similarity solver only. Limits the traversal
 *                 depth if it reaches this many number of nodes.  The default
 *                 value is '1000'.
 *                         <li> gpudb::match_graph_paired_similarity: For the
 *                 @a match_similarity solver only. If true, it computes
 *                 Jaccard score between each pair, otherwise it will compute
 *                 Jaccard from the intersection set between the source and
 *                 target nodes
 *                 <ul>
 *                         <li> gpudb::match_graph_true
 *                         <li> gpudb::match_graph_false
 *                 </ul>
 *                 The default value is gpudb::match_graph_true.
 *                         <li> gpudb::match_graph_force_undirected: For the @a
 *                 match_pattern solver only. Pattern matching will be using
 *                 both pattern and graph as undirected if set to true.
 *                 <ul>
 *                         <li> gpudb::match_graph_true
 *                         <li> gpudb::match_graph_false
 *                 </ul>
 *                 The default value is gpudb::match_graph_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

MatchGraphResponse matchGraph( const std::string& graphName,
                               const std::vector<std::string>& samplePoints,
                               const std::string& solveMethod,
                               const std::string& solutionTable,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Matches a directed route implied by a given set of
 * latitude/longitude points to an existing underlying road network graph using
 * a
 * given solution type.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph---match/" target="_top">/match/graph
 * examples</a>
 * before using this endpoint.
 * 
 * @param graphName  Name of the underlying geospatial graph resource to match
 *                   to using @a samplePoints.
 * @param samplePoints  Sample points used to match to an underlying geospatial
 *                      graph. Sample points must be specified using
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#match-identifiers"
 *                      target="_top">identifiers</a>;
 *                      identifiers are grouped as
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#match-combinations"
 *                      target="_top">combinations</a>.
 *                      Identifiers can be used with: existing column names,
 *                      e.g.,
 *                      'table.column AS SAMPLE_X'; expressions, e.g.,
 *                      'ST_MAKEPOINT(table.x, table.y) AS SAMPLE_WKTPOINT'; or
 *                      constant values, e.g.,
 *                      '{1, 2, 10} AS SAMPLE_TRIPID'.
 * @param solveMethod  The type of solver to use for graph matching.
 *                     <ul>
 *                             <li> gpudb::match_graph_markov_chain: Matches @a
 *                     samplePoints to the graph using the Hidden Markov Model
 *                     (HMM)-based method, which conducts a range-tree
 *                     closest-edge search to find the best combinations of
 *                     possible road segments (@a num_segments) for each sample
 *                     point to create the best route. The route is secured one
 *                     point at a time while looking ahead @a chain_width
 *                     number of points, so the prediction is corrected after
 *                     each point. This solution type is the most accurate but
 *                     also the most computationally intensive. Related
 *                     options: @a num_segments and @a chain_width.
 *                             <li> gpudb::match_graph_match_od_pairs: Matches
 *                     @a samplePoints to find the most probable path between
 *                     origin and destination pairs with cost constraints.
 *                             <li> gpudb::match_graph_match_supply_demand:
 *                     Matches @a samplePoints to optimize scheduling multiple
 *                     supplies (trucks) with varying sizes to varying demand
 *                     sites with varying capacities per depot. Related
 *                     options: @a partial_loading and @a max_combinations.
 *                             <li> gpudb::match_graph_match_batch_solves:
 *                     Matches @a samplePoints source and destination pairs for
 *                     the shortest path solves in batch mode.
 *                             <li> gpudb::match_graph_match_loops: Matches
 *                     closed loops (Eulerian paths) originating and ending at
 *                     each graph node within min and max hops (levels).
 *                             <li> gpudb::match_graph_match_charging_stations:
 *                     Matches an optimal path across a number of ev-charging
 *                     stations between source and target locations.
 *                             <li> gpudb::match_graph_match_similarity:
 *                     Matches the intersection set(s) by computing the Jaccard
 *                     similarity score between node pairs.
 *                             <li> gpudb::match_graph_match_pickup_dropoff:
 *                     Matches the pickups and dropoffs by optimizing the total
 *                     trip costs
 *                             <li> gpudb::match_graph_match_clusters: Matches
 *                     the graph nodes with a cluster index using Louvain
 *                     clustering algorithm
 *                             <li> gpudb::match_graph_match_pattern: Matches a
 *                     pattern in the graph
 *                     </ul>
 *                     The default value is gpudb::match_graph_markov_chain.
 * @param solutionTable  The name of the table used to store the results, in
 *                       [schema_name.]table_name format, using standard <a
 *                       href="../../../concepts/tables/#table-name-resolution"
 *                       target="_top">name resolution rules</a> and meeting <a
 *                       href="../../../concepts/tables/#table-naming-criteria"
 *                       target="_top">table naming criteria</a>.  This table
 *                       contains a <a
 *                       href="../../../location_intelligence/geo_objects/#geospatial-tracks"
 *                       target="_top">track</a> of geospatial points for the
 *                       matched portion of the graph, a track ID, and a score
 *                       value. Also outputs a details table containing a trip
 *                       ID (that matches the track ID), the latitude/longitude
 *                       pair, the timestamp the point was recorded at, and an
 *                       edge ID corresponding to the matched road segment.
 *                       Must not be an existing table of the same name.
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::match_graph_gps_noise: GPS noise value
 *                 (in meters) to remove redundant sample points. Use -1 to
 *                 disable noise reduction. The default value accounts for 95%
 *                 of point variation (+ or -5 meters).  The default value is
 *                 '5.0'.
 *                         <li> gpudb::match_graph_num_segments: Maximum number
 *                 of potentially matching road segments for each sample point.
 *                 For the @a markov_chain solver, the default is 3.  The
 *                 default value is '3'.
 *                         <li> gpudb::match_graph_search_radius: Maximum
 *                 search radius used when snapping sample points onto
 *                 potentially matching surrounding segments. The default value
 *                 corresponds to approximately 100 meters.  The default value
 *                 is '0.001'.
 *                         <li> gpudb::match_graph_chain_width: For the @a
 *                 markov_chain solver only. Length of the sample points
 *                 lookahead window within the Markov kernel; the larger the
 *                 number, the more accurate the solution.  The default value
 *                 is '9'.
 *                         <li> gpudb::match_graph_source: Optional WKT
 *                 starting point from @a samplePoints for the solver. The
 *                 default behavior for the endpoint is to use time to
 *                 determine the starting point.  The default value is 'POINT
 *                 NULL'.
 *                         <li> gpudb::match_graph_destination: Optional WKT
 *                 ending point from @a samplePoints for the solver. The
 *                 default behavior for the endpoint is to use time to
 *                 determine the destination point.  The default value is
 *                 'POINT NULL'.
 *                         <li> gpudb::match_graph_partial_loading: For the @a
 *                 match_supply_demand solver only. When false (non-default),
 *                 trucks do not off-load at the demand (store) side if the
 *                 remainder is less than the store's need
 *                 <ul>
 *                         <li> gpudb::match_graph_true: Partial off-loading at
 *                 multiple store (demand) locations
 *                         <li> gpudb::match_graph_false: No partial
 *                 off-loading allowed if supply is less than the store's
 *                 demand.
 *                 </ul>
 *                 The default value is gpudb::match_graph_true.
 *                         <li> gpudb::match_graph_max_combinations: For the @a
 *                 match_supply_demand solver only. This is the cutoff for the
 *                 number of generated combinations for sequencing the demand
 *                 locations - can increase this up to 2M.  The default value
 *                 is '10000'.
 *                         <li> gpudb::match_graph_max_supply_combinations: For
 *                 the @a match_supply_demand solver only. This is the cutoff
 *                 for the number of generated combinations for sequencing the
 *                 supply locations if/when 'permute_supplies' is true.  The
 *                 default value is '10000'.
 *                         <li> gpudb::match_graph_left_turn_penalty: This will
 *                 add an additonal weight over the edges labelled as 'left
 *                 turn' if the 'add_turn' option parameter of the
 *                 /create/graph was invoked at graph creation.  The default
 *                 value is '0.0'.
 *                         <li> gpudb::match_graph_right_turn_penalty: This
 *                 will add an additonal weight over the edges labelled as'
 *                 right turn' if the 'add_turn' option parameter of the
 *                 /create/graph was invoked at graph creation.  The default
 *                 value is '0.0'.
 *                         <li> gpudb::match_graph_intersection_penalty: This
 *                 will add an additonal weight over the edges labelled as
 *                 'intersection' if the 'add_turn' option parameter of the
 *                 /create/graph was invoked at graph creation.  The default
 *                 value is '0.0'.
 *                         <li> gpudb::match_graph_sharp_turn_penalty: This
 *                 will add an additonal weight over the edges labelled as
 *                 'sharp turn' or 'u-turn' if the 'add_turn' option parameter
 *                 of the /create/graph was invoked at graph creation.  The
 *                 default value is '0.0'.
 *                         <li> gpudb::match_graph_aggregated_output: For the
 *                 @a match_supply_demand solver only. When it is true
 *                 (default), each record in the output table shows a
 *                 particular truck's scheduled cumulative round trip path
 *                 (MULTILINESTRING) and the corresponding aggregated cost.
 *                 Otherwise, each record shows a single scheduled truck route
 *                 (LINESTRING) towards a particular demand location (store id)
 *                 with its corresponding cost.  The default value is 'true'.
 *                         <li> gpudb::match_graph_output_tracks: For the @a
 *                 match_supply_demand solver only. When it is true
 *                 (non-default), the output will be in tracks format for all
 *                 the round trips of each truck in which the timestamps are
 *                 populated directly from the edge weights starting from their
 *                 originating depots.  The default value is 'false'.
 *                         <li> gpudb::match_graph_max_trip_cost: For the @a
 *                 match_supply_demand and @a match_pickup_dropoff solvers
 *                 only. If this constraint is greater than zero (default) then
 *                 the trucks/rides will skip travelling from one demand/pick
 *                 location to another if the cost between them is greater than
 *                 this number (distance or time). Zero (default) value means
 *                 no check is performed.  The default value is '0.0'.
 *                         <li> gpudb::match_graph_filter_folding_paths: For
 *                 the @a markov_chain solver only. When true (non-default),
 *                 the paths per sequence combination is checked for folding
 *                 over patterns and can significantly increase the execution
 *                 time depending on the chain width and the number of gps
 *                 samples.
 *                 <ul>
 *                         <li> gpudb::match_graph_true: Filter out the folded
 *                 paths.
 *                         <li> gpudb::match_graph_false: Do not filter out the
 *                 folded paths
 *                 </ul>
 *                 The default value is gpudb::match_graph_false.
 *                         <li> gpudb::match_graph_unit_unloading_cost: For the
 *                 @a match_supply_demand solver only. The unit cost per load
 *                 amount to be delivered. If this value is greater than zero
 *                 (default) then the additional cost of this unit load
 *                 multiplied by the total dropped load will be added over to
 *                 the trip cost to the demand location.  The default value is
 *                 '0.0'.
 *                         <li> gpudb::match_graph_max_num_threads: For the @a
 *                 markov_chain solver only. If specified (greater than zero),
 *                 the maximum number of threads will not be greater than the
 *                 specified value. It can be lower due to the memory and the
 *                 number cores available. Default value of zero allows the
 *                 algorithm to set the maximal number of threads within these
 *                 constraints.  The default value is '0'.
 *                         <li> gpudb::match_graph_service_limit: For the @a
 *                 match_supply_demand solver only. If specified (greater than
 *                 zero), any supply actor's total service cost (distance or
 *                 time) will be limited by the specified value including
 *                 multiple rounds (if set).  The default value is '0.0'.
 *                         <li> gpudb::match_graph_enable_reuse: For the @a
 *                 match_supply_demand solver only. If specified (true), all
 *                 supply actors can be scheduled for second rounds from their
 *                 originating depots.
 *                 <ul>
 *                         <li> gpudb::match_graph_true: Allows reusing supply
 *                 actors (trucks, e.g.) for scheduling again.
 *                         <li> gpudb::match_graph_false: Supply actors are
 *                 scheduled only once from their depots.
 *                 </ul>
 *                 The default value is gpudb::match_graph_false.
 *                         <li> gpudb::match_graph_max_stops: For the @a
 *                 match_supply_demand solver only. If specified (greater than
 *                 zero), a supply actor (truck) can at most have this many
 *                 stops (demand locations) in one round trip. Otherwise, it is
 *                 unlimited. If 'enable_truck_reuse' is on, this condition
 *                 will be applied separately at each round trip use of the
 *                 same truck.  The default value is '0'.
 *                         <li> gpudb::match_graph_service_radius: For the @a
 *                 match_supply_demand and @a match_pickup_dropoff solvers
 *                 only. If specified (greater than zero), it filters the
 *                 demands/picks outside this radius centered around the supply
 *                 actor/ride's originating location (distance or time).  The
 *                 default value is '0.0'.
 *                         <li> gpudb::match_graph_permute_supplies: For the @a
 *                 match_supply_demand solver only. If specified (true), supply
 *                 side actors are permuted for the demand combinations during
 *                 msdo optimization - note that this option increases
 *                 optimization time significantly - use of 'max_combinations'
 *                 option is recommended to prevent prohibitively long runs
 *                 <ul>
 *                         <li> gpudb::match_graph_true: Generates sequences
 *                 over supply side permutations if total supply is less than
 *                 twice the total demand
 *                         <li> gpudb::match_graph_false: Permutations are not
 *                 performed, rather a specific order of supplies based on
 *                 capacity is computed
 *                 </ul>
 *                 The default value is gpudb::match_graph_true.
 *                         <li> gpudb::match_graph_batch_tsm_mode: For the @a
 *                 match_supply_demand solver only. When enabled, it sets the
 *                 number of visits on each demand location by a single
 *                 salesman at each trip is considered to be (one) 1, otherwise
 *                 there is no bound.
 *                 <ul>
 *                         <li> gpudb::match_graph_true: Sets only one visit
 *                 per demand location by a salesman (tsm mode)
 *                         <li> gpudb::match_graph_false: No preset limit
 *                 (usual msdo mode)
 *                 </ul>
 *                 The default value is gpudb::match_graph_false.
 *                         <li> gpudb::match_graph_round_trip: For the @a
 *                 match_supply_demand solver only. When enabled, the supply
 *                 will have to return back to the origination location.
 *                 <ul>
 *                         <li> gpudb::match_graph_true: The optimization is
 *                 done for trips in round trip manner always returning to
 *                 originating locations
 *                         <li> gpudb::match_graph_false: Supplies do not have
 *                 to come back to their originating locations in their routes.
 *                 The routes are considered finished at the final dropoff.
 *                 </ul>
 *                 The default value is gpudb::match_graph_true.
 *                         <li> gpudb::match_graph_num_cycles: For the @a
 *                 match_clusters solver only. Terminates the cluster exchange
 *                 iterations across 2-step-cycles (outer loop) when quality
 *                 does not improve during iterations.  The default value is
 *                 '10'.
 *                         <li> gpudb::match_graph_num_loops_per_cycle: For the
 *                 @a match_clusters solver only. Terminates the cluster
 *                 exchanges within the first step iterations of a cycle (inner
 *                 loop) unless convergence is reached.  The default value is
 *                 '10'.
 *                         <li> gpudb::match_graph_num_output_clusters: For the
 *                 @a match_clusters solver only.  Limits the output to the top
 *                 'num_output_clusters' clusters based on density. Default
 *                 value of zero outputs all clusters.  The default value is
 *                 '0'.
 *                         <li> gpudb::match_graph_max_num_clusters: For the @a
 *                 match_clusters solver only. If set (value greater than
 *                 zero), it terminates when the number of clusters goes below
 *                 than this number.  The default value is '0'.
 *                         <li> gpudb::match_graph_cluster_quality_metric: For
 *                 the @a match_clusters solver only. The quality metric for
 *                 Louvain modularity optimization solver.
 *                 <ul>
 *                         <li> gpudb::match_graph_girvan: Uses the Newman
 *                 Girvan quality metric for cluster solver
 *                         <li> gpudb::match_graph_spectral: Applies recursive
 *                 spectral bisection (RSB) partitioning solver
 *                 </ul>
 *                 The default value is gpudb::match_graph_girvan.
 *                         <li> gpudb::match_graph_restricted_type: For the @a
 *                 match_supply_demand solver only. Optimization is performed
 *                 by restricting routes labeled by 'MSDO_ODDEVEN_RESTRICTED'
 *                 only for this supply actor (truck) type
 *                 <ul>
 *                         <li> gpudb::match_graph_odd: Applies odd/even rule
 *                 restrictions to odd tagged vehicles.
 *                         <li> gpudb::match_graph_even: Applies odd/even rule
 *                 restrictions to even tagged vehicles.
 *                         <li> gpudb::match_graph_none: Does not apply
 *                 odd/even rule restrictions to any vehicles.
 *                 </ul>
 *                 The default value is gpudb::match_graph_none.
 *                         <li> gpudb::match_graph_server_id: Indicates which
 *                 graph server(s) to send the request to. Default is to send
 *                 to the server, amongst those containing the corresponding
 *                 graph, that has the most computational bandwidth.  The
 *                 default value is ''.
 *                         <li> gpudb::match_graph_inverse_solve: For the @a
 *                 match_batch_solves solver only. Solves source-destination
 *                 pairs using inverse shortest path solver.
 *                 <ul>
 *                         <li> gpudb::match_graph_true: Solves using inverse
 *                 shortest path solver.
 *                         <li> gpudb::match_graph_false: Solves using direct
 *                 shortest path solver.
 *                 </ul>
 *                 The default value is gpudb::match_graph_false.
 *                         <li> gpudb::match_graph_min_loop_level: For the @a
 *                 match_loops solver only. Finds closed loops around each node
 *                 deducible not less than this minimal hop (level) deep.  The
 *                 default value is '0'.
 *                         <li> gpudb::match_graph_max_loop_level: For the @a
 *                 match_loops solver only. Finds closed loops around each node
 *                 deducible not more than this maximal hop (level) deep.  The
 *                 default value is '5'.
 *                         <li> gpudb::match_graph_search_limit: For the @a
 *                 match_loops solver only. Searches within this limit of nodes
 *                 per vertex to detect loops. The value zero means there is no
 *                 limit.  The default value is '10000'.
 *                         <li> gpudb::match_graph_output_batch_size: For the
 *                 @a match_loops solver only. Uses this value as the batch
 *                 size of the number of loops in flushing(inserting) to the
 *                 output table.  The default value is '1000'.
 *                         <li> gpudb::match_graph_charging_capacity: For the
 *                 @a match_charging_stations solver only. This is the maximum
 *                 ev-charging capacity of a vehicle (distance in meters or
 *                 time in seconds depending on the unit of the graph weights).
 *                 The default value is '300000.0'.
 *                         <li> gpudb::match_graph_charging_candidates: For the
 *                 @a match_charging_stations solver only. Solver searches for
 *                 this many number of stations closest around each base
 *                 charging location found by capacity.  The default value is
 *                 '10'.
 *                         <li> gpudb::match_graph_charging_penalty: For the @a
 *                 match_charging_stations solver only. This is the penalty for
 *                 full charging.  The default value is '30000.0'.
 *                         <li> gpudb::match_graph_max_hops: For the @a
 *                 match_similarity solver only. Searches within this maximum
 *                 hops for source and target node pairs to compute the Jaccard
 *                 scores.  The default value is '3'.
 *                         <li> gpudb::match_graph_traversal_node_limit: For
 *                 the @a match_similarity solver only. Limits the traversal
 *                 depth if it reaches this many number of nodes.  The default
 *                 value is '1000'.
 *                         <li> gpudb::match_graph_paired_similarity: For the
 *                 @a match_similarity solver only. If true, it computes
 *                 Jaccard score between each pair, otherwise it will compute
 *                 Jaccard from the intersection set between the source and
 *                 target nodes
 *                 <ul>
 *                         <li> gpudb::match_graph_true
 *                         <li> gpudb::match_graph_false
 *                 </ul>
 *                 The default value is gpudb::match_graph_true.
 *                         <li> gpudb::match_graph_force_undirected: For the @a
 *                 match_pattern solver only. Pattern matching will be using
 *                 both pattern and graph as undirected if set to true.
 *                 <ul>
 *                         <li> gpudb::match_graph_true
 *                         <li> gpudb::match_graph_false
 *                 </ul>
 *                 The default value is gpudb::match_graph_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

MatchGraphResponse& matchGraph( const std::string& graphName,
                                const std::vector<std::string>& samplePoints,
                                const std::string& solveMethod,
                                const std::string& solutionTable,
                                const std::map<std::string, std::string>& options,
                                MatchGraphResponse& response_ ) const;

/**
 * Create a new empty result table (specified by @a tableName),
 * and insert all records from source tables
 * (specified by @a sourceTableNames) based on the field mapping
 * information (specified by @a fieldMaps).
 * <p>
 * For merge records details and examples, see
 * <a href="../../../concepts/merge_records/" target="_top">Merge Records</a>.
 * For limitations, see
 * <a href="../../../concepts/merge_records/#limitations-and-cautions"
 * target="_top">Merge Records Limitations and Cautions</a>.

 * The field map (specified by @a fieldMaps) holds the user-specified maps
 * of target table column names to source table columns. The array of
 * @a fieldMaps must match one-to-one with the @a sourceTableNames,
 * e.g., there's a map present in @a fieldMaps for each table listed in
 * @a sourceTableNames.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

MergeRecordsResponse mergeRecords( const MergeRecordsRequest& request_ ) const;

/**
 * Create a new empty result table (specified by @a tableName),
 * and insert all records from source tables
 * (specified by @a sourceTableNames) based on the field mapping
 * information (specified by @a fieldMaps).
 * <p>
 * For merge records details and examples, see
 * <a href="../../../concepts/merge_records/" target="_top">Merge Records</a>.
 * For limitations, see
 * <a href="../../../concepts/merge_records/#limitations-and-cautions"
 * target="_top">Merge Records Limitations and Cautions</a>.

 * The field map (specified by @a fieldMaps) holds the user-specified maps
 * of target table column names to source table columns. The array of
 * @a fieldMaps must match one-to-one with the @a sourceTableNames,
 * e.g., there's a map present in @a fieldMaps for each table listed in
 * @a sourceTableNames.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

MergeRecordsResponse& mergeRecords( const MergeRecordsRequest& request_,
                                    MergeRecordsResponse& response_ ) const;

/**
 * Create a new empty result table (specified by @a tableName),
 * and insert all records from source tables
 * (specified by @a sourceTableNames) based on the field mapping
 * information (specified by @a fieldMaps).
 * <p>
 * For merge records details and examples, see
 * <a href="../../../concepts/merge_records/" target="_top">Merge Records</a>.
 * For limitations, see
 * <a href="../../../concepts/merge_records/#limitations-and-cautions"
 * target="_top">Merge Records Limitations and Cautions</a>.

 * The field map (specified by @a fieldMaps) holds the user-specified maps
 * of target table column names to source table columns. The array of
 * @a fieldMaps must match one-to-one with the @a sourceTableNames,
 * e.g., there's a map present in @a fieldMaps for each table listed in
 * @a sourceTableNames.
 * 
 * @param tableName  The name of the new result table for the records to be
 *                   merged into, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a> and meeting <a
 *                   href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>.  Must NOT be an
 *                   existing table.
 * @param sourceTableNames  The list of names of source tables to get the
 *                          records from, each in [schema_name.]table_name
 *                          format, using standard <a
 *                          href="../../../concepts/tables/#table-name-resolution"
 *                          target="_top">name resolution rules</a>.  Must be
 *                          existing table names.
 * @param fieldMaps  Contains a list of source/target column mappings, one
 *                   mapping for each source table listed in @a
 *                   sourceTableNames being merged into the target table
 *                   specified by @a tableName.  Each mapping contains the
 *                   target column names (as keys) that the data in the mapped
 *                   source columns or column <a
 *                   href="../../../concepts/expressions/"
 *                   target="_top">expressions</a> (as values) will be merged
 *                   into.  All of the source columns being merged into a given
 *                   target column must match in type, as that type will
 *                   determine the type of the new target column.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::merge_records_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a tableName. If @a
 *                 persist is @a false, then this is always allowed even if the
 *                 caller does not have permission to create tables. The
 *                 generated name is returned in @a qualified_table_name.
 *                 <ul>
 *                         <li> gpudb::merge_records_true
 *                         <li> gpudb::merge_records_false
 *                 </ul>
 *                 The default value is gpudb::merge_records_false.
 *                         <li> gpudb::merge_records_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 merged table as part of @a tableName and use /create/schema
 *                 to create the schema if non-existent]  Name of a schema for
 *                 the newly created merged table specified by @a tableName.
 *                         <li> gpudb::merge_records_is_replicated: Indicates
 *                 the <a href="../../../concepts/tables/#distribution"
 *                 target="_top">distribution scheme</a> for the data of the
 *                 merged table specified in @a tableName.  If true, the table
 *                 will be <a href="../../../concepts/tables/#replication"
 *                 target="_top">replicated</a>.  If false, the table will be
 *                 <a href="../../../concepts/tables/#random-sharding"
 *                 target="_top">randomly sharded</a>.
 *                 <ul>
 *                         <li> gpudb::merge_records_true
 *                         <li> gpudb::merge_records_false
 *                 </ul>
 *                 The default value is gpudb::merge_records_false.
 *                         <li> gpudb::merge_records_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 merged table specified in @a tableName.
 *                         <li> gpudb::merge_records_persist: If @a true, then
 *                 the table specified in @a tableName will be persisted and
 *                 will not expire unless a @a ttl is specified.   If @a false,
 *                 then the table will be an in-memory table and will expire
 *                 unless a @a ttl is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::merge_records_true
 *                         <li> gpudb::merge_records_false
 *                 </ul>
 *                 The default value is gpudb::merge_records_true.
 *                         <li> gpudb::merge_records_chunk_size: Indicates the
 *                 number of records per chunk to be used for the merged table
 *                 specified in @a tableName.
 *                         <li> gpudb::merge_records_view_id: view this result
 *                 table is part of.  The default value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

MergeRecordsResponse mergeRecords( const std::string& tableName,
                                   const std::vector<std::string>& sourceTableNames,
                                   const std::vector<std::map<std::string, std::string> >& fieldMaps,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Create a new empty result table (specified by @a tableName),
 * and insert all records from source tables
 * (specified by @a sourceTableNames) based on the field mapping
 * information (specified by @a fieldMaps).
 * <p>
 * For merge records details and examples, see
 * <a href="../../../concepts/merge_records/" target="_top">Merge Records</a>.
 * For limitations, see
 * <a href="../../../concepts/merge_records/#limitations-and-cautions"
 * target="_top">Merge Records Limitations and Cautions</a>.

 * The field map (specified by @a fieldMaps) holds the user-specified maps
 * of target table column names to source table columns. The array of
 * @a fieldMaps must match one-to-one with the @a sourceTableNames,
 * e.g., there's a map present in @a fieldMaps for each table listed in
 * @a sourceTableNames.
 * 
 * @param tableName  The name of the new result table for the records to be
 *                   merged into, in [schema_name.]table_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a> and meeting <a
 *                   href="../../../concepts/tables/#table-naming-criteria"
 *                   target="_top">table naming criteria</a>.  Must NOT be an
 *                   existing table.
 * @param sourceTableNames  The list of names of source tables to get the
 *                          records from, each in [schema_name.]table_name
 *                          format, using standard <a
 *                          href="../../../concepts/tables/#table-name-resolution"
 *                          target="_top">name resolution rules</a>.  Must be
 *                          existing table names.
 * @param fieldMaps  Contains a list of source/target column mappings, one
 *                   mapping for each source table listed in @a
 *                   sourceTableNames being merged into the target table
 *                   specified by @a tableName.  Each mapping contains the
 *                   target column names (as keys) that the data in the mapped
 *                   source columns or column <a
 *                   href="../../../concepts/expressions/"
 *                   target="_top">expressions</a> (as values) will be merged
 *                   into.  All of the source columns being merged into a given
 *                   target column must match in type, as that type will
 *                   determine the type of the new target column.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::merge_records_create_temp_table: If @a
 *                 true, a unique temporary table name will be generated in the
 *                 sys_temp schema and used in place of @a tableName. If @a
 *                 persist is @a false, then this is always allowed even if the
 *                 caller does not have permission to create tables. The
 *                 generated name is returned in @a qualified_table_name.
 *                 <ul>
 *                         <li> gpudb::merge_records_true
 *                         <li> gpudb::merge_records_false
 *                 </ul>
 *                 The default value is gpudb::merge_records_false.
 *                         <li> gpudb::merge_records_collection_name:
 *                 [DEPRECATED--please specify the containing schema for the
 *                 merged table as part of @a tableName and use /create/schema
 *                 to create the schema if non-existent]  Name of a schema for
 *                 the newly created merged table specified by @a tableName.
 *                         <li> gpudb::merge_records_is_replicated: Indicates
 *                 the <a href="../../../concepts/tables/#distribution"
 *                 target="_top">distribution scheme</a> for the data of the
 *                 merged table specified in @a tableName.  If true, the table
 *                 will be <a href="../../../concepts/tables/#replication"
 *                 target="_top">replicated</a>.  If false, the table will be
 *                 <a href="../../../concepts/tables/#random-sharding"
 *                 target="_top">randomly sharded</a>.
 *                 <ul>
 *                         <li> gpudb::merge_records_true
 *                         <li> gpudb::merge_records_false
 *                 </ul>
 *                 The default value is gpudb::merge_records_false.
 *                         <li> gpudb::merge_records_ttl: Sets the <a
 *                 href="../../../concepts/ttl/" target="_top">TTL</a> of the
 *                 merged table specified in @a tableName.
 *                         <li> gpudb::merge_records_persist: If @a true, then
 *                 the table specified in @a tableName will be persisted and
 *                 will not expire unless a @a ttl is specified.   If @a false,
 *                 then the table will be an in-memory table and will expire
 *                 unless a @a ttl is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::merge_records_true
 *                         <li> gpudb::merge_records_false
 *                 </ul>
 *                 The default value is gpudb::merge_records_true.
 *                         <li> gpudb::merge_records_chunk_size: Indicates the
 *                 number of records per chunk to be used for the merged table
 *                 specified in @a tableName.
 *                         <li> gpudb::merge_records_view_id: view this result
 *                 table is part of.  The default value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

MergeRecordsResponse& mergeRecords( const std::string& tableName,
                                    const std::vector<std::string>& sourceTableNames,
                                    const std::vector<std::map<std::string, std::string> >& fieldMaps,
                                    const std::map<std::string, std::string>& options,
                                    MergeRecordsResponse& response_ ) const;

/**
 * Update an existing graph network using given nodes, edges, weights,
 * restrictions, and options.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, and
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>
 * before using this endpoint.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ModifyGraphResponse modifyGraph( const ModifyGraphRequest& request_ ) const;

/**
 * Update an existing graph network using given nodes, edges, weights,
 * restrictions, and options.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, and
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>
 * before using this endpoint.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ModifyGraphResponse& modifyGraph( const ModifyGraphRequest& request_,
                                  ModifyGraphResponse& response_ ) const;

/**
 * Update an existing graph network using given nodes, edges, weights,
 * restrictions, and options.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, and
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>
 * before using this endpoint.
 * 
 * @param graphName  Name of the graph resource to modify.
 * @param nodes  Nodes with which to update existing @a nodes in graph
 *               specified by @a graphName. Review <a
 *               href="../../../graph_solver/network_graph_solver/#nodes"
 *               target="_top">Nodes</a> for more information. Nodes must be
 *               specified using <a
 *               href="../../../graph_solver/network_graph_solver/#identifiers"
 *               target="_top">identifiers</a>; identifiers are grouped as <a
 *               href="../../../graph_solver/network_graph_solver/#id-combos"
 *               target="_top">combinations</a>. Identifiers can be used with
 *               existing column names, e.g., 'table.column AS NODE_ID',
 *               expressions, e.g., 'ST_MAKEPOINT(column1, column2) AS
 *               NODE_WKTPOINT', or raw values, e.g., '{9, 10, 11} AS NODE_ID'.
 *               If using raw values in an identifier combination, the number
 *               of values specified must match across the combination.
 *               Identifier combination(s) do not have to match the method used
 *               to create the graph, e.g., if column names were specified to
 *               create the graph, expressions or raw values could also be used
 *               to modify the graph.
 * @param edges  Edges with which to update existing @a edges in graph
 *               specified by @a graphName. Review <a
 *               href="../../../graph_solver/network_graph_solver/#edges"
 *               target="_top">Edges</a> for more information. Edges must be
 *               specified using <a
 *               href="../../../graph_solver/network_graph_solver/#identifiers"
 *               target="_top">identifiers</a>; identifiers are grouped as <a
 *               href="../../../graph_solver/network_graph_solver/#id-combos"
 *               target="_top">combinations</a>. Identifiers can be used with
 *               existing column names, e.g., 'table.column AS EDGE_ID',
 *               expressions, e.g., 'SUBSTR(column, 1, 6) AS EDGE_NODE1_NAME',
 *               or raw values, e.g., "{'family', 'coworker'} AS EDGE_LABEL".
 *               If using raw values in an identifier combination, the number
 *               of values specified must match across the combination.
 *               Identifier combination(s) do not have to match the method used
 *               to create the graph, e.g., if column names were specified to
 *               create the graph, expressions or raw values could also be used
 *               to modify the graph.
 * @param weights  Weights with which to update existing @a weights in graph
 *                 specified by @a graphName. Review <a
 *                 href="../../../graph_solver/network_graph_solver/#graph-weights"
 *                 target="_top">Weights</a> for more information. Weights must
 *                 be specified using <a
 *                 href="../../../graph_solver/network_graph_solver/#identifiers"
 *                 target="_top">identifiers</a>; identifiers are grouped as <a
 *                 href="../../../graph_solver/network_graph_solver/#id-combos"
 *                 target="_top">combinations</a>. Identifiers can be used with
 *                 existing column names, e.g., 'table.column AS
 *                 WEIGHTS_EDGE_ID', expressions, e.g., 'ST_LENGTH(wkt) AS
 *                 WEIGHTS_VALUESPECIFIED', or raw values, e.g., '{4, 15} AS
 *                 WEIGHTS_VALUESPECIFIED'. If using raw values in an
 *                 identifier combination, the number of values specified must
 *                 match across the combination. Identifier combination(s) do
 *                 not have to match the method used to create the graph, e.g.,
 *                 if column names were specified to create the graph,
 *                 expressions or raw values could also be used to modify the
 *                 graph.
 * @param restrictions  Restrictions with which to update existing @a
 *                      restrictions in graph specified by @a graphName. Review
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#graph-restrictions"
 *                      target="_top">Restrictions</a> for more information.
 *                      Restrictions must be specified using <a
 *                      href="../../../graph_solver/network_graph_solver/#identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../../graph_solver/network_graph_solver/#id-combos"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with existing column names, e.g., 'table.column AS
 *                      RESTRICTIONS_EDGE_ID', expressions, e.g., 'column/2 AS
 *                      RESTRICTIONS_VALUECOMPARED', or raw values, e.g., '{0,
 *                      0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using raw
 *                      values in an identifier combination, the number of
 *                      values specified must match across the combination.
 *                      Identifier combination(s) do not have to match the
 *                      method used to create the graph, e.g., if column names
 *                      were specified to create the graph, expressions or raw
 *                      values could also be used to modify the graph.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::modify_graph_restriction_threshold_value: Value-based
 *                 restriction comparison. Any node or edge with a
 *                 RESTRICTIONS_VALUECOMPARED value greater than the @a
 *                 restriction_threshold_value will not be included in the
 *                 graph.
 *                         <li> gpudb::modify_graph_export_create_results: If
 *                 set to @a true, returns the graph topology in the response
 *                 as arrays.
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_false.
 *                         <li> gpudb::modify_graph_enable_graph_draw: If set
 *                 to @a true, adds a 'EDGE_WKTLINE' column identifier to the
 *                 specified @a graph_table so the graph can be viewed via WMS;
 *                 for social and non-geospatial graphs, the 'EDGE_WKTLINE'
 *                 column identifier will be populated with spatial coordinates
 *                 derived from a flattening layout algorithm so the graph can
 *                 still be viewed.
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_false.
 *                         <li> gpudb::modify_graph_save_persist: If set to @a
 *                 true, the graph will be saved in the persist directory (see
 *                 the <a href="../../../config/" target="_top">config
 *                 reference</a> for more information). If set to @a false, the
 *                 graph will be removed when the graph server is shutdown.
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_false.
 *                         <li> gpudb::modify_graph_add_table_monitor: Adds a
 *                 table monitor to every table used in the creation of the
 *                 graph; this table monitor will trigger the graph to update
 *                 dynamically upon inserts to the source table(s). Note that
 *                 upon database restart, if @a save_persist is also set to @a
 *                 true, the graph will be fully reconstructed and the table
 *                 monitors will be reattached. For more details on table
 *                 monitors, see /create/tablemonitor.
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_false.
 *                         <li> gpudb::modify_graph_graph_table: If specified,
 *                 the created graph is also created as a table with the given
 *                 name, in [schema_name.]table_name format, using standard <a
 *                 href="../../../concepts/tables/#table-name-resolution"
 *                 target="_top">name resolution rules</a> and meeting <a
 *                 href="../../../concepts/tables/#table-naming-criteria"
 *                 target="_top">table naming criteria</a>.  This table will
 *                 have the following identifier columns: 'EDGE_ID',
 *                 'EDGE_NODE1_ID', 'EDGE_NODE2_ID'. If left blank, no table is
 *                 created.  The default value is ''.
 *                         <li> gpudb::modify_graph_remove_label_only: When
 *                 RESTRICTIONS on labeled entities requested, if set to true
 *                 this will NOT delete the entity but only the label
 *                 associated with the entity. Otherwise (default), it'll
 *                 delete the label AND the entity.
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_false.
 *                         <li> gpudb::modify_graph_add_turns: Adds dummy
 *                 'pillowed' edges around intersection nodes where there are
 *                 more than three edges so that additional weight penalties
 *                 can be imposed by the solve endpoints. (increases the total
 *                 number of edges).
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_false.
 *                         <li> gpudb::modify_graph_turn_angle: Value in
 *                 degrees modifies the thresholds for attributing right, left,
 *                 sharp turns, and intersections. It is the vertical deviation
 *                 angle from the incoming edge to the intersection node. The
 *                 larger the value, the larger the threshold for sharp turns
 *                 and intersections; the smaller the value, the larger the
 *                 threshold for right and left turns; 0 < turn_angle < 90.
 *                 The default value is '60'.
 *                         <li> gpudb::modify_graph_use_rtree: Use an range
 *                 tree structure to accelerate and improve the accuracy of
 *                 snapping, especially to edges.
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_true.
 *                         <li> gpudb::modify_graph_label_delimiter: If
 *                 provided the label string will be split according to this
 *                 delimiter and each sub-string will be applied as a separate
 *                 label onto the specified edge.  The default value is ''.
 *                         <li> gpudb::modify_graph_allow_multiple_edges:
 *                 Multigraph choice; allowing multiple edges with the same
 *                 node pairs if set to true, otherwise, new edges with
 *                 existing same node pairs will not be inserted.
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_true.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ModifyGraphResponse modifyGraph( const std::string& graphName,
                                 const std::vector<std::string>& nodes,
                                 const std::vector<std::string>& edges,
                                 const std::vector<std::string>& weights,
                                 const std::vector<std::string>& restrictions,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Update an existing graph network using given nodes, edges, weights,
 * restrictions, and options.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, and
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>
 * before using this endpoint.
 * 
 * @param graphName  Name of the graph resource to modify.
 * @param nodes  Nodes with which to update existing @a nodes in graph
 *               specified by @a graphName. Review <a
 *               href="../../../graph_solver/network_graph_solver/#nodes"
 *               target="_top">Nodes</a> for more information. Nodes must be
 *               specified using <a
 *               href="../../../graph_solver/network_graph_solver/#identifiers"
 *               target="_top">identifiers</a>; identifiers are grouped as <a
 *               href="../../../graph_solver/network_graph_solver/#id-combos"
 *               target="_top">combinations</a>. Identifiers can be used with
 *               existing column names, e.g., 'table.column AS NODE_ID',
 *               expressions, e.g., 'ST_MAKEPOINT(column1, column2) AS
 *               NODE_WKTPOINT', or raw values, e.g., '{9, 10, 11} AS NODE_ID'.
 *               If using raw values in an identifier combination, the number
 *               of values specified must match across the combination.
 *               Identifier combination(s) do not have to match the method used
 *               to create the graph, e.g., if column names were specified to
 *               create the graph, expressions or raw values could also be used
 *               to modify the graph.
 * @param edges  Edges with which to update existing @a edges in graph
 *               specified by @a graphName. Review <a
 *               href="../../../graph_solver/network_graph_solver/#edges"
 *               target="_top">Edges</a> for more information. Edges must be
 *               specified using <a
 *               href="../../../graph_solver/network_graph_solver/#identifiers"
 *               target="_top">identifiers</a>; identifiers are grouped as <a
 *               href="../../../graph_solver/network_graph_solver/#id-combos"
 *               target="_top">combinations</a>. Identifiers can be used with
 *               existing column names, e.g., 'table.column AS EDGE_ID',
 *               expressions, e.g., 'SUBSTR(column, 1, 6) AS EDGE_NODE1_NAME',
 *               or raw values, e.g., "{'family', 'coworker'} AS EDGE_LABEL".
 *               If using raw values in an identifier combination, the number
 *               of values specified must match across the combination.
 *               Identifier combination(s) do not have to match the method used
 *               to create the graph, e.g., if column names were specified to
 *               create the graph, expressions or raw values could also be used
 *               to modify the graph.
 * @param weights  Weights with which to update existing @a weights in graph
 *                 specified by @a graphName. Review <a
 *                 href="../../../graph_solver/network_graph_solver/#graph-weights"
 *                 target="_top">Weights</a> for more information. Weights must
 *                 be specified using <a
 *                 href="../../../graph_solver/network_graph_solver/#identifiers"
 *                 target="_top">identifiers</a>; identifiers are grouped as <a
 *                 href="../../../graph_solver/network_graph_solver/#id-combos"
 *                 target="_top">combinations</a>. Identifiers can be used with
 *                 existing column names, e.g., 'table.column AS
 *                 WEIGHTS_EDGE_ID', expressions, e.g., 'ST_LENGTH(wkt) AS
 *                 WEIGHTS_VALUESPECIFIED', or raw values, e.g., '{4, 15} AS
 *                 WEIGHTS_VALUESPECIFIED'. If using raw values in an
 *                 identifier combination, the number of values specified must
 *                 match across the combination. Identifier combination(s) do
 *                 not have to match the method used to create the graph, e.g.,
 *                 if column names were specified to create the graph,
 *                 expressions or raw values could also be used to modify the
 *                 graph.
 * @param restrictions  Restrictions with which to update existing @a
 *                      restrictions in graph specified by @a graphName. Review
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#graph-restrictions"
 *                      target="_top">Restrictions</a> for more information.
 *                      Restrictions must be specified using <a
 *                      href="../../../graph_solver/network_graph_solver/#identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../../graph_solver/network_graph_solver/#id-combos"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with existing column names, e.g., 'table.column AS
 *                      RESTRICTIONS_EDGE_ID', expressions, e.g., 'column/2 AS
 *                      RESTRICTIONS_VALUECOMPARED', or raw values, e.g., '{0,
 *                      0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using raw
 *                      values in an identifier combination, the number of
 *                      values specified must match across the combination.
 *                      Identifier combination(s) do not have to match the
 *                      method used to create the graph, e.g., if column names
 *                      were specified to create the graph, expressions or raw
 *                      values could also be used to modify the graph.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::modify_graph_restriction_threshold_value: Value-based
 *                 restriction comparison. Any node or edge with a
 *                 RESTRICTIONS_VALUECOMPARED value greater than the @a
 *                 restriction_threshold_value will not be included in the
 *                 graph.
 *                         <li> gpudb::modify_graph_export_create_results: If
 *                 set to @a true, returns the graph topology in the response
 *                 as arrays.
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_false.
 *                         <li> gpudb::modify_graph_enable_graph_draw: If set
 *                 to @a true, adds a 'EDGE_WKTLINE' column identifier to the
 *                 specified @a graph_table so the graph can be viewed via WMS;
 *                 for social and non-geospatial graphs, the 'EDGE_WKTLINE'
 *                 column identifier will be populated with spatial coordinates
 *                 derived from a flattening layout algorithm so the graph can
 *                 still be viewed.
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_false.
 *                         <li> gpudb::modify_graph_save_persist: If set to @a
 *                 true, the graph will be saved in the persist directory (see
 *                 the <a href="../../../config/" target="_top">config
 *                 reference</a> for more information). If set to @a false, the
 *                 graph will be removed when the graph server is shutdown.
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_false.
 *                         <li> gpudb::modify_graph_add_table_monitor: Adds a
 *                 table monitor to every table used in the creation of the
 *                 graph; this table monitor will trigger the graph to update
 *                 dynamically upon inserts to the source table(s). Note that
 *                 upon database restart, if @a save_persist is also set to @a
 *                 true, the graph will be fully reconstructed and the table
 *                 monitors will be reattached. For more details on table
 *                 monitors, see /create/tablemonitor.
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_false.
 *                         <li> gpudb::modify_graph_graph_table: If specified,
 *                 the created graph is also created as a table with the given
 *                 name, in [schema_name.]table_name format, using standard <a
 *                 href="../../../concepts/tables/#table-name-resolution"
 *                 target="_top">name resolution rules</a> and meeting <a
 *                 href="../../../concepts/tables/#table-naming-criteria"
 *                 target="_top">table naming criteria</a>.  This table will
 *                 have the following identifier columns: 'EDGE_ID',
 *                 'EDGE_NODE1_ID', 'EDGE_NODE2_ID'. If left blank, no table is
 *                 created.  The default value is ''.
 *                         <li> gpudb::modify_graph_remove_label_only: When
 *                 RESTRICTIONS on labeled entities requested, if set to true
 *                 this will NOT delete the entity but only the label
 *                 associated with the entity. Otherwise (default), it'll
 *                 delete the label AND the entity.
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_false.
 *                         <li> gpudb::modify_graph_add_turns: Adds dummy
 *                 'pillowed' edges around intersection nodes where there are
 *                 more than three edges so that additional weight penalties
 *                 can be imposed by the solve endpoints. (increases the total
 *                 number of edges).
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_false.
 *                         <li> gpudb::modify_graph_turn_angle: Value in
 *                 degrees modifies the thresholds for attributing right, left,
 *                 sharp turns, and intersections. It is the vertical deviation
 *                 angle from the incoming edge to the intersection node. The
 *                 larger the value, the larger the threshold for sharp turns
 *                 and intersections; the smaller the value, the larger the
 *                 threshold for right and left turns; 0 < turn_angle < 90.
 *                 The default value is '60'.
 *                         <li> gpudb::modify_graph_use_rtree: Use an range
 *                 tree structure to accelerate and improve the accuracy of
 *                 snapping, especially to edges.
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_true.
 *                         <li> gpudb::modify_graph_label_delimiter: If
 *                 provided the label string will be split according to this
 *                 delimiter and each sub-string will be applied as a separate
 *                 label onto the specified edge.  The default value is ''.
 *                         <li> gpudb::modify_graph_allow_multiple_edges:
 *                 Multigraph choice; allowing multiple edges with the same
 *                 node pairs if set to true, otherwise, new edges with
 *                 existing same node pairs will not be inserted.
 *                 <ul>
 *                         <li> gpudb::modify_graph_true
 *                         <li> gpudb::modify_graph_false
 *                 </ul>
 *                 The default value is gpudb::modify_graph_true.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ModifyGraphResponse& modifyGraph( const std::string& graphName,
                                  const std::vector<std::string>& nodes,
                                  const std::vector<std::string>& edges,
                                  const std::vector<std::string>& weights,
                                  const std::vector<std::string>& restrictions,
                                  const std::map<std::string, std::string>& options,
                                  ModifyGraphResponse& response_ ) const;

/**
 * Employs a topological query on a network graph generated a-priori by
 * {@link #createGraph(const CreateGraphRequest&) const} and returns a list
 * of adjacent edge(s) or node(s),
 * also known as an adjacency list, depending on what's been provided to the
 * endpoint; providing edges will return nodes and providing nodes will return
 * edges.
 * <p>
 * To determine the node(s) or edge(s) adjacent to a value from a given column,
 * provide a list of values to @a queries. This field can be populated with
 * column values from any table as long as the type is supported by the given
 * identifier. See
 * <a href="../../../graph_solver/network_graph_solver/#query-identifiers"
 * target="_top">Query Identifiers</a>
 * for more information.
 * <p>
 * To return the adjacency list in the response, leave @a adjacencyTable
 * empty.
 * <p>
 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph---query" target="_top">/match/graph
 * examples</a>
 * before using this endpoint.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

QueryGraphResponse queryGraph( const QueryGraphRequest& request_ ) const;

/**
 * Employs a topological query on a network graph generated a-priori by
 * {@link
 * #createGraph(const CreateGraphRequest&,CreateGraphResponse&) const} and
 * returns a list of adjacent edge(s) or node(s),
 * also known as an adjacency list, depending on what's been provided to the
 * endpoint; providing edges will return nodes and providing nodes will return
 * edges.
 * <p>
 * To determine the node(s) or edge(s) adjacent to a value from a given column,
 * provide a list of values to @a queries. This field can be populated with
 * column values from any table as long as the type is supported by the given
 * identifier. See
 * <a href="../../../graph_solver/network_graph_solver/#query-identifiers"
 * target="_top">Query Identifiers</a>
 * for more information.
 * <p>
 * To return the adjacency list in the response, leave @a adjacencyTable
 * empty.
 * <p>
 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph---query" target="_top">/match/graph
 * examples</a>
 * before using this endpoint.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

QueryGraphResponse& queryGraph( const QueryGraphRequest& request_,
                                QueryGraphResponse& response_ ) const;

/**
 * Employs a topological query on a network graph generated a-priori by
 * {@link
 * #createGraph(const std::string&,const bool,const std::vector<std::string>&,const std::vector<std::string>&,const std::vector<std::string>&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}
 * and returns a list of adjacent edge(s) or node(s),
 * also known as an adjacency list, depending on what's been provided to the
 * endpoint; providing edges will return nodes and providing nodes will return
 * edges.
 * <p>
 * To determine the node(s) or edge(s) adjacent to a value from a given column,
 * provide a list of values to @a queries. This field can be populated with
 * column values from any table as long as the type is supported by the given
 * identifier. See
 * <a href="../../../graph_solver/network_graph_solver/#query-identifiers"
 * target="_top">Query Identifiers</a>
 * for more information.
 * <p>
 * To return the adjacency list in the response, leave @a adjacencyTable
 * empty.
 * <p>
 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph---query" target="_top">/match/graph
 * examples</a>
 * before using this endpoint.
 * 
 * @param graphName  Name of the graph resource to query.
 * @param queries  Nodes or edges to be queried specified using <a
 *                 href="../../../graph_solver/network_graph_solver/#query-identifiers"
 *                 target="_top">query identifiers</a>. Identifiers can be used
 *                 with existing column names, e.g., 'table.column AS
 *                 QUERY_NODE_ID', raw values, e.g., '{0, 2} AS QUERY_NODE_ID',
 *                 or expressions, e.g., 'ST_MAKEPOINT(table.x, table.y) AS
 *                 QUERY_NODE_WKTPOINT'. Multiple values can be provided as
 *                 long as the same identifier is used for all values. If using
 *                 raw values in an identifier combination, the number of
 *                 values specified must match across the combination.
 * @param restrictions  Additional restrictions to apply to the nodes/edges of
 *                      an existing graph. Restrictions must be specified using
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../../graph_solver/network_graph_solver/#id-combos"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with existing column names, e.g., 'table.column AS
 *                      RESTRICTIONS_EDGE_ID', expressions, e.g., 'column/2 AS
 *                      RESTRICTIONS_VALUECOMPARED', or raw values, e.g., '{0,
 *                      0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using raw
 *                      values in an identifier combination, the number of
 *                      values specified must match across the combination.
 * @param adjacencyTable  Name of the table to store the resulting adjacencies,
 *                        in [schema_name.]table_name format, using standard <a
 *                        href="../../../concepts/tables/#table-name-resolution"
 *                        target="_top">name resolution rules</a> and meeting
 *                        <a
 *                        href="../../../concepts/tables/#table-naming-criteria"
 *                        target="_top">table naming criteria</a>.  If left
 *                        blank, the query results are instead returned in the
 *                        response. If the 'QUERY_TARGET_NODE_LABEL' <a
 *                        href="../../../graph_solver/network_graph_solver/#query-identifiers"
 *                        target="_top">query identifier</a> is used in @a
 *                        queries, then two additional columns will be
 *                        available: 'PATH_ID' and 'RING_ID'. See <a
 *                        href="../../../graph_solver/network_graph_solver/#using-labels"
 *                        target="_top">Using Labels</a> for more information.
 * @param rings  Sets the number of rings around the node to query for
 *               adjacency, with '1' being the edges directly attached to the
 *               queried node. Also known as number of hops. For example, if it
 *               is set to '2', the edge(s) directly attached to the queried
 *               node(s) will be returned; in addition, the edge(s) attached to
 *               the node(s) attached to the initial ring of edge(s)
 *               surrounding the queried node(s) will be returned. If the value
 *               is set to '0', any nodes that meet the criteria in @a queries
 *               and @a restrictions will be returned. This parameter is only
 *               applicable when querying nodes.
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::query_graph_force_undirected: If set to
 *                 @a true, all inbound edges and outbound edges relative to
 *                 the node will be returned. If set to @a false, only outbound
 *                 edges relative to the node will be returned. This parameter
 *                 is only applicable if the queried graph @a graphName is
 *                 directed and when querying nodes. Consult <a
 *                 href="../../../graph_solver/network_graph_solver/#directed-graphs"
 *                 target="_top">Directed Graphs</a> for more details.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                         <li> gpudb::query_graph_limit: When specified (>0),
 *                 limits the number of query results. The size of the nodes
 *                 table will be limited by the @a limit value.  The default
 *                 value is '0'.
 *                         <li> gpudb::query_graph_output_wkt_path: If true
 *                 then concatenated wkt line segments will be added as the WKT
 *                 column of the adjacency table.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                         <li> gpudb::query_graph_and_labels: If set to @a
 *                 true, the result of the query has entities that satisfy all
 *                 of the target labels, instead of any.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                         <li> gpudb::query_graph_server_id: Indicates which
 *                 graph server(s) to send the request to. Default is to send
 *                 to the server, amongst those containing the corresponding
 *                 graph, that has the most computational bandwidth.
 *                         <li> gpudb::query_graph_output_charn_length: When
 *                 specified (>0 and <=256), limits the number of char length
 *                 on the output tables for string based nodes. The default
 *                 length is 64.  The default value is '64'.
 *                         <li> gpudb::query_graph_find_common_labels: If set
 *                 to true, for many-to-many queries or multi-level traversals,
 *                 it lists the common labels between the source and target
 *                 nodes and edge labels in each path. Otherwise (zero rings),
 *                 it'll list all labels of the node(s) queried.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

QueryGraphResponse queryGraph( const std::string& graphName,
                               const std::vector<std::string>& queries,
                               const std::vector<std::string>& restrictions,
                               const std::string& adjacencyTable,
                               const int32_t rings,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Employs a topological query on a network graph generated a-priori by
 * {@link
 * #createGraph(const std::string&,const bool,const std::vector<std::string>&,const std::vector<std::string>&,const std::vector<std::string>&,const std::vector<std::string>&,const std::map<std::string, std::string>&,CreateGraphResponse&) const}
 * and returns a list of adjacent edge(s) or node(s),
 * also known as an adjacency list, depending on what's been provided to the
 * endpoint; providing edges will return nodes and providing nodes will return
 * edges.
 * <p>
 * To determine the node(s) or edge(s) adjacent to a value from a given column,
 * provide a list of values to @a queries. This field can be populated with
 * column values from any table as long as the type is supported by the given
 * identifier. See
 * <a href="../../../graph_solver/network_graph_solver/#query-identifiers"
 * target="_top">Query Identifiers</a>
 * for more information.
 * <p>
 * To return the adjacency list in the response, leave @a adjacencyTable
 * empty.
 * <p>
 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph---query" target="_top">/match/graph
 * examples</a>
 * before using this endpoint.
 * 
 * @param graphName  Name of the graph resource to query.
 * @param queries  Nodes or edges to be queried specified using <a
 *                 href="../../../graph_solver/network_graph_solver/#query-identifiers"
 *                 target="_top">query identifiers</a>. Identifiers can be used
 *                 with existing column names, e.g., 'table.column AS
 *                 QUERY_NODE_ID', raw values, e.g., '{0, 2} AS QUERY_NODE_ID',
 *                 or expressions, e.g., 'ST_MAKEPOINT(table.x, table.y) AS
 *                 QUERY_NODE_WKTPOINT'. Multiple values can be provided as
 *                 long as the same identifier is used for all values. If using
 *                 raw values in an identifier combination, the number of
 *                 values specified must match across the combination.
 * @param restrictions  Additional restrictions to apply to the nodes/edges of
 *                      an existing graph. Restrictions must be specified using
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../../graph_solver/network_graph_solver/#id-combos"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with existing column names, e.g., 'table.column AS
 *                      RESTRICTIONS_EDGE_ID', expressions, e.g., 'column/2 AS
 *                      RESTRICTIONS_VALUECOMPARED', or raw values, e.g., '{0,
 *                      0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using raw
 *                      values in an identifier combination, the number of
 *                      values specified must match across the combination.
 * @param adjacencyTable  Name of the table to store the resulting adjacencies,
 *                        in [schema_name.]table_name format, using standard <a
 *                        href="../../../concepts/tables/#table-name-resolution"
 *                        target="_top">name resolution rules</a> and meeting
 *                        <a
 *                        href="../../../concepts/tables/#table-naming-criteria"
 *                        target="_top">table naming criteria</a>.  If left
 *                        blank, the query results are instead returned in the
 *                        response. If the 'QUERY_TARGET_NODE_LABEL' <a
 *                        href="../../../graph_solver/network_graph_solver/#query-identifiers"
 *                        target="_top">query identifier</a> is used in @a
 *                        queries, then two additional columns will be
 *                        available: 'PATH_ID' and 'RING_ID'. See <a
 *                        href="../../../graph_solver/network_graph_solver/#using-labels"
 *                        target="_top">Using Labels</a> for more information.
 * @param rings  Sets the number of rings around the node to query for
 *               adjacency, with '1' being the edges directly attached to the
 *               queried node. Also known as number of hops. For example, if it
 *               is set to '2', the edge(s) directly attached to the queried
 *               node(s) will be returned; in addition, the edge(s) attached to
 *               the node(s) attached to the initial ring of edge(s)
 *               surrounding the queried node(s) will be returned. If the value
 *               is set to '0', any nodes that meet the criteria in @a queries
 *               and @a restrictions will be returned. This parameter is only
 *               applicable when querying nodes.
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::query_graph_force_undirected: If set to
 *                 @a true, all inbound edges and outbound edges relative to
 *                 the node will be returned. If set to @a false, only outbound
 *                 edges relative to the node will be returned. This parameter
 *                 is only applicable if the queried graph @a graphName is
 *                 directed and when querying nodes. Consult <a
 *                 href="../../../graph_solver/network_graph_solver/#directed-graphs"
 *                 target="_top">Directed Graphs</a> for more details.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                         <li> gpudb::query_graph_limit: When specified (>0),
 *                 limits the number of query results. The size of the nodes
 *                 table will be limited by the @a limit value.  The default
 *                 value is '0'.
 *                         <li> gpudb::query_graph_output_wkt_path: If true
 *                 then concatenated wkt line segments will be added as the WKT
 *                 column of the adjacency table.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                         <li> gpudb::query_graph_and_labels: If set to @a
 *                 true, the result of the query has entities that satisfy all
 *                 of the target labels, instead of any.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                         <li> gpudb::query_graph_server_id: Indicates which
 *                 graph server(s) to send the request to. Default is to send
 *                 to the server, amongst those containing the corresponding
 *                 graph, that has the most computational bandwidth.
 *                         <li> gpudb::query_graph_output_charn_length: When
 *                 specified (>0 and <=256), limits the number of char length
 *                 on the output tables for string based nodes. The default
 *                 length is 64.  The default value is '64'.
 *                         <li> gpudb::query_graph_find_common_labels: If set
 *                 to true, for many-to-many queries or multi-level traversals,
 *                 it lists the common labels between the source and target
 *                 nodes and edge labels in each path. Otherwise (zero rings),
 *                 it'll list all labels of the node(s) queried.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

QueryGraphResponse& queryGraph( const std::string& graphName,
                                const std::vector<std::string>& queries,
                                const std::vector<std::string>& restrictions,
                                const std::string& adjacencyTable,
                                const int32_t rings,
                                const std::map<std::string, std::string>& options,
                                QueryGraphResponse& response_ ) const;

/**
 * Rebalances an existing partitioned graph.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some <a href="../../../guide-tags/graph/" target="_top">graph
 * examples</a> before
 * using this endpoint.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RepartitionGraphResponse repartitionGraph( const RepartitionGraphRequest& request_ ) const;

/**
 * Rebalances an existing partitioned graph.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some <a href="../../../guide-tags/graph/" target="_top">graph
 * examples</a> before
 * using this endpoint.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RepartitionGraphResponse& repartitionGraph( const RepartitionGraphRequest& request_,
                                            RepartitionGraphResponse& response_ ) const;

/**
 * Rebalances an existing partitioned graph.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some <a href="../../../guide-tags/graph/" target="_top">graph
 * examples</a> before
 * using this endpoint.
 * 
 * @param graphName  Name of the graph resource to rebalance.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::repartition_graph_new_graph_name: If a
 *                 non-empty value is specified, the original graph will be
 *                 kept
 *                 (non-default behaviour) and a new balanced graph will be
 *                 created under this given name.  When the
 *                 value is empty (default), the generated 'balanced' graph
 *                 will replace the original 'unbalanced'
 *                 graph under the same graph name.  The default value is ''.
 *                         <li> gpudb::repartition_graph_source_node: The
 *                 distributed shortest path solve is run from this source node
 *                 to
 *                 all the nodes in the graph to create balaced partitions
 *                 using the iso-distance levels of the
 *                 solution.  The source node is selected by the rebalance
 *                 algorithm automatically (default case when
 *                 the value is an empty string). Otherwise, the user specified
 *                 node is used as the source.  The default value is ''.
 *                         <li> gpudb::repartition_graph_sql_request_avro_json:
 *                 The default value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RepartitionGraphResponse repartitionGraph( const std::string& graphName,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * Rebalances an existing partitioned graph.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some <a href="../../../guide-tags/graph/" target="_top">graph
 * examples</a> before
 * using this endpoint.
 * 
 * @param graphName  Name of the graph resource to rebalance.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::repartition_graph_new_graph_name: If a
 *                 non-empty value is specified, the original graph will be
 *                 kept
 *                 (non-default behaviour) and a new balanced graph will be
 *                 created under this given name.  When the
 *                 value is empty (default), the generated 'balanced' graph
 *                 will replace the original 'unbalanced'
 *                 graph under the same graph name.  The default value is ''.
 *                         <li> gpudb::repartition_graph_source_node: The
 *                 distributed shortest path solve is run from this source node
 *                 to
 *                 all the nodes in the graph to create balaced partitions
 *                 using the iso-distance levels of the
 *                 solution.  The source node is selected by the rebalance
 *                 algorithm automatically (default case when
 *                 the value is an empty string). Otherwise, the user specified
 *                 node is used as the source.  The default value is ''.
 *                         <li> gpudb::repartition_graph_sql_request_avro_json:
 *                 The default value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RepartitionGraphResponse& repartitionGraph( const std::string& graphName,
                                            const std::map<std::string, std::string>& options,
                                            RepartitionGraphResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ReserveResourceResponse reserveResource( const ReserveResourceRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ReserveResourceResponse& reserveResource( const ReserveResourceRequest& request_,
                                          ReserveResourceResponse& response_ ) const;

/**
 * @private
 * 
 * @param component
 * @param name
 * @param action
 *                <ul>
 *                        <li> gpudb::reserve_resource_get_size
 *                        <li> gpudb::reserve_resource_notify_untiered
 *                        <li> gpudb::reserve_resource_tier
 *                        <li> gpudb::reserve_resource_evict
 *                        <li> gpudb::reserve_resource_delete
 *                        <li> gpudb::reserve_resource_change_owner
 *                </ul>
 * @param bytesRequested
 * @param ownerId
 * @param options
 *                 <ul>
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ReserveResourceResponse reserveResource( const std::string& component,
                                         const std::string& name,
                                         const std::string& action,
                                         const int64_t bytesRequested,
                                         const int64_t ownerId,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param component
 * @param name
 * @param action
 *                <ul>
 *                        <li> gpudb::reserve_resource_get_size
 *                        <li> gpudb::reserve_resource_notify_untiered
 *                        <li> gpudb::reserve_resource_tier
 *                        <li> gpudb::reserve_resource_evict
 *                        <li> gpudb::reserve_resource_delete
 *                        <li> gpudb::reserve_resource_change_owner
 *                </ul>
 * @param bytesRequested
 * @param ownerId
 * @param options
 *                 <ul>
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ReserveResourceResponse& reserveResource( const std::string& component,
                                          const std::string& name,
                                          const std::string& action,
                                          const int64_t bytesRequested,
                                          const int64_t ownerId,
                                          const std::map<std::string, std::string>& options,
                                          ReserveResourceResponse& response_ ) const;

/**
 * Revoke user or role the specified permission on the specified object.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionResponse revokePermission( const RevokePermissionRequest& request_ ) const;

/**
 * Revoke user or role the specified permission on the specified object.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionResponse& revokePermission( const RevokePermissionRequest& request_,
                                            RevokePermissionResponse& response_ ) const;

/**
 * Revoke user or role the specified permission on the specified object.
 * 
 * @param principal  Name of the user or role for which the permission is being
 *                   revoked.  Must be an existing user or role.
 * @param object  Name of object permission is being revoked from.  It is
 *                recommended to use a fully-qualified name when possible.
 * @param objectType  The type of object being revoked
 *                    <ul>
 *                            <li> gpudb::revoke_permission_context: Context
 *                            <li> gpudb::revoke_permission_credential:
 *                    Credential
 *                            <li> gpudb::revoke_permission_datasink: Data Sink
 *                            <li> gpudb::revoke_permission_datasource: Data
 *                    Source
 *                            <li> gpudb::revoke_permission_directory: KIFS
 *                    File Directory
 *                            <li> gpudb::revoke_permission_graph: A Graph
 *                    object
 *                            <li> gpudb::revoke_permission_proc: UDF Procedure
 *                            <li> gpudb::revoke_permission_schema: Schema
 *                            <li> gpudb::revoke_permission_sql_proc: SQL
 *                    Procedure
 *                            <li> gpudb::revoke_permission_system:
 *                    System-level access
 *                            <li> gpudb::revoke_permission_table: Database
 *                    Table
 *                            <li> gpudb::revoke_permission_table_monitor:
 *                    Table monitor
 *                    </ul>
 * @param permission  Permission being revoked.
 *                    <ul>
 *                            <li> gpudb::revoke_permission_admin: Full
 *                    read/write and administrative access on the object.
 *                            <li> gpudb::revoke_permission_connect: Connect
 *                    access on the given data source or data sink.
 *                            <li> gpudb::revoke_permission_delete: Delete rows
 *                    from tables.
 *                            <li> gpudb::revoke_permission_execute: Ability to
 *                    Execute the Procedure object.
 *                            <li> gpudb::revoke_permission_insert: Insert
 *                    access to tables.
 *                            <li> gpudb::revoke_permission_read: Ability to
 *                    read, list and use the object.
 *                            <li> gpudb::revoke_permission_update: Update
 *                    access to the table.
 *                            <li> gpudb::revoke_permission_user_admin: Access
 *                    to administer users and roles that do not have
 *                    system_admin permission.
 *                            <li> gpudb::revoke_permission_write: Access to
 *                    write, change and delete objects.
 *                    </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::revoke_permission_columns: Revoke table
 *                 security from these columns, comma-separated.  The default
 *                 value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionResponse revokePermission( const std::string& principal,
                                           const std::string& object,
                                           const std::string& objectType,
                                           const std::string& permission,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * Revoke user or role the specified permission on the specified object.
 * 
 * @param principal  Name of the user or role for which the permission is being
 *                   revoked.  Must be an existing user or role.
 * @param object  Name of object permission is being revoked from.  It is
 *                recommended to use a fully-qualified name when possible.
 * @param objectType  The type of object being revoked
 *                    <ul>
 *                            <li> gpudb::revoke_permission_context: Context
 *                            <li> gpudb::revoke_permission_credential:
 *                    Credential
 *                            <li> gpudb::revoke_permission_datasink: Data Sink
 *                            <li> gpudb::revoke_permission_datasource: Data
 *                    Source
 *                            <li> gpudb::revoke_permission_directory: KIFS
 *                    File Directory
 *                            <li> gpudb::revoke_permission_graph: A Graph
 *                    object
 *                            <li> gpudb::revoke_permission_proc: UDF Procedure
 *                            <li> gpudb::revoke_permission_schema: Schema
 *                            <li> gpudb::revoke_permission_sql_proc: SQL
 *                    Procedure
 *                            <li> gpudb::revoke_permission_system:
 *                    System-level access
 *                            <li> gpudb::revoke_permission_table: Database
 *                    Table
 *                            <li> gpudb::revoke_permission_table_monitor:
 *                    Table monitor
 *                    </ul>
 * @param permission  Permission being revoked.
 *                    <ul>
 *                            <li> gpudb::revoke_permission_admin: Full
 *                    read/write and administrative access on the object.
 *                            <li> gpudb::revoke_permission_connect: Connect
 *                    access on the given data source or data sink.
 *                            <li> gpudb::revoke_permission_delete: Delete rows
 *                    from tables.
 *                            <li> gpudb::revoke_permission_execute: Ability to
 *                    Execute the Procedure object.
 *                            <li> gpudb::revoke_permission_insert: Insert
 *                    access to tables.
 *                            <li> gpudb::revoke_permission_read: Ability to
 *                    read, list and use the object.
 *                            <li> gpudb::revoke_permission_update: Update
 *                    access to the table.
 *                            <li> gpudb::revoke_permission_user_admin: Access
 *                    to administer users and roles that do not have
 *                    system_admin permission.
 *                            <li> gpudb::revoke_permission_write: Access to
 *                    write, change and delete objects.
 *                    </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::revoke_permission_columns: Revoke table
 *                 security from these columns, comma-separated.  The default
 *                 value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionResponse& revokePermission( const std::string& principal,
                                            const std::string& object,
                                            const std::string& objectType,
                                            const std::string& permission,
                                            const std::map<std::string, std::string>& options,
                                            RevokePermissionResponse& response_ ) const;

/**
 * Revokes a <a
 * href="../../../security/sec_concepts/#security-concepts-permissions-credential"
 * target="_top">credential-level permission</a> from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionCredentialResponse revokePermissionCredential( const RevokePermissionCredentialRequest& request_ ) const;

/**
 * Revokes a <a
 * href="../../../security/sec_concepts/#security-concepts-permissions-credential"
 * target="_top">credential-level permission</a> from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionCredentialResponse& revokePermissionCredential( const RevokePermissionCredentialRequest& request_,
                                                                RevokePermissionCredentialResponse& response_ ) const;

/**
 * Revokes a <a
 * href="../../../security/sec_concepts/#security-concepts-permissions-credential"
 * target="_top">credential-level permission</a> from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li>
 *                    gpudb::revoke_permission_credential_credential_admin:
 *                    Full read/write and administrative access on the
 *                    credential.
 *                            <li>
 *                    gpudb::revoke_permission_credential_credential_read:
 *                    Ability to read and use the credential.
 *                    </ul>
 * @param credentialName  Name of the credential on which the permission will
 *                        be revoked. Must be an existing credential, or an
 *                        empty string to revoke access on all credentials.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionCredentialResponse revokePermissionCredential( const std::string& name,
                                                               const std::string& permission,
                                                               const std::string& credentialName,
                                                               const std::map<std::string, std::string>& options ) const;

/**
 * Revokes a <a
 * href="../../../security/sec_concepts/#security-concepts-permissions-credential"
 * target="_top">credential-level permission</a> from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li>
 *                    gpudb::revoke_permission_credential_credential_admin:
 *                    Full read/write and administrative access on the
 *                    credential.
 *                            <li>
 *                    gpudb::revoke_permission_credential_credential_read:
 *                    Ability to read and use the credential.
 *                    </ul>
 * @param credentialName  Name of the credential on which the permission will
 *                        be revoked. Must be an existing credential, or an
 *                        empty string to revoke access on all credentials.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionCredentialResponse& revokePermissionCredential( const std::string& name,
                                                                const std::string& permission,
                                                                const std::string& credentialName,
                                                                const std::map<std::string, std::string>& options,
                                                                RevokePermissionCredentialResponse& response_ ) const;

/**
 * Revokes a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a> permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionDatasourceResponse revokePermissionDatasource( const RevokePermissionDatasourceRequest& request_ ) const;

/**
 * Revokes a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a> permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionDatasourceResponse& revokePermissionDatasource( const RevokePermissionDatasourceRequest& request_,
                                                                RevokePermissionDatasourceResponse& response_ ) const;

/**
 * Revokes a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a> permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role
 *                    <ul>
 *                            <li> gpudb::revoke_permission_datasource_admin:
 *                    Admin access on the given data source
 *                            <li> gpudb::revoke_permission_datasource_connect:
 *                    Connect access on the given data source
 *                    </ul>
 * @param datasourceName  Name of the data source on which the permission will
 *                        be revoked. Must be an existing data source, or an
 *                        empty string to revoke permission from all data
 *                        sources.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionDatasourceResponse revokePermissionDatasource( const std::string& name,
                                                               const std::string& permission,
                                                               const std::string& datasourceName,
                                                               const std::map<std::string, std::string>& options ) const;

/**
 * Revokes a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a> permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role
 *                    <ul>
 *                            <li> gpudb::revoke_permission_datasource_admin:
 *                    Admin access on the given data source
 *                            <li> gpudb::revoke_permission_datasource_connect:
 *                    Connect access on the given data source
 *                    </ul>
 * @param datasourceName  Name of the data source on which the permission will
 *                        be revoked. Must be an existing data source, or an
 *                        empty string to revoke permission from all data
 *                        sources.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionDatasourceResponse& revokePermissionDatasource( const std::string& name,
                                                                const std::string& permission,
                                                                const std::string& datasourceName,
                                                                const std::map<std::string, std::string>& options,
                                                                RevokePermissionDatasourceResponse& response_ ) const;

/**
 * Revokes a <a href="../../../tools/kifs/" target="_top">KiFS</a>
 * directory-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionDirectoryResponse revokePermissionDirectory( const RevokePermissionDirectoryRequest& request_ ) const;

/**
 * Revokes a <a href="../../../tools/kifs/" target="_top">KiFS</a>
 * directory-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionDirectoryResponse& revokePermissionDirectory( const RevokePermissionDirectoryRequest& request_,
                                                              RevokePermissionDirectoryResponse& response_ ) const;

/**
 * Revokes a <a href="../../../tools/kifs/" target="_top">KiFS</a>
 * directory-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li>
 *                    gpudb::revoke_permission_directory_directory_read: For
 *                    files in the directory, access to list files, download
 *                    files, or use files in server side functions
 *                            <li>
 *                    gpudb::revoke_permission_directory_directory_write:
 *                    Access to upload files to, or delete files from, the
 *                    directory. A user or role with write access automatically
 *                    has read acceess
 *                    </ul>
 * @param directoryName  Name of the KiFS directory to which the permission
 *                       revokes access
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionDirectoryResponse revokePermissionDirectory( const std::string& name,
                                                             const std::string& permission,
                                                             const std::string& directoryName,
                                                             const std::map<std::string, std::string>& options ) const;

/**
 * Revokes a <a href="../../../tools/kifs/" target="_top">KiFS</a>
 * directory-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li>
 *                    gpudb::revoke_permission_directory_directory_read: For
 *                    files in the directory, access to list files, download
 *                    files, or use files in server side functions
 *                            <li>
 *                    gpudb::revoke_permission_directory_directory_write:
 *                    Access to upload files to, or delete files from, the
 *                    directory. A user or role with write access automatically
 *                    has read acceess
 *                    </ul>
 * @param directoryName  Name of the KiFS directory to which the permission
 *                       revokes access
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionDirectoryResponse& revokePermissionDirectory( const std::string& name,
                                                              const std::string& permission,
                                                              const std::string& directoryName,
                                                              const std::map<std::string, std::string>& options,
                                                              RevokePermissionDirectoryResponse& response_ ) const;

/**
 * Revokes a proc-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionProcResponse revokePermissionProc( const RevokePermissionProcRequest& request_ ) const;

/**
 * Revokes a proc-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionProcResponse& revokePermissionProc( const RevokePermissionProcRequest& request_,
                                                    RevokePermissionProcResponse& response_ ) const;

/**
 * Revokes a proc-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li> gpudb::revoke_permission_proc_proc_admin:
 *                    Admin access to the proc.
 *                            <li> gpudb::revoke_permission_proc_proc_execute:
 *                    Execute access to the proc.
 *                    </ul>
 * @param procName  Name of the proc to which the permission grants access.
 *                  Must be an existing proc, or an empty string if the
 *                  permission grants access to all procs.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionProcResponse revokePermissionProc( const std::string& name,
                                                   const std::string& permission,
                                                   const std::string& procName,
                                                   const std::map<std::string, std::string>& options ) const;

/**
 * Revokes a proc-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li> gpudb::revoke_permission_proc_proc_admin:
 *                    Admin access to the proc.
 *                            <li> gpudb::revoke_permission_proc_proc_execute:
 *                    Execute access to the proc.
 *                    </ul>
 * @param procName  Name of the proc to which the permission grants access.
 *                  Must be an existing proc, or an empty string if the
 *                  permission grants access to all procs.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionProcResponse& revokePermissionProc( const std::string& name,
                                                    const std::string& permission,
                                                    const std::string& procName,
                                                    const std::map<std::string, std::string>& options,
                                                    RevokePermissionProcResponse& response_ ) const;

/**
 * Revokes a system-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionSystemResponse revokePermissionSystem( const RevokePermissionSystemRequest& request_ ) const;

/**
 * Revokes a system-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionSystemResponse& revokePermissionSystem( const RevokePermissionSystemRequest& request_,
                                                        RevokePermissionSystemResponse& response_ ) const;

/**
 * Revokes a system-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li>
 *                    gpudb::revoke_permission_system_system_admin: Full access
 *                    to all data and system functions.
 *                            <li>
 *                    gpudb::revoke_permission_system_system_user_admin: Access
 *                    to administer users and roles that do not have
 *                    system_admin permission.
 *                            <li>
 *                    gpudb::revoke_permission_system_system_write: Read and
 *                    write access to all tables.
 *                            <li> gpudb::revoke_permission_system_system_read:
 *                    Read-only access to all tables.
 *                    </ul>
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionSystemResponse revokePermissionSystem( const std::string& name,
                                                       const std::string& permission,
                                                       const std::map<std::string, std::string>& options ) const;

/**
 * Revokes a system-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li>
 *                    gpudb::revoke_permission_system_system_admin: Full access
 *                    to all data and system functions.
 *                            <li>
 *                    gpudb::revoke_permission_system_system_user_admin: Access
 *                    to administer users and roles that do not have
 *                    system_admin permission.
 *                            <li>
 *                    gpudb::revoke_permission_system_system_write: Read and
 *                    write access to all tables.
 *                            <li> gpudb::revoke_permission_system_system_read:
 *                    Read-only access to all tables.
 *                    </ul>
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionSystemResponse& revokePermissionSystem( const std::string& name,
                                                        const std::string& permission,
                                                        const std::map<std::string, std::string>& options,
                                                        RevokePermissionSystemResponse& response_ ) const;

/**
 * Revokes a table-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionTableResponse revokePermissionTable( const RevokePermissionTableRequest& request_ ) const;

/**
 * Revokes a table-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionTableResponse& revokePermissionTable( const RevokePermissionTableRequest& request_,
                                                      RevokePermissionTableResponse& response_ ) const;

/**
 * Revokes a table-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li> gpudb::revoke_permission_table_table_admin:
 *                    Full read/write and administrative access to the table.
 *                            <li> gpudb::revoke_permission_table_table_insert:
 *                    Insert access to the table.
 *                            <li> gpudb::revoke_permission_table_table_update:
 *                    Update access to the table.
 *                            <li> gpudb::revoke_permission_table_table_delete:
 *                    Delete access to the table.
 *                            <li> gpudb::revoke_permission_table_table_read:
 *                    Read access to the table.
 *                    </ul>
 * @param tableName  Name of the table to which the permission grants access,
 *                   in [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table, view or schema.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::revoke_permission_table_columns: Apply
 *                 security to these columns, comma-separated.  The default
 *                 value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionTableResponse revokePermissionTable( const std::string& name,
                                                     const std::string& permission,
                                                     const std::string& tableName,
                                                     const std::map<std::string, std::string>& options ) const;

/**
 * Revokes a table-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li> gpudb::revoke_permission_table_table_admin:
 *                    Full read/write and administrative access to the table.
 *                            <li> gpudb::revoke_permission_table_table_insert:
 *                    Insert access to the table.
 *                            <li> gpudb::revoke_permission_table_table_update:
 *                    Update access to the table.
 *                            <li> gpudb::revoke_permission_table_table_delete:
 *                    Delete access to the table.
 *                            <li> gpudb::revoke_permission_table_table_read:
 *                    Read access to the table.
 *                    </ul>
 * @param tableName  Name of the table to which the permission grants access,
 *                   in [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing table, view or schema.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::revoke_permission_table_columns: Apply
 *                 security to these columns, comma-separated.  The default
 *                 value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionTableResponse& revokePermissionTable( const std::string& name,
                                                      const std::string& permission,
                                                      const std::string& tableName,
                                                      const std::map<std::string, std::string>& options,
                                                      RevokePermissionTableResponse& response_ ) const;

/**
 * Revokes membership in a role from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokeRoleResponse revokeRole( const RevokeRoleRequest& request_ ) const;

/**
 * Revokes membership in a role from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokeRoleResponse& revokeRole( const RevokeRoleRequest& request_,
                                RevokeRoleResponse& response_ ) const;

/**
 * Revokes membership in a role from a user or role.
 * 
 * @param role  Name of the role in which membership will be revoked. Must be
 *              an existing role.
 * @param member  Name of the user or role that will be revoked membership in
 *                @a role. Must be an existing user or role.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokeRoleResponse revokeRole( const std::string& role,
                               const std::string& member,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Revokes membership in a role from a user or role.
 * 
 * @param role  Name of the role in which membership will be revoked. Must be
 *              an existing role.
 * @param member  Name of the user or role that will be revoked membership in
 *                @a role. Must be an existing user or role.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokeRoleResponse& revokeRole( const std::string& role,
                                const std::string& member,
                                const std::map<std::string, std::string>& options,
                                RevokeRoleResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowContainerRegistryResponse showContainerRegistry( const ShowContainerRegistryRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowContainerRegistryResponse& showContainerRegistry( const ShowContainerRegistryRequest& request_,
                                                      ShowContainerRegistryResponse& response_ ) const;

/**
 * @private
 * 
 * @param registryName
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowContainerRegistryResponse showContainerRegistry( const std::string& registryName,
                                                     const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param registryName
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowContainerRegistryResponse& showContainerRegistry( const std::string& registryName,
                                                      const std::map<std::string, std::string>& options,
                                                      ShowContainerRegistryResponse& response_ ) const;

/**
 * Shows information about a specified <a href="../../../concepts/credentials/"
 * target="_top">credential</a> or all credentials.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowCredentialResponse showCredential( const ShowCredentialRequest& request_ ) const;

/**
 * Shows information about a specified <a href="../../../concepts/credentials/"
 * target="_top">credential</a> or all credentials.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowCredentialResponse& showCredential( const ShowCredentialRequest& request_,
                                        ShowCredentialResponse& response_ ) const;

/**
 * Shows information about a specified <a href="../../../concepts/credentials/"
 * target="_top">credential</a> or all credentials.
 * 
 * @param credentialName  Name of the credential on which to retrieve
 *                        information. The name must refer to a currently
 *                        existing credential. If '*' is specified, information
 *                        about all credentials will be returned.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowCredentialResponse showCredential( const std::string& credentialName,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Shows information about a specified <a href="../../../concepts/credentials/"
 * target="_top">credential</a> or all credentials.
 * 
 * @param credentialName  Name of the credential on which to retrieve
 *                        information. The name must refer to a currently
 *                        existing credential. If '*' is specified, information
 *                        about all credentials will be returned.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowCredentialResponse& showCredential( const std::string& credentialName,
                                        const std::map<std::string, std::string>& options,
                                        ShowCredentialResponse& response_ ) const;

/**
 * Shows information about a specified <a href="../../../concepts/data_sinks/"
 * target="_top">data sink</a> or all data sinks.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowDatasinkResponse showDatasink( const ShowDatasinkRequest& request_ ) const;

/**
 * Shows information about a specified <a href="../../../concepts/data_sinks/"
 * target="_top">data sink</a> or all data sinks.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowDatasinkResponse& showDatasink( const ShowDatasinkRequest& request_,
                                    ShowDatasinkResponse& response_ ) const;

/**
 * Shows information about a specified <a href="../../../concepts/data_sinks/"
 * target="_top">data sink</a> or all data sinks.
 * 
 * @param name  Name of the data sink for which to retrieve information. The
 *              name must refer to a currently existing data sink. If '*' is
 *              specified, information about all data sinks will be returned.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowDatasinkResponse showDatasink( const std::string& name,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Shows information about a specified <a href="../../../concepts/data_sinks/"
 * target="_top">data sink</a> or all data sinks.
 * 
 * @param name  Name of the data sink for which to retrieve information. The
 *              name must refer to a currently existing data sink. If '*' is
 *              specified, information about all data sinks will be returned.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowDatasinkResponse& showDatasink( const std::string& name,
                                    const std::map<std::string, std::string>& options,
                                    ShowDatasinkResponse& response_ ) const;

/**
 * Shows information about a specified <a
 * href="../../../concepts/data_sources/" target="_top">data source</a> or all
 * data sources.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowDatasourceResponse showDatasource( const ShowDatasourceRequest& request_ ) const;

/**
 * Shows information about a specified <a
 * href="../../../concepts/data_sources/" target="_top">data source</a> or all
 * data sources.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowDatasourceResponse& showDatasource( const ShowDatasourceRequest& request_,
                                        ShowDatasourceResponse& response_ ) const;

/**
 * Shows information about a specified <a
 * href="../../../concepts/data_sources/" target="_top">data source</a> or all
 * data sources.
 * 
 * @param name  Name of the data source for which to retrieve information. The
 *              name must refer to a currently existing data source. If '*' is
 *              specified, information about all data sources will be returned.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowDatasourceResponse showDatasource( const std::string& name,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Shows information about a specified <a
 * href="../../../concepts/data_sources/" target="_top">data source</a> or all
 * data sources.
 * 
 * @param name  Name of the data source for which to retrieve information. The
 *              name must refer to a currently existing data source. If '*' is
 *              specified, information about all data sources will be returned.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowDatasourceResponse& showDatasource( const std::string& name,
                                        const std::map<std::string, std::string>& options,
                                        ShowDatasourceResponse& response_ ) const;

/**
 * Shows information about directories in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. Can be used to show a single directory, or all
 * directories.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowDirectoriesResponse showDirectories( const ShowDirectoriesRequest& request_ ) const;

/**
 * Shows information about directories in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. Can be used to show a single directory, or all
 * directories.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowDirectoriesResponse& showDirectories( const ShowDirectoriesRequest& request_,
                                          ShowDirectoriesResponse& response_ ) const;

/**
 * Shows information about directories in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. Can be used to show a single directory, or all
 * directories.
 * 
 * @param directoryName  The KiFS directory name to show. If empty, shows all
 *                       directories.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowDirectoriesResponse showDirectories( const std::string& directoryName,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Shows information about directories in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. Can be used to show a single directory, or all
 * directories.
 * 
 * @param directoryName  The KiFS directory name to show. If empty, shows all
 *                       directories.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowDirectoriesResponse& showDirectories( const std::string& directoryName,
                                          const std::map<std::string, std::string>& options,
                                          ShowDirectoriesResponse& response_ ) const;

/**
 * Shows information about a specified <a href="../../../concepts/udf/"
 * target="_top">user-defined function</a> (UDF) environment or all
 * environments.
 * Returns detailed information about existing environments.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowEnvironmentResponse showEnvironment( const ShowEnvironmentRequest& request_ ) const;

/**
 * Shows information about a specified <a href="../../../concepts/udf/"
 * target="_top">user-defined function</a> (UDF) environment or all
 * environments.
 * Returns detailed information about existing environments.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowEnvironmentResponse& showEnvironment( const ShowEnvironmentRequest& request_,
                                          ShowEnvironmentResponse& response_ ) const;

/**
 * Shows information about a specified <a href="../../../concepts/udf/"
 * target="_top">user-defined function</a> (UDF) environment or all
 * environments.
 * Returns detailed information about existing environments.
 * 
 * @param environmentName  Name of the environment on which to retrieve
 *                         information. The name must refer to a currently
 *                         existing environment. If '*' or an empty value is
 *                         specified, information about all environments will
 *                         be returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_environment_no_error_if_not_exists:
 *                 If @a true and if the environment specified in @a
 *                 environmentName does not exist, no error is returned. If @a
 *                 false and if the environment specified in @a environmentName
 *                 does not exist, then an error is returned.
 *                 <ul>
 *                         <li> gpudb::show_environment_true
 *                         <li> gpudb::show_environment_false
 *                 </ul>
 *                 The default value is gpudb::show_environment_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowEnvironmentResponse showEnvironment( const std::string& environmentName,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Shows information about a specified <a href="../../../concepts/udf/"
 * target="_top">user-defined function</a> (UDF) environment or all
 * environments.
 * Returns detailed information about existing environments.
 * 
 * @param environmentName  Name of the environment on which to retrieve
 *                         information. The name must refer to a currently
 *                         existing environment. If '*' or an empty value is
 *                         specified, information about all environments will
 *                         be returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_environment_no_error_if_not_exists:
 *                 If @a true and if the environment specified in @a
 *                 environmentName does not exist, no error is returned. If @a
 *                 false and if the environment specified in @a environmentName
 *                 does not exist, then an error is returned.
 *                 <ul>
 *                         <li> gpudb::show_environment_true
 *                         <li> gpudb::show_environment_false
 *                 </ul>
 *                 The default value is gpudb::show_environment_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowEnvironmentResponse& showEnvironment( const std::string& environmentName,
                                          const std::map<std::string, std::string>& options,
                                          ShowEnvironmentResponse& response_ ) const;

/**
 * Shows information about files in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. Can be used for individual files, or to show all
 * files in a given directory.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowFilesResponse showFiles( const ShowFilesRequest& request_ ) const;

/**
 * Shows information about files in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. Can be used for individual files, or to show all
 * files in a given directory.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowFilesResponse& showFiles( const ShowFilesRequest& request_,
                              ShowFilesResponse& response_ ) const;

/**
 * Shows information about files in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. Can be used for individual files, or to show all
 * files in a given directory.
 * 
 * @param paths  File paths to show. Each path can be a KiFS directory name, or
 *               a full path to a KiFS file. File paths may contain wildcard
 *               characters after the KiFS directory delimeter.
 *               Accepted wildcard characters are asterisk (*) to represent any
 *               string of zero or more characters, and question mark (?) to
 *               indicate a single character.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowFilesResponse showFiles( const std::vector<std::string>& paths,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Shows information about files in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. Can be used for individual files, or to show all
 * files in a given directory.
 * 
 * @param paths  File paths to show. Each path can be a KiFS directory name, or
 *               a full path to a KiFS file. File paths may contain wildcard
 *               characters after the KiFS directory delimeter.
 *               Accepted wildcard characters are asterisk (*) to represent any
 *               string of zero or more characters, and question mark (?) to
 *               indicate a single character.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowFilesResponse& showFiles( const std::vector<std::string>& paths,
                              const std::map<std::string, std::string>& options,
                              ShowFilesResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowFunctionsResponse showFunctions( const ShowFunctionsRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowFunctionsResponse& showFunctions( const ShowFunctionsRequest& request_,
                                      ShowFunctionsResponse& response_ ) const;

/**
 * @private
 * 
 * @param names
 * @param options
 *                 <ul>
 *                         <li> gpudb::show_functions_properties
 *                         <li> gpudb::show_functions_show_scalar_functions:
 *                 <ul>
 *                         <li> gpudb::show_functions_true
 *                         <li> gpudb::show_functions_false
 *                 </ul>
 *                 The default value is gpudb::show_functions_true.
 *                         <li> gpudb::show_functions_show_aggregate_functions:
 *                 <ul>
 *                         <li> gpudb::show_functions_true
 *                         <li> gpudb::show_functions_false
 *                 </ul>
 *                 The default value is gpudb::show_functions_true.
 *                         <li> gpudb::show_functions_show_sql_procedures:
 *                 <ul>
 *                         <li> gpudb::show_functions_true
 *                         <li> gpudb::show_functions_false
 *                 </ul>
 *                 The default value is gpudb::show_functions_true.
 *                         <li>
 *                 gpudb::show_functions_show_user_defined_functions:
 *                 <ul>
 *                         <li> gpudb::show_functions_true
 *                         <li> gpudb::show_functions_false
 *                 </ul>
 *                 The default value is gpudb::show_functions_true.
 *                         <li> gpudb::show_functions_show_cast_functions:
 *                 <ul>
 *                         <li> gpudb::show_functions_true
 *                         <li> gpudb::show_functions_false
 *                 </ul>
 *                 The default value is gpudb::show_functions_true.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowFunctionsResponse showFunctions( const std::vector<std::string>& names,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param names
 * @param options
 *                 <ul>
 *                         <li> gpudb::show_functions_properties
 *                         <li> gpudb::show_functions_show_scalar_functions:
 *                 <ul>
 *                         <li> gpudb::show_functions_true
 *                         <li> gpudb::show_functions_false
 *                 </ul>
 *                 The default value is gpudb::show_functions_true.
 *                         <li> gpudb::show_functions_show_aggregate_functions:
 *                 <ul>
 *                         <li> gpudb::show_functions_true
 *                         <li> gpudb::show_functions_false
 *                 </ul>
 *                 The default value is gpudb::show_functions_true.
 *                         <li> gpudb::show_functions_show_sql_procedures:
 *                 <ul>
 *                         <li> gpudb::show_functions_true
 *                         <li> gpudb::show_functions_false
 *                 </ul>
 *                 The default value is gpudb::show_functions_true.
 *                         <li>
 *                 gpudb::show_functions_show_user_defined_functions:
 *                 <ul>
 *                         <li> gpudb::show_functions_true
 *                         <li> gpudb::show_functions_false
 *                 </ul>
 *                 The default value is gpudb::show_functions_true.
 *                         <li> gpudb::show_functions_show_cast_functions:
 *                 <ul>
 *                         <li> gpudb::show_functions_true
 *                         <li> gpudb::show_functions_false
 *                 </ul>
 *                 The default value is gpudb::show_functions_true.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowFunctionsResponse& showFunctions( const std::vector<std::string>& names,
                                      const std::map<std::string, std::string>& options,
                                      ShowFunctionsResponse& response_ ) const;

/**
 * Shows information and characteristics of graphs that exist on the graph
 * server.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowGraphResponse showGraph( const ShowGraphRequest& request_ ) const;

/**
 * Shows information and characteristics of graphs that exist on the graph
 * server.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowGraphResponse& showGraph( const ShowGraphRequest& request_,
                              ShowGraphResponse& response_ ) const;

/**
 * Shows information and characteristics of graphs that exist on the graph
 * server.
 * 
 * @param graphName  Name of the graph on which to retrieve information. If
 *                   left as the default value, information about all graphs is
 *                   returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_graph_show_original_request: If set
 *                 to @a true, the request that was originally used to create
 *                 the graph is also returned as JSON.
 *                 <ul>
 *                         <li> gpudb::show_graph_true
 *                         <li> gpudb::show_graph_false
 *                 </ul>
 *                 The default value is gpudb::show_graph_true.
 *                         <li> gpudb::show_graph_server_id: Indicates which
 *                 graph server(s) to send the request to. Default is to send
 *                 to get information about all the servers.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowGraphResponse showGraph( const std::string& graphName,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Shows information and characteristics of graphs that exist on the graph
 * server.
 * 
 * @param graphName  Name of the graph on which to retrieve information. If
 *                   left as the default value, information about all graphs is
 *                   returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_graph_show_original_request: If set
 *                 to @a true, the request that was originally used to create
 *                 the graph is also returned as JSON.
 *                 <ul>
 *                         <li> gpudb::show_graph_true
 *                         <li> gpudb::show_graph_false
 *                 </ul>
 *                 The default value is gpudb::show_graph_true.
 *                         <li> gpudb::show_graph_server_id: Indicates which
 *                 graph server(s) to send the request to. Default is to send
 *                 to get information about all the servers.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowGraphResponse& showGraph( const std::string& graphName,
                              const std::map<std::string, std::string>& options,
                              ShowGraphResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowGraphGrammarResponse showGraphGrammar( const ShowGraphGrammarRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowGraphGrammarResponse& showGraphGrammar( const ShowGraphGrammarRequest& request_,
                                            ShowGraphGrammarResponse& response_ ) const;

/**
 * @private
 * 
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowGraphGrammarResponse showGraphGrammar( const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowGraphGrammarResponse& showGraphGrammar( const std::map<std::string, std::string>& options,
                                            ShowGraphGrammarResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowModelResponse showModel( const ShowModelRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowModelResponse& showModel( const ShowModelRequest& request_,
                              ShowModelResponse& response_ ) const;

/**
 * @private
 * 
 * @param modelNames
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowModelResponse showModel( const std::vector<std::string>& modelNames,
                             const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param modelNames
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowModelResponse& showModel( const std::vector<std::string>& modelNames,
                              const std::map<std::string, std::string>& options,
                              ShowModelResponse& response_ ) const;

/**
 * Shows information about a proc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowProcResponse showProc( const ShowProcRequest& request_ ) const;

/**
 * Shows information about a proc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowProcResponse& showProc( const ShowProcRequest& request_,
                            ShowProcResponse& response_ ) const;

/**
 * Shows information about a proc.
 * 
 * @param procName  Name of the proc to show information about. If specified,
 *                  must be the name of a currently existing proc. If not
 *                  specified, information about all procs will be returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_proc_include_files: If set to @a
 *                 true, the files that make up the proc will be returned. If
 *                 set to @a false, the files will not be returned.
 *                 <ul>
 *                         <li> gpudb::show_proc_true
 *                         <li> gpudb::show_proc_false
 *                 </ul>
 *                 The default value is gpudb::show_proc_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowProcResponse showProc( const std::string& procName,
                           const std::map<std::string, std::string>& options ) const;

/**
 * Shows information about a proc.
 * 
 * @param procName  Name of the proc to show information about. If specified,
 *                  must be the name of a currently existing proc. If not
 *                  specified, information about all procs will be returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_proc_include_files: If set to @a
 *                 true, the files that make up the proc will be returned. If
 *                 set to @a false, the files will not be returned.
 *                 <ul>
 *                         <li> gpudb::show_proc_true
 *                         <li> gpudb::show_proc_false
 *                 </ul>
 *                 The default value is gpudb::show_proc_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowProcResponse& showProc( const std::string& procName,
                            const std::map<std::string, std::string>& options,
                            ShowProcResponse& response_ ) const;

/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@link
 * #executeProc(const ExecuteProcRequest&) const}) and data segment ID
 * (each invocation of the proc command on a data segment is assigned a data
 * segment ID).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowProcStatusResponse showProcStatus( const ShowProcStatusRequest& request_ ) const;

/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@link
 * #executeProc(const ExecuteProcRequest&,ExecuteProcResponse&) const}) and
 * data segment ID (each invocation of the proc command on a data segment is
 * assigned a data segment ID).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowProcStatusResponse& showProcStatus( const ShowProcStatusRequest& request_,
                                        ShowProcStatusResponse& response_ ) const;

/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@link
 * #executeProc(const std::string&,const std::map<std::string, std::string>&,const std::map<std::string, std::vector<uint8_t> >&,const std::vector<std::string>&,const std::map<std::string, std::vector<std::string> >&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const})
 * and data segment ID (each invocation of the proc command on a data segment
 * is assigned a data segment ID).
 * 
 * @param runId  The run ID of a specific proc instance for which the status
 *               will be returned. If a proc with a matching run ID is not
 *               found, the response will be empty. If not specified, the
 *               statuses of all executed proc instances will be returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_proc_status_clear_complete: If set
 *                 to @a true, if a proc instance has completed (either
 *                 successfully or unsuccessfully) then its status will be
 *                 cleared and no longer returned in subsequent calls.
 *                 <ul>
 *                         <li> gpudb::show_proc_status_true
 *                         <li> gpudb::show_proc_status_false
 *                 </ul>
 *                 The default value is gpudb::show_proc_status_false.
 *                         <li> gpudb::show_proc_status_run_tag: If @a runId is
 *                 specified, return the status for a proc instance that has a
 *                 matching run ID and a matching run tag that was provided to
 *                 /execute/proc. If @a runId is not specified, return statuses
 *                 for all proc instances where a matching run tag was provided
 *                 to /execute/proc.  The default value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowProcStatusResponse showProcStatus( const std::string& runId,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@link
 * #executeProc(const std::string&,const std::map<std::string, std::string>&,const std::map<std::string, std::vector<uint8_t> >&,const std::vector<std::string>&,const std::map<std::string, std::vector<std::string> >&,const std::vector<std::string>&,const std::map<std::string, std::string>&,ExecuteProcResponse&) const})
 * and data segment ID (each invocation of the proc command on a data segment
 * is assigned a data segment ID).
 * 
 * @param runId  The run ID of a specific proc instance for which the status
 *               will be returned. If a proc with a matching run ID is not
 *               found, the response will be empty. If not specified, the
 *               statuses of all executed proc instances will be returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_proc_status_clear_complete: If set
 *                 to @a true, if a proc instance has completed (either
 *                 successfully or unsuccessfully) then its status will be
 *                 cleared and no longer returned in subsequent calls.
 *                 <ul>
 *                         <li> gpudb::show_proc_status_true
 *                         <li> gpudb::show_proc_status_false
 *                 </ul>
 *                 The default value is gpudb::show_proc_status_false.
 *                         <li> gpudb::show_proc_status_run_tag: If @a runId is
 *                 specified, return the status for a proc instance that has a
 *                 matching run ID and a matching run tag that was provided to
 *                 /execute/proc. If @a runId is not specified, return statuses
 *                 for all proc instances where a matching run tag was provided
 *                 to /execute/proc.  The default value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowProcStatusResponse& showProcStatus( const std::string& runId,
                                        const std::map<std::string, std::string>& options,
                                        ShowProcStatusResponse& response_ ) const;

/**
 * Returns information about the internal sub-components (tiered objects)
 * which use resources of the system. The request can either return results
 * from
 * actively used objects (default) or it can be used to query the status of the
 * objects of a given list of tables.
 * Returns detailed information about the requested resource objects.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowResourceObjectsResponse showResourceObjects( const ShowResourceObjectsRequest& request_ ) const;

/**
 * Returns information about the internal sub-components (tiered objects)
 * which use resources of the system. The request can either return results
 * from
 * actively used objects (default) or it can be used to query the status of the
 * objects of a given list of tables.
 * Returns detailed information about the requested resource objects.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowResourceObjectsResponse& showResourceObjects( const ShowResourceObjectsRequest& request_,
                                                  ShowResourceObjectsResponse& response_ ) const;

/**
 * Returns information about the internal sub-components (tiered objects)
 * which use resources of the system. The request can either return results
 * from
 * actively used objects (default) or it can be used to query the status of the
 * objects of a given list of tables.
 * Returns detailed information about the requested resource objects.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_resource_objects_tiers:
 *                 Comma-separated list of tiers to query, leave blank for all
 *                 tiers.
 *                         <li> gpudb::show_resource_objects_expression: An
 *                 expression to filter the returned objects. Expression is
 *                 limited to the following operators:
 *                 =,!=,<,<=,>,>=,+,-,*,AND,OR,LIKE. For details see
 *                 <a href="../../../concepts/expressions/"
 *                 target="_top">Expressions</a>. To use a more complex
 *                 expression, query the
 *                 ki_catalog.ki_tiered_objects table directly.
 *                         <li> gpudb::show_resource_objects_order_by: Single
 *                 column to be sorted by as well as the sort direction, e.g.,
 *                 'size asc'.
 *                 <ul>
 *                         <li> gpudb::show_resource_objects_size
 *                         <li> gpudb::show_resource_objects_id
 *                         <li> gpudb::show_resource_objects_priority
 *                         <li> gpudb::show_resource_objects_tier
 *                         <li> gpudb::show_resource_objects_evictable
 *                         <li>
 *                 gpudb::show_resource_objects_owner_resource_group
 *                 </ul>
 *                         <li> gpudb::show_resource_objects_limit: An integer
 *                 indicating the maximum number of results to be
 *                 returned, per rank, or (-1) to indicate that the maximum
 *                 number of results allowed by the server
 *                 should be returned.  The number of records returned will
 *                 never exceed the server's own limit,
 *                 defined by the <a
 *                 href="../../../config/#config-main-general"
 *                 target="_top">max_get_records_size</a> parameter in the
 *                 server
 *                 configuration.  The default value is '100'.
 *                         <li> gpudb::show_resource_objects_table_names:
 *                 Comma-separated list of tables to restrict the results to.
 *                 Use '*' to show all tables.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowResourceObjectsResponse showResourceObjects( const std::map<std::string, std::string>& options ) const;

/**
 * Returns information about the internal sub-components (tiered objects)
 * which use resources of the system. The request can either return results
 * from
 * actively used objects (default) or it can be used to query the status of the
 * objects of a given list of tables.
 * Returns detailed information about the requested resource objects.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_resource_objects_tiers:
 *                 Comma-separated list of tiers to query, leave blank for all
 *                 tiers.
 *                         <li> gpudb::show_resource_objects_expression: An
 *                 expression to filter the returned objects. Expression is
 *                 limited to the following operators:
 *                 =,!=,<,<=,>,>=,+,-,*,AND,OR,LIKE. For details see
 *                 <a href="../../../concepts/expressions/"
 *                 target="_top">Expressions</a>. To use a more complex
 *                 expression, query the
 *                 ki_catalog.ki_tiered_objects table directly.
 *                         <li> gpudb::show_resource_objects_order_by: Single
 *                 column to be sorted by as well as the sort direction, e.g.,
 *                 'size asc'.
 *                 <ul>
 *                         <li> gpudb::show_resource_objects_size
 *                         <li> gpudb::show_resource_objects_id
 *                         <li> gpudb::show_resource_objects_priority
 *                         <li> gpudb::show_resource_objects_tier
 *                         <li> gpudb::show_resource_objects_evictable
 *                         <li>
 *                 gpudb::show_resource_objects_owner_resource_group
 *                 </ul>
 *                         <li> gpudb::show_resource_objects_limit: An integer
 *                 indicating the maximum number of results to be
 *                 returned, per rank, or (-1) to indicate that the maximum
 *                 number of results allowed by the server
 *                 should be returned.  The number of records returned will
 *                 never exceed the server's own limit,
 *                 defined by the <a
 *                 href="../../../config/#config-main-general"
 *                 target="_top">max_get_records_size</a> parameter in the
 *                 server
 *                 configuration.  The default value is '100'.
 *                         <li> gpudb::show_resource_objects_table_names:
 *                 Comma-separated list of tables to restrict the results to.
 *                 Use '*' to show all tables.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowResourceObjectsResponse& showResourceObjects( const std::map<std::string, std::string>& options,
                                                  ShowResourceObjectsResponse& response_ ) const;

/**
 * Requests various statistics for storage/memory tiers and resource groups.
 * Returns statistics on a per-rank basis.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowResourceStatisticsResponse showResourceStatistics( const ShowResourceStatisticsRequest& request_ ) const;

/**
 * Requests various statistics for storage/memory tiers and resource groups.
 * Returns statistics on a per-rank basis.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowResourceStatisticsResponse& showResourceStatistics( const ShowResourceStatisticsRequest& request_,
                                                        ShowResourceStatisticsResponse& response_ ) const;

/**
 * Requests various statistics for storage/memory tiers and resource groups.
 * Returns statistics on a per-rank basis.
 * 
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowResourceStatisticsResponse showResourceStatistics( const std::map<std::string, std::string>& options ) const;

/**
 * Requests various statistics for storage/memory tiers and resource groups.
 * Returns statistics on a per-rank basis.
 * 
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowResourceStatisticsResponse& showResourceStatistics( const std::map<std::string, std::string>& options,
                                                        ShowResourceStatisticsResponse& response_ ) const;

/**
 * Requests resource group properties.
 * Returns detailed information about the requested resource groups.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowResourceGroupsResponse showResourceGroups( const ShowResourceGroupsRequest& request_ ) const;

/**
 * Requests resource group properties.
 * Returns detailed information about the requested resource groups.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowResourceGroupsResponse& showResourceGroups( const ShowResourceGroupsRequest& request_,
                                                ShowResourceGroupsResponse& response_ ) const;

/**
 * Requests resource group properties.
 * Returns detailed information about the requested resource groups.
 * 
 * @param names  List of names of groups to be shown. A single entry with an
 *               empty string returns all groups.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::show_resource_groups_show_default_values: If @a true
 *                 include values of fields that are based on the default
 *                 resource group.
 *                 <ul>
 *                         <li> gpudb::show_resource_groups_true
 *                         <li> gpudb::show_resource_groups_false
 *                 </ul>
 *                 The default value is gpudb::show_resource_groups_true.
 *                         <li> gpudb::show_resource_groups_show_default_group:
 *                 If @a true include the default and system resource groups in
 *                 the response. This value defaults to false if an explicit
 *                 list of group names is provided, and true otherwise.
 *                 <ul>
 *                         <li> gpudb::show_resource_groups_true
 *                         <li> gpudb::show_resource_groups_false
 *                 </ul>
 *                 The default value is gpudb::show_resource_groups_true.
 *                         <li> gpudb::show_resource_groups_show_tier_usage: If
 *                 @a true include the resource group usage on the worker ranks
 *                 in the response.
 *                 <ul>
 *                         <li> gpudb::show_resource_groups_true
 *                         <li> gpudb::show_resource_groups_false
 *                 </ul>
 *                 The default value is gpudb::show_resource_groups_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowResourceGroupsResponse showResourceGroups( const std::vector<std::string>& names,
                                               const std::map<std::string, std::string>& options ) const;

/**
 * Requests resource group properties.
 * Returns detailed information about the requested resource groups.
 * 
 * @param names  List of names of groups to be shown. A single entry with an
 *               empty string returns all groups.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::show_resource_groups_show_default_values: If @a true
 *                 include values of fields that are based on the default
 *                 resource group.
 *                 <ul>
 *                         <li> gpudb::show_resource_groups_true
 *                         <li> gpudb::show_resource_groups_false
 *                 </ul>
 *                 The default value is gpudb::show_resource_groups_true.
 *                         <li> gpudb::show_resource_groups_show_default_group:
 *                 If @a true include the default and system resource groups in
 *                 the response. This value defaults to false if an explicit
 *                 list of group names is provided, and true otherwise.
 *                 <ul>
 *                         <li> gpudb::show_resource_groups_true
 *                         <li> gpudb::show_resource_groups_false
 *                 </ul>
 *                 The default value is gpudb::show_resource_groups_true.
 *                         <li> gpudb::show_resource_groups_show_tier_usage: If
 *                 @a true include the resource group usage on the worker ranks
 *                 in the response.
 *                 <ul>
 *                         <li> gpudb::show_resource_groups_true
 *                         <li> gpudb::show_resource_groups_false
 *                 </ul>
 *                 The default value is gpudb::show_resource_groups_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowResourceGroupsResponse& showResourceGroups( const std::vector<std::string>& names,
                                                const std::map<std::string, std::string>& options,
                                                ShowResourceGroupsResponse& response_ ) const;

/**
 * Retrieves information about a <a href="../../../concepts/schemas/"
 * target="_top">schema</a> (or all schemas), as specified in @a schemaName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSchemaResponse showSchema( const ShowSchemaRequest& request_ ) const;

/**
 * Retrieves information about a <a href="../../../concepts/schemas/"
 * target="_top">schema</a> (or all schemas), as specified in @a schemaName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSchemaResponse& showSchema( const ShowSchemaRequest& request_,
                                ShowSchemaResponse& response_ ) const;

/**
 * Retrieves information about a <a href="../../../concepts/schemas/"
 * target="_top">schema</a> (or all schemas), as specified in @a schemaName.
 * 
 * @param schemaName  Name of the schema for which to retrieve the information.
 *                    If blank, then info for all schemas is returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_schema_no_error_if_not_exists: If
 *                 @a false will return an error if the provided @a schemaName
 *                 does not exist. If @a true then it will return an empty
 *                 result if the provided @a schemaName does not exist.
 *                 <ul>
 *                         <li> gpudb::show_schema_true
 *                         <li> gpudb::show_schema_false
 *                 </ul>
 *                 The default value is gpudb::show_schema_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSchemaResponse showSchema( const std::string& schemaName,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Retrieves information about a <a href="../../../concepts/schemas/"
 * target="_top">schema</a> (or all schemas), as specified in @a schemaName.
 * 
 * @param schemaName  Name of the schema for which to retrieve the information.
 *                    If blank, then info for all schemas is returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_schema_no_error_if_not_exists: If
 *                 @a false will return an error if the provided @a schemaName
 *                 does not exist. If @a true then it will return an empty
 *                 result if the provided @a schemaName does not exist.
 *                 <ul>
 *                         <li> gpudb::show_schema_true
 *                         <li> gpudb::show_schema_false
 *                 </ul>
 *                 The default value is gpudb::show_schema_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSchemaResponse& showSchema( const std::string& schemaName,
                                const std::map<std::string, std::string>& options,
                                ShowSchemaResponse& response_ ) const;

/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSecurityResponse showSecurity( const ShowSecurityRequest& request_ ) const;

/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSecurityResponse& showSecurity( const ShowSecurityRequest& request_,
                                    ShowSecurityResponse& response_ ) const;

/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 * 
 * @param names  A list of names of users and/or roles about which security
 *               information is requested. If none are provided, information
 *               about all users and roles will be returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_security_show_current_user: If @a
 *                 true, returns only security information for the current
 *                 user.
 *                 <ul>
 *                         <li> gpudb::show_security_true
 *                         <li> gpudb::show_security_false
 *                 </ul>
 *                 The default value is gpudb::show_security_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSecurityResponse showSecurity( const std::vector<std::string>& names,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 * 
 * @param names  A list of names of users and/or roles about which security
 *               information is requested. If none are provided, information
 *               about all users and roles will be returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_security_show_current_user: If @a
 *                 true, returns only security information for the current
 *                 user.
 *                 <ul>
 *                         <li> gpudb::show_security_true
 *                         <li> gpudb::show_security_false
 *                 </ul>
 *                 The default value is gpudb::show_security_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSecurityResponse& showSecurity( const std::vector<std::string>& names,
                                    const std::map<std::string, std::string>& options,
                                    ShowSecurityResponse& response_ ) const;

/**
 * Shows information about SQL procedures, including the full definition of
 * each requested procedure.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSqlProcResponse showSqlProc( const ShowSqlProcRequest& request_ ) const;

/**
 * Shows information about SQL procedures, including the full definition of
 * each requested procedure.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSqlProcResponse& showSqlProc( const ShowSqlProcRequest& request_,
                                  ShowSqlProcResponse& response_ ) const;

/**
 * Shows information about SQL procedures, including the full definition of
 * each requested procedure.
 * 
 * @param procedureName  Name of the procedure for which to retrieve the
 *                       information. If blank, then information about all
 *                       procedures is returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_sql_proc_no_error_if_not_exists: If
 *                 @a true, no error will be returned if the requested
 *                 procedure does not exist.  If @a false, an error will be
 *                 returned if the requested procedure does not exist.
 *                 <ul>
 *                         <li> gpudb::show_sql_proc_true
 *                         <li> gpudb::show_sql_proc_false
 *                 </ul>
 *                 The default value is gpudb::show_sql_proc_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSqlProcResponse showSqlProc( const std::string& procedureName,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Shows information about SQL procedures, including the full definition of
 * each requested procedure.
 * 
 * @param procedureName  Name of the procedure for which to retrieve the
 *                       information. If blank, then information about all
 *                       procedures is returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_sql_proc_no_error_if_not_exists: If
 *                 @a true, no error will be returned if the requested
 *                 procedure does not exist.  If @a false, an error will be
 *                 returned if the requested procedure does not exist.
 *                 <ul>
 *                         <li> gpudb::show_sql_proc_true
 *                         <li> gpudb::show_sql_proc_false
 *                 </ul>
 *                 The default value is gpudb::show_sql_proc_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSqlProcResponse& showSqlProc( const std::string& procedureName,
                                  const std::map<std::string, std::string>& options,
                                  ShowSqlProcResponse& response_ ) const;

/**
 * Retrieves the collected column statistics for the specified table(s).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowStatisticsResponse showStatistics( const ShowStatisticsRequest& request_ ) const;

/**
 * Retrieves the collected column statistics for the specified table(s).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowStatisticsResponse& showStatistics( const ShowStatisticsRequest& request_,
                                        ShowStatisticsResponse& response_ ) const;

/**
 * Retrieves the collected column statistics for the specified table(s).
 * 
 * @param tableNames  Names of tables whose metadata will be fetched, each in
 *                    [schema_name.]table_name format, using standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.  All provided
 *                    tables must exist, or an error is returned.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowStatisticsResponse showStatistics( const std::vector<std::string>& tableNames,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Retrieves the collected column statistics for the specified table(s).
 * 
 * @param tableNames  Names of tables whose metadata will be fetched, each in
 *                    [schema_name.]table_name format, using standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.  All provided
 *                    tables must exist, or an error is returned.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowStatisticsResponse& showStatistics( const std::vector<std::string>& tableNames,
                                        const std::map<std::string, std::string>& options,
                                        ShowStatisticsResponse& response_ ) const;

/**
 * Returns server configuration and version related information to the caller.
 * The admin tool uses it to present server related information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemPropertiesResponse showSystemProperties( const ShowSystemPropertiesRequest& request_ ) const;

/**
 * Returns server configuration and version related information to the caller.
 * The admin tool uses it to present server related information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemPropertiesResponse& showSystemProperties( const ShowSystemPropertiesRequest& request_,
                                                    ShowSystemPropertiesResponse& response_ ) const;

/**
 * Returns server configuration and version related information to the caller.
 * The admin tool uses it to present server related information to the user.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_system_properties_properties: A
 *                 list of comma separated names of properties requested. If
 *                 not specified, all properties will be returned.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemPropertiesResponse showSystemProperties( const std::map<std::string, std::string>& options ) const;

/**
 * Returns server configuration and version related information to the caller.
 * The admin tool uses it to present server related information to the user.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_system_properties_properties: A
 *                 list of comma separated names of properties requested. If
 *                 not specified, all properties will be returned.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemPropertiesResponse& showSystemProperties( const std::map<std::string, std::string>& options,
                                                    ShowSystemPropertiesResponse& response_ ) const;

/**
 * Provides server configuration and health related status to the caller. The
 * admin tool uses it to present server related information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemStatusResponse showSystemStatus( const ShowSystemStatusRequest& request_ ) const;

/**
 * Provides server configuration and health related status to the caller. The
 * admin tool uses it to present server related information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemStatusResponse& showSystemStatus( const ShowSystemStatusRequest& request_,
                                            ShowSystemStatusResponse& response_ ) const;

/**
 * Provides server configuration and health related status to the caller. The
 * admin tool uses it to present server related information to the user.
 * 
 * @param options  Optional parameters, currently unused.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemStatusResponse showSystemStatus( const std::map<std::string, std::string>& options ) const;

/**
 * Provides server configuration and health related status to the caller. The
 * admin tool uses it to present server related information to the user.
 * 
 * @param options  Optional parameters, currently unused.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemStatusResponse& showSystemStatus( const std::map<std::string, std::string>& options,
                                            ShowSystemStatusResponse& response_ ) const;

/**
 * Returns the last 100 database requests along with the request timing and
 * internal job id. The admin tool uses it to present request timing
 * information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemTimingResponse showSystemTiming( const ShowSystemTimingRequest& request_ ) const;

/**
 * Returns the last 100 database requests along with the request timing and
 * internal job id. The admin tool uses it to present request timing
 * information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemTimingResponse& showSystemTiming( const ShowSystemTimingRequest& request_,
                                            ShowSystemTimingResponse& response_ ) const;

/**
 * Returns the last 100 database requests along with the request timing and
 * internal job id. The admin tool uses it to present request timing
 * information to the user.
 * 
 * @param options  Optional parameters, currently unused.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemTimingResponse showSystemTiming( const std::map<std::string, std::string>& options ) const;

/**
 * Returns the last 100 database requests along with the request timing and
 * internal job id. The admin tool uses it to present request timing
 * information to the user.
 * 
 * @param options  Optional parameters, currently unused.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemTimingResponse& showSystemTiming( const std::map<std::string, std::string>& options,
                                            ShowSystemTimingResponse& response_ ) const;

/**
 * Retrieves detailed information about a table, view, or schema,
 * specified in @a tableName. If the supplied @a tableName is a
 * schema the call can return information about either the schema itself or the
 * tables and views it contains. If @a tableName is empty, information about
 * all schemas will be returned.
 * <p>
 * If the option @a get_sizes is set to
 * @a true, then the number of records
 * in each table is returned (in @a sizes and
 * @a fullSizes), along with the total number of objects across all
 * requested tables (in @a totalSize and @a totalFullSize).
 * <p>
 * For a schema, setting the @a show_children option to
 * @a false returns only information
 * about the schema itself; setting @a show_children to
 * @a true returns a list of tables and
 * views contained in the schema, along with their corresponding detail.
 * <p>
 * To retrieve a list of every table, view, and schema in the database, set
 * @a tableName to '*' and @a show_children to
 * @a true.  When doing this, the
 * returned @a totalSize and @a totalFullSize will not include the sizes of
 * non-base tables (e.g., filters, views, joins, etc.).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableResponse showTable( const ShowTableRequest& request_ ) const;

/**
 * Retrieves detailed information about a table, view, or schema,
 * specified in @a tableName. If the supplied @a tableName is a
 * schema the call can return information about either the schema itself or the
 * tables and views it contains. If @a tableName is empty, information about
 * all schemas will be returned.
 * <p>
 * If the option @a get_sizes is set to
 * @a true, then the number of records
 * in each table is returned (in @a sizes and
 * @a fullSizes), along with the total number of objects across all
 * requested tables (in @a totalSize and @a totalFullSize).
 * <p>
 * For a schema, setting the @a show_children option to
 * @a false returns only information
 * about the schema itself; setting @a show_children to
 * @a true returns a list of tables and
 * views contained in the schema, along with their corresponding detail.
 * <p>
 * To retrieve a list of every table, view, and schema in the database, set
 * @a tableName to '*' and @a show_children to
 * @a true.  When doing this, the
 * returned @a totalSize and @a totalFullSize will not include the sizes of
 * non-base tables (e.g., filters, views, joins, etc.).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableResponse& showTable( const ShowTableRequest& request_,
                              ShowTableResponse& response_ ) const;

/**
 * Retrieves detailed information about a table, view, or schema,
 * specified in @a tableName. If the supplied @a tableName is a
 * schema the call can return information about either the schema itself or the
 * tables and views it contains. If @a tableName is empty, information about
 * all schemas will be returned.
 * <p>
 * If the option @a get_sizes is set to
 * @a true, then the number of records
 * in each table is returned (in @a sizes and
 * @a fullSizes), along with the total number of objects across all
 * requested tables (in @a totalSize and @a totalFullSize).
 * <p>
 * For a schema, setting the @a show_children option to
 * @a false returns only information
 * about the schema itself; setting @a show_children to
 * @a true returns a list of tables and
 * views contained in the schema, along with their corresponding detail.
 * <p>
 * To retrieve a list of every table, view, and schema in the database, set
 * @a tableName to '*' and @a show_children to
 * @a true.  When doing this, the
 * returned @a totalSize and @a totalFullSize will not include the sizes of
 * non-base tables (e.g., filters, views, joins, etc.).
 * 
 * @param tableName  Name of the table for which to retrieve the information,
 *                   in [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  If blank, then
 *                   returns information about all tables and views.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_table_force_synchronous: If @a true
 *                 then the table sizes will wait for read lock before
 *                 returning.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_true.
 *                         <li> gpudb::show_table_get_sizes: If @a true then
 *                 the number of records in each table, along with a cumulative
 *                 count, will be returned; blank, otherwise.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_false.
 *                         <li> gpudb::show_table_get_cached_sizes: If @a true
 *                 then the number of records in each table, along with a
 *                 cumulative count, will be returned; blank, otherwise. This
 *                 version will return the sizes cached at rank 0, which may be
 *                 stale if there is a multihead insert occuring.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_false.
 *                         <li> gpudb::show_table_show_children: If @a
 *                 tableName is a schema, then @a true will return information
 *                 about the tables and views in the schema, and @a false will
 *                 return information about the schema itself. If @a tableName
 *                 is a table or view, @a show_children must be @a false. If @a
 *                 tableName is empty, then @a show_children must be @a true.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_true.
 *                         <li> gpudb::show_table_no_error_if_not_exists: If @a
 *                 false will return an error if the provided @a tableName does
 *                 not exist. If @a true then it will return an empty result.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_false.
 *                         <li> gpudb::show_table_get_column_info: If @a true
 *                 then column info (memory usage, etc) will be returned.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableResponse showTable( const std::string& tableName,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Retrieves detailed information about a table, view, or schema,
 * specified in @a tableName. If the supplied @a tableName is a
 * schema the call can return information about either the schema itself or the
 * tables and views it contains. If @a tableName is empty, information about
 * all schemas will be returned.
 * <p>
 * If the option @a get_sizes is set to
 * @a true, then the number of records
 * in each table is returned (in @a sizes and
 * @a fullSizes), along with the total number of objects across all
 * requested tables (in @a totalSize and @a totalFullSize).
 * <p>
 * For a schema, setting the @a show_children option to
 * @a false returns only information
 * about the schema itself; setting @a show_children to
 * @a true returns a list of tables and
 * views contained in the schema, along with their corresponding detail.
 * <p>
 * To retrieve a list of every table, view, and schema in the database, set
 * @a tableName to '*' and @a show_children to
 * @a true.  When doing this, the
 * returned @a totalSize and @a totalFullSize will not include the sizes of
 * non-base tables (e.g., filters, views, joins, etc.).
 * 
 * @param tableName  Name of the table for which to retrieve the information,
 *                   in [schema_name.]table_name format, using standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  If blank, then
 *                   returns information about all tables and views.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_table_force_synchronous: If @a true
 *                 then the table sizes will wait for read lock before
 *                 returning.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_true.
 *                         <li> gpudb::show_table_get_sizes: If @a true then
 *                 the number of records in each table, along with a cumulative
 *                 count, will be returned; blank, otherwise.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_false.
 *                         <li> gpudb::show_table_get_cached_sizes: If @a true
 *                 then the number of records in each table, along with a
 *                 cumulative count, will be returned; blank, otherwise. This
 *                 version will return the sizes cached at rank 0, which may be
 *                 stale if there is a multihead insert occuring.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_false.
 *                         <li> gpudb::show_table_show_children: If @a
 *                 tableName is a schema, then @a true will return information
 *                 about the tables and views in the schema, and @a false will
 *                 return information about the schema itself. If @a tableName
 *                 is a table or view, @a show_children must be @a false. If @a
 *                 tableName is empty, then @a show_children must be @a true.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_true.
 *                         <li> gpudb::show_table_no_error_if_not_exists: If @a
 *                 false will return an error if the provided @a tableName does
 *                 not exist. If @a true then it will return an empty result.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_false.
 *                         <li> gpudb::show_table_get_column_info: If @a true
 *                 then column info (memory usage, etc) will be returned.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableResponse& showTable( const std::string& tableName,
                              const std::map<std::string, std::string>& options,
                              ShowTableResponse& response_ ) const;

/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableMetadataResponse showTableMetadata( const ShowTableMetadataRequest& request_ ) const;

/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableMetadataResponse& showTableMetadata( const ShowTableMetadataRequest& request_,
                                              ShowTableMetadataResponse& response_ ) const;

/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param tableNames  Names of tables whose metadata will be fetched, in
 *                    [schema_name.]table_name format, using standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.  All provided
 *                    tables must exist, or an error is returned.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableMetadataResponse showTableMetadata( const std::vector<std::string>& tableNames,
                                             const std::map<std::string, std::string>& options ) const;

/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param tableNames  Names of tables whose metadata will be fetched, in
 *                    [schema_name.]table_name format, using standard <a
 *                    href="../../../concepts/tables/#table-name-resolution"
 *                    target="_top">name resolution rules</a>.  All provided
 *                    tables must exist, or an error is returned.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableMetadataResponse& showTableMetadata( const std::vector<std::string>& tableNames,
                                              const std::map<std::string, std::string>& options,
                                              ShowTableMetadataResponse& response_ ) const;

/**
 * Show table monitors and their properties. Table monitors are created using
 * {@link #createTableMonitor(const CreateTableMonitorRequest&) const}.
 * Returns detailed information about existing table monitors.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableMonitorsResponse showTableMonitors( const ShowTableMonitorsRequest& request_ ) const;

/**
 * Show table monitors and their properties. Table monitors are created using
 * {@link
 * #createTableMonitor(const CreateTableMonitorRequest&,CreateTableMonitorResponse&) const}.
 * Returns detailed information about existing table monitors.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableMonitorsResponse& showTableMonitors( const ShowTableMonitorsRequest& request_,
                                              ShowTableMonitorsResponse& response_ ) const;

/**
 * Show table monitors and their properties. Table monitors are created using
 * {@link
 * #createTableMonitor(const std::string&,const std::map<std::string, std::string>&) const}.
 * Returns detailed information about existing table monitors.
 * 
 * @param monitorIds  List of monitors to be shown. An empty list or a single
 *                    entry with an empty string returns all table monitors.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableMonitorsResponse showTableMonitors( const std::vector<std::string>& monitorIds,
                                             const std::map<std::string, std::string>& options ) const;

/**
 * Show table monitors and their properties. Table monitors are created using
 * {@link
 * #createTableMonitor(const std::string&,const std::map<std::string, std::string>&,CreateTableMonitorResponse&) const}.
 * Returns detailed information about existing table monitors.
 * 
 * @param monitorIds  List of monitors to be shown. An empty list or a single
 *                    entry with an empty string returns all table monitors.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableMonitorsResponse& showTableMonitors( const std::vector<std::string>& monitorIds,
                                              const std::map<std::string, std::string>& options,
                                              ShowTableMonitorsResponse& response_ ) const;

/**
 * Gets names of the tables whose type matches the given criteria. Each table
 * has a particular type. This type comprises the schema and properties of the
 * table and sometimes a type label. This function allows a look up of the
 * existing tables based on full or partial type information. The operation is
 * synchronous.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTablesByTypeResponse showTablesByType( const ShowTablesByTypeRequest& request_ ) const;

/**
 * Gets names of the tables whose type matches the given criteria. Each table
 * has a particular type. This type comprises the schema and properties of the
 * table and sometimes a type label. This function allows a look up of the
 * existing tables based on full or partial type information. The operation is
 * synchronous.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTablesByTypeResponse& showTablesByType( const ShowTablesByTypeRequest& request_,
                                            ShowTablesByTypeResponse& response_ ) const;

/**
 * Gets names of the tables whose type matches the given criteria. Each table
 * has a particular type. This type comprises the schema and properties of the
 * table and sometimes a type label. This function allows a look up of the
 * existing tables based on full or partial type information. The operation is
 * synchronous.
 * 
 * @param typeId  Type id returned by a call to /create/type.
 * @param label  Optional user supplied label which can be used instead of the
 *               type_id to retrieve all tables with the given label.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTablesByTypeResponse showTablesByType( const std::string& typeId,
                                           const std::string& label,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * Gets names of the tables whose type matches the given criteria. Each table
 * has a particular type. This type comprises the schema and properties of the
 * table and sometimes a type label. This function allows a look up of the
 * existing tables based on full or partial type information. The operation is
 * synchronous.
 * 
 * @param typeId  Type id returned by a call to /create/type.
 * @param label  Optional user supplied label which can be used instead of the
 *               type_id to retrieve all tables with the given label.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTablesByTypeResponse& showTablesByType( const std::string& typeId,
                                            const std::string& label,
                                            const std::map<std::string, std::string>& options,
                                            ShowTablesByTypeResponse& response_ ) const;

/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTriggersResponse showTriggers( const ShowTriggersRequest& request_ ) const;

/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTriggersResponse& showTriggers( const ShowTriggersRequest& request_,
                                    ShowTriggersResponse& response_ ) const;

/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active.
 * 
 * @param triggerIds  List of IDs of the triggers whose information is to be
 *                    retrieved. An empty list means information will be
 *                    retrieved on all active triggers.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTriggersResponse showTriggers( const std::vector<std::string>& triggerIds,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active.
 * 
 * @param triggerIds  List of IDs of the triggers whose information is to be
 *                    retrieved. An empty list means information will be
 *                    retrieved on all active triggers.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTriggersResponse& showTriggers( const std::vector<std::string>& triggerIds,
                                    const std::map<std::string, std::string>& options,
                                    ShowTriggersResponse& response_ ) const;

/**
 * Retrieves information for the specified data type ID or type label. For all
 * data types that match the input criteria, the database returns the type ID,
 * the type schema, the label (if available), and the type's column properties.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTypesResponse showTypes( const ShowTypesRequest& request_ ) const;

/**
 * Retrieves information for the specified data type ID or type label. For all
 * data types that match the input criteria, the database returns the type ID,
 * the type schema, the label (if available), and the type's column properties.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTypesResponse& showTypes( const ShowTypesRequest& request_,
                              ShowTypesResponse& response_ ) const;

/**
 * Retrieves information for the specified data type ID or type label. For all
 * data types that match the input criteria, the database returns the type ID,
 * the type schema, the label (if available), and the type's column properties.
 * 
 * @param typeId  Type Id returned in response to a call to /create/type.
 * @param label  Option string that was supplied by user in a call to
 *               /create/type.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_types_no_join_types: When set to
 *                 'true', no join types will be included.
 *                 <ul>
 *                         <li> gpudb::show_types_true
 *                         <li> gpudb::show_types_false
 *                 </ul>
 *                 The default value is gpudb::show_types_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTypesResponse showTypes( const std::string& typeId,
                             const std::string& label,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Retrieves information for the specified data type ID or type label. For all
 * data types that match the input criteria, the database returns the type ID,
 * the type schema, the label (if available), and the type's column properties.
 * 
 * @param typeId  Type Id returned in response to a call to /create/type.
 * @param label  Option string that was supplied by user in a call to
 *               /create/type.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_types_no_join_types: When set to
 *                 'true', no join types will be included.
 *                 <ul>
 *                         <li> gpudb::show_types_true
 *                         <li> gpudb::show_types_false
 *                 </ul>
 *                 The default value is gpudb::show_types_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTypesResponse& showTypes( const std::string& typeId,
                              const std::string& label,
                              const std::map<std::string, std::string>& options,
                              ShowTypesResponse& response_ ) const;

/**
 * Retrieves information about rendered videos.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowVideoResponse showVideo( const ShowVideoRequest& request_ ) const;

/**
 * Retrieves information about rendered videos.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowVideoResponse& showVideo( const ShowVideoRequest& request_,
                              ShowVideoResponse& response_ ) const;

/**
 * Retrieves information about rendered videos.
 * 
 * @param paths  The fully-qualified <a href="../../../tools/kifs/"
 *               target="_top">KiFS</a> paths for the videos to show. If empty,
 *               shows all videos.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowVideoResponse showVideo( const std::vector<std::string>& paths,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Retrieves information about rendered videos.
 * 
 * @param paths  The fully-qualified <a href="../../../tools/kifs/"
 *               target="_top">KiFS</a> paths for the videos to show. If empty,
 *               shows all videos.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowVideoResponse& showVideo( const std::vector<std::string>& paths,
                              const std::map<std::string, std::string>& options,
                              ShowVideoResponse& response_ ) const;

/**
 * Solves an existing graph for a type of problem (e.g., shortest path,
 * page rank, travelling salesman, etc.) using source nodes, destination nodes,
 * and
 * additional, optional weights and restrictions.
 * <p>
 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph---solve" target="_top">/solve/graph
 * examples</a>
 * before using this endpoint.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

SolveGraphResponse solveGraph( const SolveGraphRequest& request_ ) const;

/**
 * Solves an existing graph for a type of problem (e.g., shortest path,
 * page rank, travelling salesman, etc.) using source nodes, destination nodes,
 * and
 * additional, optional weights and restrictions.
 * <p>
 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph---solve" target="_top">/solve/graph
 * examples</a>
 * before using this endpoint.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

SolveGraphResponse& solveGraph( const SolveGraphRequest& request_,
                                SolveGraphResponse& response_ ) const;

/**
 * Solves an existing graph for a type of problem (e.g., shortest path,
 * page rank, travelling salesman, etc.) using source nodes, destination nodes,
 * and
 * additional, optional weights and restrictions.
 * <p>
 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph---solve" target="_top">/solve/graph
 * examples</a>
 * before using this endpoint.
 * 
 * @param graphName  Name of the graph resource to solve.
 * @param weightsOnEdges  Additional weights to apply to the edges of an
 *                        existing
 *                        graph. Weights must be specified using
 *                        <a
 *                        href="../../../graph_solver/network_graph_solver/#identifiers"
 *                        target="_top">identifiers</a>;
 *                        identifiers are grouped as
 *                        <a
 *                        href="../../../graph_solver/network_graph_solver/#id-combos"
 *                        target="_top">combinations</a>.
 *                        Identifiers can be used with existing column names,
 *                        e.g.,
 *                        'table.column AS WEIGHTS_EDGE_ID', expressions, e.g.,
 *                        'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED', or
 *                        constant values, e.g.,
 *                        '{4, 15, 2} AS WEIGHTS_VALUESPECIFIED'. Any provided
 *                        weights will be added
 *                        (in the case of 'WEIGHTS_VALUESPECIFIED') to or
 *                        multiplied with
 *                        (in the case of 'WEIGHTS_FACTORSPECIFIED') the
 *                        existing weight(s). If using
 *                        constant values in an identifier combination, the
 *                        number of values specified
 *                        must match across the combination.
 * @param restrictions  Additional restrictions to apply to the nodes/edges of
 *                      an
 *                      existing graph. Restrictions must be specified using
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#identifiers"
 *                      target="_top">identifiers</a>;
 *                      identifiers are grouped as
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#id-combos"
 *                      target="_top">combinations</a>.
 *                      Identifiers can be used with existing column names,
 *                      e.g.,
 *                      'table.column AS RESTRICTIONS_EDGE_ID', expressions,
 *                      e.g.,
 *                      'column/2 AS RESTRICTIONS_VALUECOMPARED', or constant
 *                      values, e.g.,
 *                      '{0, 0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using
 *                      constant values in an
 *                      identifier combination, the number of values specified
 *                      must match across the
 *                      combination. If remove_previous_restrictions option is
 *                      set
 *                      to true, any
 *                      provided restrictions will replace the existing
 *                      restrictions. Otherwise, any provided
 *                      restrictions will be added (in the case of
 *                      'RESTRICTIONS_VALUECOMPARED') to or
 *                      replaced (in the case of 'RESTRICTIONS_ONOFFCOMPARED').
 * @param solverType  The type of solver to use for the graph.
 *                    <ul>
 *                            <li> gpudb::solve_graph_SHORTEST_PATH: Solves for
 *                    the optimal (shortest) path based on weights and
 *                    restrictions from one source to destinations nodes. Also
 *                    known as the Dijkstra solver.
 *                            <li> gpudb::solve_graph_PAGE_RANK: Solves for the
 *                    probability of each destination node being visited based
 *                    on the links of the graph topology. Weights are not
 *                    required to use this solver.
 *                            <li> gpudb::solve_graph_PROBABILITY_RANK: Solves
 *                    for the transitional probability (Hidden Markov) for each
 *                    node based on the weights (probability assigned over
 *                    given edges).
 *                            <li> gpudb::solve_graph_CENTRALITY: Solves for
 *                    the degree of a node to depict how many pairs of
 *                    individuals that would have to go through the node to
 *                    reach one another in the minimum number of hops. Also
 *                    known as betweenness.
 *                            <li> gpudb::solve_graph_MULTIPLE_ROUTING: Solves
 *                    for finding the minimum cost cumulative path for a
 *                    round-trip starting from the given source and visiting
 *                    each given destination node once then returning to the
 *                    source. Also known as the travelling salesman problem.
 *                            <li> gpudb::solve_graph_INVERSE_SHORTEST_PATH:
 *                    Solves for finding the optimal path cost for each
 *                    destination node to route to the source node. Also known
 *                    as inverse Dijkstra or the service man routing problem.
 *                            <li> gpudb::solve_graph_BACKHAUL_ROUTING: Solves
 *                    for optimal routes that connect remote asset nodes to the
 *                    fixed (backbone) asset nodes.
 *                            <li> gpudb::solve_graph_ALLPATHS: Solves for
 *                    paths that would give costs between max and min solution
 *                    radia - Make sure to limit by the 'max_solution_targets'
 *                    option. Min cost shoudl be >= shortest_path cost.
 *                            <li> gpudb::solve_graph_STATS_ALL: Solves for
 *                    graph statistics such as graph diameter, longest pairs,
 *                    vertex valences, topology numbers, average and max
 *                    cluster sizes, etc.
 *                            <li> gpudb::solve_graph_CLOSENESS: Solves for the
 *                    centrality closeness score per node as the sum of the
 *                    inverse shortest path costs to all nodes in the graph.
 *                    </ul>
 *                    The default value is gpudb::solve_graph_SHORTEST_PATH.
 * @param sourceNodes  It can be one of the nodal identifiers - e.g:
 *                     'NODE_WKTPOINT' for source nodes. For @a
 *                     BACKHAUL_ROUTING, this list depicts the fixed assets.
 * @param destinationNodes  It can be one of the nodal identifiers - e.g:
 *                          'NODE_WKTPOINT' for destination (target) nodes. For
 *                          @a BACKHAUL_ROUTING, this list depicts the remote
 *                          assets.
 * @param solutionTable  Name of the table to store the solution, in
 *                       [schema_name.]table_name format, using standard <a
 *                       href="../../../concepts/tables/#table-name-resolution"
 *                       target="_top">name resolution rules</a>.
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::solve_graph_max_solution_radius: For @a
 *                 ALLPATHS, @a SHORTEST_PATH and @a INVERSE_SHORTEST_PATH
 *                 solvers only. Sets the maximum solution cost radius, which
 *                 ignores the @a destinationNodes list and instead outputs the
 *                 nodes within the radius sorted by ascending cost. If set to
 *                 '0.0', the setting is ignored.  The default value is '0.0'.
 *                         <li> gpudb::solve_graph_min_solution_radius: For @a
 *                 ALLPATHS, @a SHORTEST_PATH and @a INVERSE_SHORTEST_PATH
 *                 solvers only. Applicable only when @a max_solution_radius is
 *                 set. Sets the minimum solution cost radius, which ignores
 *                 the @a destinationNodes list and instead outputs the nodes
 *                 within the radius sorted by ascending cost. If set to '0.0',
 *                 the setting is ignored.  The default value is '0.0'.
 *                         <li> gpudb::solve_graph_max_solution_targets: For @a
 *                 ALLPATHS, @a SHORTEST_PATH and @a INVERSE_SHORTEST_PATH
 *                 solvers only. Sets the maximum number of solution targets,
 *                 which ignores the @a destinationNodes list and instead
 *                 outputs no more than n number of nodes sorted by ascending
 *                 cost where n is equal to the setting value. If set to 0, the
 *                 setting is ignored.  The default value is '1000'.
 *                         <li> gpudb::solve_graph_uniform_weights: When
 *                 specified, assigns the given value to all the edges in the
 *                 graph. Note that weights provided in @a weightsOnEdges will
 *                 override this value.
 *                         <li> gpudb::solve_graph_left_turn_penalty: This will
 *                 add an additonal weight over the edges labelled as 'left
 *                 turn' if the 'add_turn' option parameter of the
 *                 /create/graph was invoked at graph creation.  The default
 *                 value is '0.0'.
 *                         <li> gpudb::solve_graph_right_turn_penalty: This
 *                 will add an additonal weight over the edges labelled as'
 *                 right turn' if the 'add_turn' option parameter of the
 *                 /create/graph was invoked at graph creation.  The default
 *                 value is '0.0'.
 *                         <li> gpudb::solve_graph_intersection_penalty: This
 *                 will add an additonal weight over the edges labelled as
 *                 'intersection' if the 'add_turn' option parameter of the
 *                 /create/graph was invoked at graph creation.  The default
 *                 value is '0.0'.
 *                         <li> gpudb::solve_graph_sharp_turn_penalty: This
 *                 will add an additonal weight over the edges labelled as
 *                 'sharp turn' or 'u-turn' if the 'add_turn' option parameter
 *                 of the /create/graph was invoked at graph creation.  The
 *                 default value is '0.0'.
 *                         <li> gpudb::solve_graph_num_best_paths: For @a
 *                 MULTIPLE_ROUTING solvers only; sets the number of shortest
 *                 paths computed from each node. This is the heuristic
 *                 criterion. Default value of zero allows the number to be
 *                 computed automatically by the solver. The user may want to
 *                 override this parameter to speed-up the solver.  The default
 *                 value is '0'.
 *                         <li> gpudb::solve_graph_max_num_combinations: For @a
 *                 MULTIPLE_ROUTING solvers only; sets the cap on the
 *                 combinatorial sequences generated. If the default value of
 *                 two millions is overridden to a lesser value, it can
 *                 potentially speed up the solver.  The default value is
 *                 '2000000'.
 *                         <li> gpudb::solve_graph_output_edge_path: If true
 *                 then concatenated edge ids will be added as the EDGE path
 *                 column of the solution table for each source and target pair
 *                 in shortest path solves.
 *                 <ul>
 *                         <li> gpudb::solve_graph_true
 *                         <li> gpudb::solve_graph_false
 *                 </ul>
 *                 The default value is gpudb::solve_graph_false.
 *                         <li> gpudb::solve_graph_output_wkt_path: If true
 *                 then concatenated wkt line segments will be added as the
 *                 Wktroute column of the solution table for each source and
 *                 target pair in shortest path solves.
 *                 <ul>
 *                         <li> gpudb::solve_graph_true
 *                         <li> gpudb::solve_graph_false
 *                 </ul>
 *                 The default value is gpudb::solve_graph_true.
 *                         <li> gpudb::solve_graph_server_id: Indicates which
 *                 graph server(s) to send the request to. Default is to send
 *                 to the server, amongst those containing the corresponding
 *                 graph, that has the most computational bandwidth. For
 *                 SHORTEST_PATH solver type, the input is split amongst the
 *                 server containing the corresponding graph.
 *                         <li> gpudb::solve_graph_convergence_limit: For @a
 *                 PAGE_RANK solvers only; Maximum percent relative threshold
 *                 on the pagerank scores of each node between consecutive
 *                 iterations to satisfy convergence. Default value is 1 (one)
 *                 percent.  The default value is '1.0'.
 *                         <li> gpudb::solve_graph_max_iterations: For @a
 *                 PAGE_RANK solvers only; Maximum number of pagerank
 *                 iterations for satisfying convergence. Default value is 100.
 *                 The default value is '100'.
 *                         <li> gpudb::solve_graph_max_runs: For all @a
 *                 CENTRALITY solvers only; Sets the maximum number of shortest
 *                 path runs; maximum possible value is the number of nodes in
 *                 the graph. Default value of 0 enables this value to be auto
 *                 computed by the solver.  The default value is '0'.
 *                         <li> gpudb::solve_graph_output_clusters: For @a
 *                 STATS_ALL solvers only; the cluster index for each node will
 *                 be inserted as an additional column in the output.
 *                 <ul>
 *                         <li> gpudb::solve_graph_true: An additional column
 *                 'CLUSTER' will be added for each node
 *                         <li> gpudb::solve_graph_false: No extra cluster info
 *                 per node will be available in the output
 *                 </ul>
 *                 The default value is gpudb::solve_graph_false.
 *                         <li> gpudb::solve_graph_solve_heuristic: Specify
 *                 heuristic search criterion only for the geo graphs and
 *                 shortest path solves towards a single target
 *                 <ul>
 *                         <li> gpudb::solve_graph_astar: Employs A-STAR
 *                 heuristics to speed up the shortest path traversal
 *                         <li> gpudb::solve_graph_none: No heuristics are
 *                 applied
 *                 </ul>
 *                 The default value is gpudb::solve_graph_none.
 *                         <li> gpudb::solve_graph_astar_radius: For path
 *                 solvers only when 'solve_heuristic' option is 'astar'. The
 *                 shortest path traversal front includes nodes only within
 *                 this radius (kilometers) as it moves towards the target
 *                 location.  The default value is '70'.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

SolveGraphResponse solveGraph( const std::string& graphName,
                               const std::vector<std::string>& weightsOnEdges,
                               const std::vector<std::string>& restrictions,
                               const std::string& solverType,
                               const std::vector<std::string>& sourceNodes,
                               const std::vector<std::string>& destinationNodes,
                               const std::string& solutionTable,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Solves an existing graph for a type of problem (e.g., shortest path,
 * page rank, travelling salesman, etc.) using source nodes, destination nodes,
 * and
 * additional, optional weights and restrictions.
 * <p>
 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph---solve" target="_top">/solve/graph
 * examples</a>
 * before using this endpoint.
 * 
 * @param graphName  Name of the graph resource to solve.
 * @param weightsOnEdges  Additional weights to apply to the edges of an
 *                        existing
 *                        graph. Weights must be specified using
 *                        <a
 *                        href="../../../graph_solver/network_graph_solver/#identifiers"
 *                        target="_top">identifiers</a>;
 *                        identifiers are grouped as
 *                        <a
 *                        href="../../../graph_solver/network_graph_solver/#id-combos"
 *                        target="_top">combinations</a>.
 *                        Identifiers can be used with existing column names,
 *                        e.g.,
 *                        'table.column AS WEIGHTS_EDGE_ID', expressions, e.g.,
 *                        'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED', or
 *                        constant values, e.g.,
 *                        '{4, 15, 2} AS WEIGHTS_VALUESPECIFIED'. Any provided
 *                        weights will be added
 *                        (in the case of 'WEIGHTS_VALUESPECIFIED') to or
 *                        multiplied with
 *                        (in the case of 'WEIGHTS_FACTORSPECIFIED') the
 *                        existing weight(s). If using
 *                        constant values in an identifier combination, the
 *                        number of values specified
 *                        must match across the combination.
 * @param restrictions  Additional restrictions to apply to the nodes/edges of
 *                      an
 *                      existing graph. Restrictions must be specified using
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#identifiers"
 *                      target="_top">identifiers</a>;
 *                      identifiers are grouped as
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#id-combos"
 *                      target="_top">combinations</a>.
 *                      Identifiers can be used with existing column names,
 *                      e.g.,
 *                      'table.column AS RESTRICTIONS_EDGE_ID', expressions,
 *                      e.g.,
 *                      'column/2 AS RESTRICTIONS_VALUECOMPARED', or constant
 *                      values, e.g.,
 *                      '{0, 0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using
 *                      constant values in an
 *                      identifier combination, the number of values specified
 *                      must match across the
 *                      combination. If remove_previous_restrictions option is
 *                      set
 *                      to true, any
 *                      provided restrictions will replace the existing
 *                      restrictions. Otherwise, any provided
 *                      restrictions will be added (in the case of
 *                      'RESTRICTIONS_VALUECOMPARED') to or
 *                      replaced (in the case of 'RESTRICTIONS_ONOFFCOMPARED').
 * @param solverType  The type of solver to use for the graph.
 *                    <ul>
 *                            <li> gpudb::solve_graph_SHORTEST_PATH: Solves for
 *                    the optimal (shortest) path based on weights and
 *                    restrictions from one source to destinations nodes. Also
 *                    known as the Dijkstra solver.
 *                            <li> gpudb::solve_graph_PAGE_RANK: Solves for the
 *                    probability of each destination node being visited based
 *                    on the links of the graph topology. Weights are not
 *                    required to use this solver.
 *                            <li> gpudb::solve_graph_PROBABILITY_RANK: Solves
 *                    for the transitional probability (Hidden Markov) for each
 *                    node based on the weights (probability assigned over
 *                    given edges).
 *                            <li> gpudb::solve_graph_CENTRALITY: Solves for
 *                    the degree of a node to depict how many pairs of
 *                    individuals that would have to go through the node to
 *                    reach one another in the minimum number of hops. Also
 *                    known as betweenness.
 *                            <li> gpudb::solve_graph_MULTIPLE_ROUTING: Solves
 *                    for finding the minimum cost cumulative path for a
 *                    round-trip starting from the given source and visiting
 *                    each given destination node once then returning to the
 *                    source. Also known as the travelling salesman problem.
 *                            <li> gpudb::solve_graph_INVERSE_SHORTEST_PATH:
 *                    Solves for finding the optimal path cost for each
 *                    destination node to route to the source node. Also known
 *                    as inverse Dijkstra or the service man routing problem.
 *                            <li> gpudb::solve_graph_BACKHAUL_ROUTING: Solves
 *                    for optimal routes that connect remote asset nodes to the
 *                    fixed (backbone) asset nodes.
 *                            <li> gpudb::solve_graph_ALLPATHS: Solves for
 *                    paths that would give costs between max and min solution
 *                    radia - Make sure to limit by the 'max_solution_targets'
 *                    option. Min cost shoudl be >= shortest_path cost.
 *                            <li> gpudb::solve_graph_STATS_ALL: Solves for
 *                    graph statistics such as graph diameter, longest pairs,
 *                    vertex valences, topology numbers, average and max
 *                    cluster sizes, etc.
 *                            <li> gpudb::solve_graph_CLOSENESS: Solves for the
 *                    centrality closeness score per node as the sum of the
 *                    inverse shortest path costs to all nodes in the graph.
 *                    </ul>
 *                    The default value is gpudb::solve_graph_SHORTEST_PATH.
 * @param sourceNodes  It can be one of the nodal identifiers - e.g:
 *                     'NODE_WKTPOINT' for source nodes. For @a
 *                     BACKHAUL_ROUTING, this list depicts the fixed assets.
 * @param destinationNodes  It can be one of the nodal identifiers - e.g:
 *                          'NODE_WKTPOINT' for destination (target) nodes. For
 *                          @a BACKHAUL_ROUTING, this list depicts the remote
 *                          assets.
 * @param solutionTable  Name of the table to store the solution, in
 *                       [schema_name.]table_name format, using standard <a
 *                       href="../../../concepts/tables/#table-name-resolution"
 *                       target="_top">name resolution rules</a>.
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::solve_graph_max_solution_radius: For @a
 *                 ALLPATHS, @a SHORTEST_PATH and @a INVERSE_SHORTEST_PATH
 *                 solvers only. Sets the maximum solution cost radius, which
 *                 ignores the @a destinationNodes list and instead outputs the
 *                 nodes within the radius sorted by ascending cost. If set to
 *                 '0.0', the setting is ignored.  The default value is '0.0'.
 *                         <li> gpudb::solve_graph_min_solution_radius: For @a
 *                 ALLPATHS, @a SHORTEST_PATH and @a INVERSE_SHORTEST_PATH
 *                 solvers only. Applicable only when @a max_solution_radius is
 *                 set. Sets the minimum solution cost radius, which ignores
 *                 the @a destinationNodes list and instead outputs the nodes
 *                 within the radius sorted by ascending cost. If set to '0.0',
 *                 the setting is ignored.  The default value is '0.0'.
 *                         <li> gpudb::solve_graph_max_solution_targets: For @a
 *                 ALLPATHS, @a SHORTEST_PATH and @a INVERSE_SHORTEST_PATH
 *                 solvers only. Sets the maximum number of solution targets,
 *                 which ignores the @a destinationNodes list and instead
 *                 outputs no more than n number of nodes sorted by ascending
 *                 cost where n is equal to the setting value. If set to 0, the
 *                 setting is ignored.  The default value is '1000'.
 *                         <li> gpudb::solve_graph_uniform_weights: When
 *                 specified, assigns the given value to all the edges in the
 *                 graph. Note that weights provided in @a weightsOnEdges will
 *                 override this value.
 *                         <li> gpudb::solve_graph_left_turn_penalty: This will
 *                 add an additonal weight over the edges labelled as 'left
 *                 turn' if the 'add_turn' option parameter of the
 *                 /create/graph was invoked at graph creation.  The default
 *                 value is '0.0'.
 *                         <li> gpudb::solve_graph_right_turn_penalty: This
 *                 will add an additonal weight over the edges labelled as'
 *                 right turn' if the 'add_turn' option parameter of the
 *                 /create/graph was invoked at graph creation.  The default
 *                 value is '0.0'.
 *                         <li> gpudb::solve_graph_intersection_penalty: This
 *                 will add an additonal weight over the edges labelled as
 *                 'intersection' if the 'add_turn' option parameter of the
 *                 /create/graph was invoked at graph creation.  The default
 *                 value is '0.0'.
 *                         <li> gpudb::solve_graph_sharp_turn_penalty: This
 *                 will add an additonal weight over the edges labelled as
 *                 'sharp turn' or 'u-turn' if the 'add_turn' option parameter
 *                 of the /create/graph was invoked at graph creation.  The
 *                 default value is '0.0'.
 *                         <li> gpudb::solve_graph_num_best_paths: For @a
 *                 MULTIPLE_ROUTING solvers only; sets the number of shortest
 *                 paths computed from each node. This is the heuristic
 *                 criterion. Default value of zero allows the number to be
 *                 computed automatically by the solver. The user may want to
 *                 override this parameter to speed-up the solver.  The default
 *                 value is '0'.
 *                         <li> gpudb::solve_graph_max_num_combinations: For @a
 *                 MULTIPLE_ROUTING solvers only; sets the cap on the
 *                 combinatorial sequences generated. If the default value of
 *                 two millions is overridden to a lesser value, it can
 *                 potentially speed up the solver.  The default value is
 *                 '2000000'.
 *                         <li> gpudb::solve_graph_output_edge_path: If true
 *                 then concatenated edge ids will be added as the EDGE path
 *                 column of the solution table for each source and target pair
 *                 in shortest path solves.
 *                 <ul>
 *                         <li> gpudb::solve_graph_true
 *                         <li> gpudb::solve_graph_false
 *                 </ul>
 *                 The default value is gpudb::solve_graph_false.
 *                         <li> gpudb::solve_graph_output_wkt_path: If true
 *                 then concatenated wkt line segments will be added as the
 *                 Wktroute column of the solution table for each source and
 *                 target pair in shortest path solves.
 *                 <ul>
 *                         <li> gpudb::solve_graph_true
 *                         <li> gpudb::solve_graph_false
 *                 </ul>
 *                 The default value is gpudb::solve_graph_true.
 *                         <li> gpudb::solve_graph_server_id: Indicates which
 *                 graph server(s) to send the request to. Default is to send
 *                 to the server, amongst those containing the corresponding
 *                 graph, that has the most computational bandwidth. For
 *                 SHORTEST_PATH solver type, the input is split amongst the
 *                 server containing the corresponding graph.
 *                         <li> gpudb::solve_graph_convergence_limit: For @a
 *                 PAGE_RANK solvers only; Maximum percent relative threshold
 *                 on the pagerank scores of each node between consecutive
 *                 iterations to satisfy convergence. Default value is 1 (one)
 *                 percent.  The default value is '1.0'.
 *                         <li> gpudb::solve_graph_max_iterations: For @a
 *                 PAGE_RANK solvers only; Maximum number of pagerank
 *                 iterations for satisfying convergence. Default value is 100.
 *                 The default value is '100'.
 *                         <li> gpudb::solve_graph_max_runs: For all @a
 *                 CENTRALITY solvers only; Sets the maximum number of shortest
 *                 path runs; maximum possible value is the number of nodes in
 *                 the graph. Default value of 0 enables this value to be auto
 *                 computed by the solver.  The default value is '0'.
 *                         <li> gpudb::solve_graph_output_clusters: For @a
 *                 STATS_ALL solvers only; the cluster index for each node will
 *                 be inserted as an additional column in the output.
 *                 <ul>
 *                         <li> gpudb::solve_graph_true: An additional column
 *                 'CLUSTER' will be added for each node
 *                         <li> gpudb::solve_graph_false: No extra cluster info
 *                 per node will be available in the output
 *                 </ul>
 *                 The default value is gpudb::solve_graph_false.
 *                         <li> gpudb::solve_graph_solve_heuristic: Specify
 *                 heuristic search criterion only for the geo graphs and
 *                 shortest path solves towards a single target
 *                 <ul>
 *                         <li> gpudb::solve_graph_astar: Employs A-STAR
 *                 heuristics to speed up the shortest path traversal
 *                         <li> gpudb::solve_graph_none: No heuristics are
 *                 applied
 *                 </ul>
 *                 The default value is gpudb::solve_graph_none.
 *                         <li> gpudb::solve_graph_astar_radius: For path
 *                 solvers only when 'solve_heuristic' option is 'astar'. The
 *                 shortest path traversal front includes nodes only within
 *                 this radius (kilometers) as it moves towards the target
 *                 location.  The default value is '70'.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

SolveGraphResponse& solveGraph( const std::string& graphName,
                                const std::vector<std::string>& weightsOnEdges,
                                const std::vector<std::string>& restrictions,
                                const std::string& solverType,
                                const std::vector<std::string>& sourceNodes,
                                const std::vector<std::string>& destinationNodes,
                                const std::string& solutionTable,
                                const std::map<std::string, std::string>& options,
                                SolveGraphResponse& response_ ) const;

/**
 * Runs multiple predicate-based updates in a single call.  With the
 * list of given expressions, any matching record's column values will be
 * updated
 * as provided in @a newValuesMaps.  There is also an optional 'upsert'
 * capability where if a particular predicate doesn't match any existing
 * record,
 * then a new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * result view.
 * <p>
 * This operation can update primary key values.  By default only
 * 'pure primary key' predicates are allowed when updating primary key values.
 * If
 * the primary key for a table is the column 'attr1', then the operation will
 * only
 * accept predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then
 * this operation will only accept predicates of the form:
 * "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns
 * must appear in an equality predicate in the expressions.  Furthermore each
 * 'pure primary key' predicate must be unique within a given request.  These
 * restrictions can be removed by utilizing some available options through
 * @a options.
 * <p>
 * The @a update_on_existing_pk option specifies the record primary key
 * collision
 * policy for tables with a <a href="../../../concepts/tables/#primary-keys"
 * target="_top">primary key</a>, while
 * @a ignore_existing_pk specifies the record primary key collision
 * error-suppression policy when those collisions result in the update being
 * rejected.  Both are
 * ignored on tables with no primary key.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UpdateRecordsResponse updateRecordsRaw( const RawUpdateRecordsRequest& request_ ) const;

/**
 * Runs multiple predicate-based updates in a single call.  With the
 * list of given expressions, any matching record's column values will be
 * updated
 * as provided in @a newValuesMaps.  There is also an optional 'upsert'
 * capability where if a particular predicate doesn't match any existing
 * record,
 * then a new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * result view.
 * <p>
 * This operation can update primary key values.  By default only
 * 'pure primary key' predicates are allowed when updating primary key values.
 * If
 * the primary key for a table is the column 'attr1', then the operation will
 * only
 * accept predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then
 * this operation will only accept predicates of the form:
 * "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns
 * must appear in an equality predicate in the expressions.  Furthermore each
 * 'pure primary key' predicate must be unique within a given request.  These
 * restrictions can be removed by utilizing some available options through
 * @a options.
 * <p>
 * The @a update_on_existing_pk option specifies the record primary key
 * collision
 * policy for tables with a <a href="../../../concepts/tables/#primary-keys"
 * target="_top">primary key</a>, while
 * @a ignore_existing_pk specifies the record primary key collision
 * error-suppression policy when those collisions result in the update being
 * rejected.  Both are
 * ignored on tables with no primary key.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UpdateRecordsResponse& updateRecordsRaw( const RawUpdateRecordsRequest& request_,
                                         UpdateRecordsResponse& response_ ) const;

/**
 * Runs multiple predicate-based updates in a single call.  With the
 * list of given expressions, any matching record's column values will be
 * updated
 * as provided in @a newValuesMaps.  There is also an optional 'upsert'
 * capability where if a particular predicate doesn't match any existing
 * record,
 * then a new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * result view.
 * <p>
 * This operation can update primary key values.  By default only
 * 'pure primary key' predicates are allowed when updating primary key values.
 * If
 * the primary key for a table is the column 'attr1', then the operation will
 * only
 * accept predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then
 * this operation will only accept predicates of the form:
 * "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns
 * must appear in an equality predicate in the expressions.  Furthermore each
 * 'pure primary key' predicate must be unique within a given request.  These
 * restrictions can be removed by utilizing some available options through
 * @a options.
 * <p>
 * The @a update_on_existing_pk option specifies the record primary key
 * collision
 * policy for tables with a <a href="../../../concepts/tables/#primary-keys"
 * target="_top">primary key</a>, while
 * @a ignore_existing_pk specifies the record primary key collision
 * error-suppression policy when those collisions result in the update being
 * rejected.  Both are
 * ignored on tables with no primary key.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TRequest> 
UpdateRecordsResponse updateRecords( const UpdateRecordsRequest<TRequest>& request_ ) const
{
    RawUpdateRecordsRequest actualRequest_;
    actualRequest_.tableName = request_.tableName;
    actualRequest_.expressions = request_.expressions;
    actualRequest_.newValuesMaps = request_.newValuesMaps;
    avro::encode(actualRequest_.recordsToInsert, request_.data, this->m_threadCount, this->m_executor);
    actualRequest_.options = request_.options;
    UpdateRecordsResponse actualResponse_;
    submitRequest("/update/records", actualRequest_, actualResponse_, true);
    return actualResponse_;
}


/**
 * Runs multiple predicate-based updates in a single call.  With the
 * list of given expressions, any matching record's column values will be
 * updated
 * as provided in @a newValuesMaps.  There is also an optional 'upsert'
 * capability where if a particular predicate doesn't match any existing
 * record,
 * then a new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * result view.
 * <p>
 * This operation can update primary key values.  By default only
 * 'pure primary key' predicates are allowed when updating primary key values.
 * If
 * the primary key for a table is the column 'attr1', then the operation will
 * only
 * accept predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then
 * this operation will only accept predicates of the form:
 * "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns
 * must appear in an equality predicate in the expressions.  Furthermore each
 * 'pure primary key' predicate must be unique within a given request.  These
 * restrictions can be removed by utilizing some available options through
 * @a options.
 * <p>
 * The @a update_on_existing_pk option specifies the record primary key
 * collision
 * policy for tables with a <a href="../../../concepts/tables/#primary-keys"
 * target="_top">primary key</a>, while
 * @a ignore_existing_pk specifies the record primary key collision
 * error-suppression policy when those collisions result in the update being
 * rejected.  Both are
 * ignored on tables with no primary key.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TRequest> 
UpdateRecordsResponse& updateRecords( const UpdateRecordsRequest<TRequest>& request_,
                                      UpdateRecordsResponse& response_ ) const
{
    RawUpdateRecordsRequest actualRequest_;
    actualRequest_.tableName = request_.tableName;
    actualRequest_.expressions = request_.expressions;
    actualRequest_.newValuesMaps = request_.newValuesMaps;
    avro::encode(actualRequest_.recordsToInsert, request_.data, this->m_threadCount, this->m_executor);
    actualRequest_.options = request_.options;
    submitRequest("/update/records", actualRequest_, response_, true);
    return response_;
}


/**
 * Runs multiple predicate-based updates in a single call.  With the
 * list of given expressions, any matching record's column values will be
 * updated
 * as provided in @a newValuesMaps.  There is also an optional 'upsert'
 * capability where if a particular predicate doesn't match any existing
 * record,
 * then a new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * result view.
 * <p>
 * This operation can update primary key values.  By default only
 * 'pure primary key' predicates are allowed when updating primary key values.
 * If
 * the primary key for a table is the column 'attr1', then the operation will
 * only
 * accept predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then
 * this operation will only accept predicates of the form:
 * "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns
 * must appear in an equality predicate in the expressions.  Furthermore each
 * 'pure primary key' predicate must be unique within a given request.  These
 * restrictions can be removed by utilizing some available options through
 * @a options.
 * <p>
 * The @a update_on_existing_pk option specifies the record primary key
 * collision
 * policy for tables with a <a href="../../../concepts/tables/#primary-keys"
 * target="_top">primary key</a>, while
 * @a ignore_existing_pk specifies the record primary key collision
 * error-suppression policy when those collisions result in the update being
 * rejected.  Both are
 * ignored on tables with no primary key.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param tableName  Name of table to be updated, in [schema_name.]table_name
 *                   format, using standard
 *                   <a href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be a
 *                   currently
 *                   existing table and not a view.
 * @param expressions  A list of the actual predicates, one for each update;
 *                     format should follow the guidelines /filter.
 * @param newValuesMaps  List of new values for the matching records.  Each
 *                       element is a map with
 *                       (key, value) pairs where the keys are the names of the
 *                       columns whose values are to be updated; the
 *                       values are the new values.  The number of elements in
 *                       the list should match the length of @a expressions.
 * @param data  An *optional* list of new binary-avro encoded records to
 *              insert, one for each
 *              update.  If one of @a expressions does not yield a matching
 *              record to be updated, then the
 *              corresponding element from this list will be added to the
 *              table.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::update_records_global_expression: An
 *                 optional global expression to reduce the search space of the
 *                 predicates listed in @a expressions.  The default value is
 *                 ''.
 *                         <li> gpudb::update_records_bypass_safety_checks:
 *                 When set to @a true,
 *                 all predicates are available for primary key updates.  Keep
 *                 in mind that it is possible to destroy
 *                 data in this case, since a single predicate may match
 *                 multiple objects (potentially all of records
 *                 of a table), and then updating all of those records to have
 *                 the same primary key will, due to the
 *                 primary key uniqueness constraints, effectively delete all
 *                 but one of those updated records.
 *                 <ul>
 *                         <li> gpudb::update_records_true
 *                         <li> gpudb::update_records_false
 *                 </ul>
 *                 The default value is gpudb::update_records_false.
 *                         <li> gpudb::update_records_update_on_existing_pk:
 *                 Specifies the record collision policy for updating a table
 *                 with a
 *                 <a href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>.  There are two ways that a
 *                 record collision can
 *                 occur.
 *                 The first is an "update collision", which happens when the
 *                 update changes the value of the updated
 *                 record's primary key, and that new primary key already
 *                 exists as the primary key of another record
 *                 in the table.
 *                 The second is an "insert collision", which occurs when a
 *                 given filter in @a expressions
 *                 finds no records to update, and the alternate insert record
 *                 given in @a recordsToInsert (or
 *                 @a recordsToInsertStr) contains a primary key matching that
 *                 of an existing record in the
 *                 table.
 *                 If @a update_on_existing_pk is set to
 *                 @a true, "update collisions" will result in the
 *                 existing record collided into being removed and the record
 *                 updated with values specified in
 *                 @a newValuesMaps taking its place; "insert collisions" will
 *                 result in the collided-into
 *                 record being updated with the values in @a
 *                 recordsToInsert/@a recordsToInsertStr
 *                 (if given).
 *                 If set to @a false, the existing collided-into
 *                 record will remain unchanged, while the update will be
 *                 rejected and the error handled as determined
 *                 by @a ignore_existing_pk.  If the specified table does not
 *                 have a primary key,
 *                 then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::update_records_true: Overwrite the
 *                 collided-into record when updating a
 *                 record's primary key or inserting an alternate record causes
 *                 a primary key collision between the
 *                 record being updated/inserted and another existing record in
 *                 the table
 *                         <li> gpudb::update_records_false: Reject updates
 *                 which cause primary key collisions
 *                 between the record being updated/inserted and an existing
 *                 record in the table
 *                 </ul>
 *                 The default value is gpudb::update_records_false.
 *                         <li> gpudb::update_records_ignore_existing_pk:
 *                 Specifies the record collision error-suppression policy for
 *                 updating a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only used when primary
 *                 key record collisions are rejected (@a update_on_existing_pk
 *                 is
 *                 @a false).  If set to
 *                 @a true, any record update that is rejected for
 *                 resulting in a primary key collision with an existing table
 *                 record will be ignored with no error
 *                 generated.  If @a false, the rejection of any update
 *                 for resulting in a primary key collision will cause an error
 *                 to be reported.  If the specified table
 *                 does not have a primary key or if @a update_on_existing_pk
 *                 is
 *                 @a true, then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::update_records_true: Ignore updates that
 *                 result in primary key collisions with existing records
 *                         <li> gpudb::update_records_false: Treat as errors
 *                 any updates that result in primary key collisions with
 *                 existing records
 *                 </ul>
 *                 The default value is gpudb::update_records_false.
 *                         <li> gpudb::update_records_update_partition: Force
 *                 qualifying records to be deleted and reinserted so their
 *                 partition membership will be reevaluated.
 *                 <ul>
 *                         <li> gpudb::update_records_true
 *                         <li> gpudb::update_records_false
 *                 </ul>
 *                 The default value is gpudb::update_records_false.
 *                         <li> gpudb::update_records_truncate_strings: If set
 *                 to @a true, any strings which are too long for their charN
 *                 string fields will be truncated to fit.
 *                 <ul>
 *                         <li> gpudb::update_records_true
 *                         <li> gpudb::update_records_false
 *                 </ul>
 *                 The default value is gpudb::update_records_false.
 *                         <li>
 *                 gpudb::update_records_use_expressions_in_new_values_maps:
 *                 When set to @a true,
 *                 all new values in @a newValuesMaps are considered as
 *                 expression values. When set to
 *                 @a false, all new values in
 *                 @a newValuesMaps are considered as constants.  NOTE:  When
 *                 @a true, string constants will need
 *                 to be quoted to avoid being evaluated as expressions.
 *                 <ul>
 *                         <li> gpudb::update_records_true
 *                         <li> gpudb::update_records_false
 *                 </ul>
 *                 The default value is gpudb::update_records_false.
 *                         <li> gpudb::update_records_record_id: ID of a single
 *                 record to be updated (returned in the call to
 *                 /insert/records or /get/records/fromcollection).
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TRequest> 
UpdateRecordsResponse updateRecords( const std::string& tableName,
                                     const std::vector<std::string>& expressions,
                                     const std::vector<std::map<std::string, boost::optional<std::string> > >& newValuesMaps,
                                     const std::vector<TRequest>& data,
                                     const std::map<std::string, std::string>& options ) const
{
    RawUpdateRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.expressions = expressions;
    actualRequest_.newValuesMaps = newValuesMaps;
    avro::encode(actualRequest_.recordsToInsert, data, this->m_threadCount, this->m_executor);
    actualRequest_.options = options;
    UpdateRecordsResponse actualResponse_;
    submitRequest("/update/records", actualRequest_, actualResponse_, true);
    return actualResponse_;
}


/**
 * Runs multiple predicate-based updates in a single call.  With the
 * list of given expressions, any matching record's column values will be
 * updated
 * as provided in @a newValuesMaps.  There is also an optional 'upsert'
 * capability where if a particular predicate doesn't match any existing
 * record,
 * then a new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * result view.
 * <p>
 * This operation can update primary key values.  By default only
 * 'pure primary key' predicates are allowed when updating primary key values.
 * If
 * the primary key for a table is the column 'attr1', then the operation will
 * only
 * accept predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then
 * this operation will only accept predicates of the form:
 * "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns
 * must appear in an equality predicate in the expressions.  Furthermore each
 * 'pure primary key' predicate must be unique within a given request.  These
 * restrictions can be removed by utilizing some available options through
 * @a options.
 * <p>
 * The @a update_on_existing_pk option specifies the record primary key
 * collision
 * policy for tables with a <a href="../../../concepts/tables/#primary-keys"
 * target="_top">primary key</a>, while
 * @a ignore_existing_pk specifies the record primary key collision
 * error-suppression policy when those collisions result in the update being
 * rejected.  Both are
 * ignored on tables with no primary key.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param tableName  Name of table to be updated, in [schema_name.]table_name
 *                   format, using standard
 *                   <a href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be a
 *                   currently
 *                   existing table and not a view.
 * @param expressions  A list of the actual predicates, one for each update;
 *                     format should follow the guidelines /filter.
 * @param newValuesMaps  List of new values for the matching records.  Each
 *                       element is a map with
 *                       (key, value) pairs where the keys are the names of the
 *                       columns whose values are to be updated; the
 *                       values are the new values.  The number of elements in
 *                       the list should match the length of @a expressions.
 * @param data  An *optional* list of new binary-avro encoded records to
 *              insert, one for each
 *              update.  If one of @a expressions does not yield a matching
 *              record to be updated, then the
 *              corresponding element from this list will be added to the
 *              table.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::update_records_global_expression: An
 *                 optional global expression to reduce the search space of the
 *                 predicates listed in @a expressions.  The default value is
 *                 ''.
 *                         <li> gpudb::update_records_bypass_safety_checks:
 *                 When set to @a true,
 *                 all predicates are available for primary key updates.  Keep
 *                 in mind that it is possible to destroy
 *                 data in this case, since a single predicate may match
 *                 multiple objects (potentially all of records
 *                 of a table), and then updating all of those records to have
 *                 the same primary key will, due to the
 *                 primary key uniqueness constraints, effectively delete all
 *                 but one of those updated records.
 *                 <ul>
 *                         <li> gpudb::update_records_true
 *                         <li> gpudb::update_records_false
 *                 </ul>
 *                 The default value is gpudb::update_records_false.
 *                         <li> gpudb::update_records_update_on_existing_pk:
 *                 Specifies the record collision policy for updating a table
 *                 with a
 *                 <a href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>.  There are two ways that a
 *                 record collision can
 *                 occur.
 *                 The first is an "update collision", which happens when the
 *                 update changes the value of the updated
 *                 record's primary key, and that new primary key already
 *                 exists as the primary key of another record
 *                 in the table.
 *                 The second is an "insert collision", which occurs when a
 *                 given filter in @a expressions
 *                 finds no records to update, and the alternate insert record
 *                 given in @a recordsToInsert (or
 *                 @a recordsToInsertStr) contains a primary key matching that
 *                 of an existing record in the
 *                 table.
 *                 If @a update_on_existing_pk is set to
 *                 @a true, "update collisions" will result in the
 *                 existing record collided into being removed and the record
 *                 updated with values specified in
 *                 @a newValuesMaps taking its place; "insert collisions" will
 *                 result in the collided-into
 *                 record being updated with the values in @a
 *                 recordsToInsert/@a recordsToInsertStr
 *                 (if given).
 *                 If set to @a false, the existing collided-into
 *                 record will remain unchanged, while the update will be
 *                 rejected and the error handled as determined
 *                 by @a ignore_existing_pk.  If the specified table does not
 *                 have a primary key,
 *                 then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::update_records_true: Overwrite the
 *                 collided-into record when updating a
 *                 record's primary key or inserting an alternate record causes
 *                 a primary key collision between the
 *                 record being updated/inserted and another existing record in
 *                 the table
 *                         <li> gpudb::update_records_false: Reject updates
 *                 which cause primary key collisions
 *                 between the record being updated/inserted and an existing
 *                 record in the table
 *                 </ul>
 *                 The default value is gpudb::update_records_false.
 *                         <li> gpudb::update_records_ignore_existing_pk:
 *                 Specifies the record collision error-suppression policy for
 *                 updating a table with a <a
 *                 href="../../../concepts/tables/#primary-keys"
 *                 target="_top">primary key</a>, only used when primary
 *                 key record collisions are rejected (@a update_on_existing_pk
 *                 is
 *                 @a false).  If set to
 *                 @a true, any record update that is rejected for
 *                 resulting in a primary key collision with an existing table
 *                 record will be ignored with no error
 *                 generated.  If @a false, the rejection of any update
 *                 for resulting in a primary key collision will cause an error
 *                 to be reported.  If the specified table
 *                 does not have a primary key or if @a update_on_existing_pk
 *                 is
 *                 @a true, then this option has no effect.
 *                 <ul>
 *                         <li> gpudb::update_records_true: Ignore updates that
 *                 result in primary key collisions with existing records
 *                         <li> gpudb::update_records_false: Treat as errors
 *                 any updates that result in primary key collisions with
 *                 existing records
 *                 </ul>
 *                 The default value is gpudb::update_records_false.
 *                         <li> gpudb::update_records_update_partition: Force
 *                 qualifying records to be deleted and reinserted so their
 *                 partition membership will be reevaluated.
 *                 <ul>
 *                         <li> gpudb::update_records_true
 *                         <li> gpudb::update_records_false
 *                 </ul>
 *                 The default value is gpudb::update_records_false.
 *                         <li> gpudb::update_records_truncate_strings: If set
 *                 to @a true, any strings which are too long for their charN
 *                 string fields will be truncated to fit.
 *                 <ul>
 *                         <li> gpudb::update_records_true
 *                         <li> gpudb::update_records_false
 *                 </ul>
 *                 The default value is gpudb::update_records_false.
 *                         <li>
 *                 gpudb::update_records_use_expressions_in_new_values_maps:
 *                 When set to @a true,
 *                 all new values in @a newValuesMaps are considered as
 *                 expression values. When set to
 *                 @a false, all new values in
 *                 @a newValuesMaps are considered as constants.  NOTE:  When
 *                 @a true, string constants will need
 *                 to be quoted to avoid being evaluated as expressions.
 *                 <ul>
 *                         <li> gpudb::update_records_true
 *                         <li> gpudb::update_records_false
 *                 </ul>
 *                 The default value is gpudb::update_records_false.
 *                         <li> gpudb::update_records_record_id: ID of a single
 *                 record to be updated (returned in the call to
 *                 /insert/records or /get/records/fromcollection).
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TRequest> 
UpdateRecordsResponse& updateRecords( const std::string& tableName,
                                      const std::vector<std::string>& expressions,
                                      const std::vector<std::map<std::string, boost::optional<std::string> > >& newValuesMaps,
                                      const std::vector<TRequest>& data,
                                      const std::map<std::string, std::string>& options,
                                      UpdateRecordsResponse& response_ ) const
{
    RawUpdateRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.expressions = expressions;
    actualRequest_.newValuesMaps = newValuesMaps;
    avro::encode(actualRequest_.recordsToInsert, data, this->m_threadCount, this->m_executor);
    actualRequest_.options = options;
    submitRequest("/update/records", actualRequest_, response_, true);
    return response_;
}


/**
 * Updates the view specified by @a tableName to include full
 * series (track) information from the @a worldTableName for the series
 * (tracks) present in the @a viewName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UpdateRecordsBySeriesResponse updateRecordsBySeries( const UpdateRecordsBySeriesRequest& request_ ) const;

/**
 * Updates the view specified by @a tableName to include full
 * series (track) information from the @a worldTableName for the series
 * (tracks) present in the @a viewName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UpdateRecordsBySeriesResponse& updateRecordsBySeries( const UpdateRecordsBySeriesRequest& request_,
                                                      UpdateRecordsBySeriesResponse& response_ ) const;

/**
 * Updates the view specified by @a tableName to include full
 * series (track) information from the @a worldTableName for the series
 * (tracks) present in the @a viewName.
 * 
 * @param tableName  Name of the view on which the update operation will be
 *                   performed, in [schema_name.]view_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing view.
 * @param worldTableName  Name of the table containing the complete series
 *                        (track) information, in [schema_name.]table_name
 *                        format, using standard <a
 *                        href="../../../concepts/tables/#table-name-resolution"
 *                        target="_top">name resolution rules</a>.
 * @param viewName  Name of the view containing the series (tracks) which have
 *                  to be updated, in [schema_name.]view_name format, using
 *                  standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a>.
 * @param reserved
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UpdateRecordsBySeriesResponse updateRecordsBySeries( const std::string& tableName,
                                                     const std::string& worldTableName,
                                                     const std::string& viewName,
                                                     const std::vector<std::string>& reserved,
                                                     const std::map<std::string, std::string>& options ) const;

/**
 * Updates the view specified by @a tableName to include full
 * series (track) information from the @a worldTableName for the series
 * (tracks) present in the @a viewName.
 * 
 * @param tableName  Name of the view on which the update operation will be
 *                   performed, in [schema_name.]view_name format, using
 *                   standard <a
 *                   href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.  Must be an
 *                   existing view.
 * @param worldTableName  Name of the table containing the complete series
 *                        (track) information, in [schema_name.]table_name
 *                        format, using standard <a
 *                        href="../../../concepts/tables/#table-name-resolution"
 *                        target="_top">name resolution rules</a>.
 * @param viewName  Name of the view containing the series (tracks) which have
 *                  to be updated, in [schema_name.]view_name format, using
 *                  standard <a
 *                  href="../../../concepts/tables/#table-name-resolution"
 *                  target="_top">name resolution rules</a>.
 * @param reserved
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UpdateRecordsBySeriesResponse& updateRecordsBySeries( const std::string& tableName,
                                                      const std::string& worldTableName,
                                                      const std::string& viewName,
                                                      const std::vector<std::string>& reserved,
                                                      const std::map<std::string, std::string>& options,
                                                      UpdateRecordsBySeriesResponse& response_ ) const;

/**
 * Uploads one or more files to <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. There are
 * two methods for uploading files: load files in their entirety, or load files
 * in
 * parts. The latter is recommeded for files of approximately 60 MB or larger.
 * <p>
 * To upload files in their entirety, populate @a fileNames with the file
 * names to upload into on KiFS, and their respective byte content in
 * @a fileData.
 * <p>
 * Multiple steps are involved when uploading in multiple parts. Only one file
 * at a
 * time can be uploaded in this manner. A user-provided UUID is utilized to tie
 * all
 * the upload steps together for a given file.  To upload a file in multiple
 * parts:
 * <p>
 * 1. Provide the file name in @a fileNames, the UUID in
 *    the @a multipart_upload_uuid key in @a options, and
 *    a @a multipart_operation value of
 *    @a init.
 * 2. Upload one or more parts by providing the file name, the part data
 *    in @a fileData, the UUID, a @a multipart_operation
 *    value of @a upload_part, and
 *    the part number in the @a multipart_upload_part_number.
 *    The part numbers must start at 1 and increase incrementally.
 *    Parts may not be uploaded out of order.
 * 3. Complete the upload by providing the file name, the UUID, and a
 *    @a multipart_operation value of
 *    @a complete.
 * <p>
 * Multipart uploads in progress may be canceled by providing the file name,
 * the
 * UUID, and a @a multipart_operation value of
 * @a cancel.  If an new upload is
 * initialized with a different UUID for an existing upload in progress, the
 * pre-existing upload is automatically canceled in favor of the new upload.
 * <p>
 * The multipart upload must be completed for the file to be usable in KiFS.
 * Information about multipart uploads in progress is available in
 * {@link #showFiles(const ShowFilesRequest&) const}.
 * <p>
 * File data may be pre-encoded using base64 encoding. This should be indicated
 * using the @a file_encoding option, and is recommended when
 * using JSON serialization.
 * <p>
 * Each file path must reside in a top-level KiFS directory, i.e. one of the
 * directories listed in {@link
 * #showDirectories(const ShowDirectoriesRequest&) const}. The user must
 * have write
 * permission on the directory. Nested directories are permitted in file name
 * paths. Directories are deliniated with the directory separator of '/'.  For
 * example, given the file path '/a/b/c/d.txt', 'a' must be a KiFS directory.
 * <p>
 * These characters are allowed in file name paths: letters, numbers, spaces,
 * the
 * path delimiter of '/', and the characters: '.' '-' ':' '[' ']' '(' ')' '#'
 * '='.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UploadFilesResponse uploadFiles( const UploadFilesRequest& request_ ) const;

/**
 * Uploads one or more files to <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. There are
 * two methods for uploading files: load files in their entirety, or load files
 * in
 * parts. The latter is recommeded for files of approximately 60 MB or larger.
 * <p>
 * To upload files in their entirety, populate @a fileNames with the file
 * names to upload into on KiFS, and their respective byte content in
 * @a fileData.
 * <p>
 * Multiple steps are involved when uploading in multiple parts. Only one file
 * at a
 * time can be uploaded in this manner. A user-provided UUID is utilized to tie
 * all
 * the upload steps together for a given file.  To upload a file in multiple
 * parts:
 * <p>
 * 1. Provide the file name in @a fileNames, the UUID in
 *    the @a multipart_upload_uuid key in @a options, and
 *    a @a multipart_operation value of
 *    @a init.
 * 2. Upload one or more parts by providing the file name, the part data
 *    in @a fileData, the UUID, a @a multipart_operation
 *    value of @a upload_part, and
 *    the part number in the @a multipart_upload_part_number.
 *    The part numbers must start at 1 and increase incrementally.
 *    Parts may not be uploaded out of order.
 * 3. Complete the upload by providing the file name, the UUID, and a
 *    @a multipart_operation value of
 *    @a complete.
 * <p>
 * Multipart uploads in progress may be canceled by providing the file name,
 * the
 * UUID, and a @a multipart_operation value of
 * @a cancel.  If an new upload is
 * initialized with a different UUID for an existing upload in progress, the
 * pre-existing upload is automatically canceled in favor of the new upload.
 * <p>
 * The multipart upload must be completed for the file to be usable in KiFS.
 * Information about multipart uploads in progress is available in
 * {@link #showFiles(const ShowFilesRequest&,ShowFilesResponse&) const}.
 * <p>
 * File data may be pre-encoded using base64 encoding. This should be indicated
 * using the @a file_encoding option, and is recommended when
 * using JSON serialization.
 * <p>
 * Each file path must reside in a top-level KiFS directory, i.e. one of the
 * directories listed in {@link
 * #showDirectories(const ShowDirectoriesRequest&,ShowDirectoriesResponse&) const}.
 * The user must have write
 * permission on the directory. Nested directories are permitted in file name
 * paths. Directories are deliniated with the directory separator of '/'.  For
 * example, given the file path '/a/b/c/d.txt', 'a' must be a KiFS directory.
 * <p>
 * These characters are allowed in file name paths: letters, numbers, spaces,
 * the
 * path delimiter of '/', and the characters: '.' '-' ':' '[' ']' '(' ')' '#'
 * '='.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UploadFilesResponse& uploadFiles( const UploadFilesRequest& request_,
                                  UploadFilesResponse& response_ ) const;

/**
 * Uploads one or more files to <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. There are
 * two methods for uploading files: load files in their entirety, or load files
 * in
 * parts. The latter is recommeded for files of approximately 60 MB or larger.
 * <p>
 * To upload files in their entirety, populate @a fileNames with the file
 * names to upload into on KiFS, and their respective byte content in
 * @a fileData.
 * <p>
 * Multiple steps are involved when uploading in multiple parts. Only one file
 * at a
 * time can be uploaded in this manner. A user-provided UUID is utilized to tie
 * all
 * the upload steps together for a given file.  To upload a file in multiple
 * parts:
 * <p>
 * 1. Provide the file name in @a fileNames, the UUID in
 *    the @a multipart_upload_uuid key in @a options, and
 *    a @a multipart_operation value of
 *    @a init.
 * 2. Upload one or more parts by providing the file name, the part data
 *    in @a fileData, the UUID, a @a multipart_operation
 *    value of @a upload_part, and
 *    the part number in the @a multipart_upload_part_number.
 *    The part numbers must start at 1 and increase incrementally.
 *    Parts may not be uploaded out of order.
 * 3. Complete the upload by providing the file name, the UUID, and a
 *    @a multipart_operation value of
 *    @a complete.
 * <p>
 * Multipart uploads in progress may be canceled by providing the file name,
 * the
 * UUID, and a @a multipart_operation value of
 * @a cancel.  If an new upload is
 * initialized with a different UUID for an existing upload in progress, the
 * pre-existing upload is automatically canceled in favor of the new upload.
 * <p>
 * The multipart upload must be completed for the file to be usable in KiFS.
 * Information about multipart uploads in progress is available in
 * {@link
 * #showFiles(const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * File data may be pre-encoded using base64 encoding. This should be indicated
 * using the @a file_encoding option, and is recommended when
 * using JSON serialization.
 * <p>
 * Each file path must reside in a top-level KiFS directory, i.e. one of the
 * directories listed in {@link
 * #showDirectories(const std::string&,const std::map<std::string, std::string>&) const}.
 * The user must have write
 * permission on the directory. Nested directories are permitted in file name
 * paths. Directories are deliniated with the directory separator of '/'.  For
 * example, given the file path '/a/b/c/d.txt', 'a' must be a KiFS directory.
 * <p>
 * These characters are allowed in file name paths: letters, numbers, spaces,
 * the
 * path delimiter of '/', and the characters: '.' '-' ':' '[' ']' '(' ')' '#'
 * '='.
 * 
 * @param fileNames  An array of full file name paths to be used for the files
 *                   uploaded to KiFS. File names may have any number of nested
 *                   directories in their
 *                   paths, but the top-level directory must be an existing
 *                   KiFS directory. Each file
 *                   must reside in or under a top-level directory. A full file
 *                   name path cannot be
 *                   larger than 1024 characters.
 * @param fileData  File data for the files being uploaded, for the respective
 *                  files in @a fileNames.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::upload_files_file_encoding: Encoding
 *                 that has been applied to the uploaded
 *                 file data. When using JSON serialization it is recommended
 *                 to utilize
 *                 @a base64. The caller is responsible
 *                 for encoding the data provided in this payload
 *                 <ul>
 *                         <li> gpudb::upload_files_base64: Specifies that the
 *                 file data being uploaded has been base64 encoded.
 *                         <li> gpudb::upload_files_none: The uploaded file
 *                 data has not been encoded.
 *                 </ul>
 *                 The default value is gpudb::upload_files_none.
 *                         <li> gpudb::upload_files_multipart_operation:
 *                 Multipart upload operation to perform
 *                 <ul>
 *                         <li> gpudb::upload_files_none: Default, indicates
 *                 this is not a multipart upload
 *                         <li> gpudb::upload_files_init: Initialize a
 *                 multipart file upload
 *                         <li> gpudb::upload_files_upload_part: Uploads a part
 *                 of the specified multipart file upload
 *                         <li> gpudb::upload_files_complete: Complete the
 *                 specified multipart file upload
 *                         <li> gpudb::upload_files_cancel: Cancel the
 *                 specified multipart file upload
 *                 </ul>
 *                 The default value is gpudb::upload_files_none.
 *                         <li> gpudb::upload_files_multipart_upload_uuid: UUID
 *                 to uniquely identify a multipart upload
 *                         <li>
 *                 gpudb::upload_files_multipart_upload_part_number:
 *                 Incremental part number for each part in a
 *                 multipart upload. Part numbers start at 1, increment by 1,
 *                 and must be uploaded
 *                 sequentially
 *                         <li> gpudb::upload_files_delete_if_exists: If @a
 *                 true,
 *                 any existing files specified in @a fileNames will be deleted
 *                 prior to start of upload.
 *                 Otherwise the file is replaced once the upload completes.
 *                 Rollback of the original file is
 *                 no longer possible if the upload is cancelled, aborted or
 *                 fails if the file was deleted beforehand.
 *                 <ul>
 *                         <li> gpudb::upload_files_true
 *                         <li> gpudb::upload_files_false
 *                 </ul>
 *                 The default value is gpudb::upload_files_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UploadFilesResponse uploadFiles( const std::vector<std::string>& fileNames,
                                 const std::vector<std::vector<uint8_t> >& fileData,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Uploads one or more files to <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. There are
 * two methods for uploading files: load files in their entirety, or load files
 * in
 * parts. The latter is recommeded for files of approximately 60 MB or larger.
 * <p>
 * To upload files in their entirety, populate @a fileNames with the file
 * names to upload into on KiFS, and their respective byte content in
 * @a fileData.
 * <p>
 * Multiple steps are involved when uploading in multiple parts. Only one file
 * at a
 * time can be uploaded in this manner. A user-provided UUID is utilized to tie
 * all
 * the upload steps together for a given file.  To upload a file in multiple
 * parts:
 * <p>
 * 1. Provide the file name in @a fileNames, the UUID in
 *    the @a multipart_upload_uuid key in @a options, and
 *    a @a multipart_operation value of
 *    @a init.
 * 2. Upload one or more parts by providing the file name, the part data
 *    in @a fileData, the UUID, a @a multipart_operation
 *    value of @a upload_part, and
 *    the part number in the @a multipart_upload_part_number.
 *    The part numbers must start at 1 and increase incrementally.
 *    Parts may not be uploaded out of order.
 * 3. Complete the upload by providing the file name, the UUID, and a
 *    @a multipart_operation value of
 *    @a complete.
 * <p>
 * Multipart uploads in progress may be canceled by providing the file name,
 * the
 * UUID, and a @a multipart_operation value of
 * @a cancel.  If an new upload is
 * initialized with a different UUID for an existing upload in progress, the
 * pre-existing upload is automatically canceled in favor of the new upload.
 * <p>
 * The multipart upload must be completed for the file to be usable in KiFS.
 * Information about multipart uploads in progress is available in
 * {@link
 * #showFiles(const std::vector<std::string>&,const std::map<std::string, std::string>&,ShowFilesResponse&) const}.
 * <p>
 * File data may be pre-encoded using base64 encoding. This should be indicated
 * using the @a file_encoding option, and is recommended when
 * using JSON serialization.
 * <p>
 * Each file path must reside in a top-level KiFS directory, i.e. one of the
 * directories listed in {@link
 * #showDirectories(const std::string&,const std::map<std::string, std::string>&,ShowDirectoriesResponse&) const}.
 * The user must have write
 * permission on the directory. Nested directories are permitted in file name
 * paths. Directories are deliniated with the directory separator of '/'.  For
 * example, given the file path '/a/b/c/d.txt', 'a' must be a KiFS directory.
 * <p>
 * These characters are allowed in file name paths: letters, numbers, spaces,
 * the
 * path delimiter of '/', and the characters: '.' '-' ':' '[' ']' '(' ')' '#'
 * '='.
 * 
 * @param fileNames  An array of full file name paths to be used for the files
 *                   uploaded to KiFS. File names may have any number of nested
 *                   directories in their
 *                   paths, but the top-level directory must be an existing
 *                   KiFS directory. Each file
 *                   must reside in or under a top-level directory. A full file
 *                   name path cannot be
 *                   larger than 1024 characters.
 * @param fileData  File data for the files being uploaded, for the respective
 *                  files in @a fileNames.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::upload_files_file_encoding: Encoding
 *                 that has been applied to the uploaded
 *                 file data. When using JSON serialization it is recommended
 *                 to utilize
 *                 @a base64. The caller is responsible
 *                 for encoding the data provided in this payload
 *                 <ul>
 *                         <li> gpudb::upload_files_base64: Specifies that the
 *                 file data being uploaded has been base64 encoded.
 *                         <li> gpudb::upload_files_none: The uploaded file
 *                 data has not been encoded.
 *                 </ul>
 *                 The default value is gpudb::upload_files_none.
 *                         <li> gpudb::upload_files_multipart_operation:
 *                 Multipart upload operation to perform
 *                 <ul>
 *                         <li> gpudb::upload_files_none: Default, indicates
 *                 this is not a multipart upload
 *                         <li> gpudb::upload_files_init: Initialize a
 *                 multipart file upload
 *                         <li> gpudb::upload_files_upload_part: Uploads a part
 *                 of the specified multipart file upload
 *                         <li> gpudb::upload_files_complete: Complete the
 *                 specified multipart file upload
 *                         <li> gpudb::upload_files_cancel: Cancel the
 *                 specified multipart file upload
 *                 </ul>
 *                 The default value is gpudb::upload_files_none.
 *                         <li> gpudb::upload_files_multipart_upload_uuid: UUID
 *                 to uniquely identify a multipart upload
 *                         <li>
 *                 gpudb::upload_files_multipart_upload_part_number:
 *                 Incremental part number for each part in a
 *                 multipart upload. Part numbers start at 1, increment by 1,
 *                 and must be uploaded
 *                 sequentially
 *                         <li> gpudb::upload_files_delete_if_exists: If @a
 *                 true,
 *                 any existing files specified in @a fileNames will be deleted
 *                 prior to start of upload.
 *                 Otherwise the file is replaced once the upload completes.
 *                 Rollback of the original file is
 *                 no longer possible if the upload is cancelled, aborted or
 *                 fails if the file was deleted beforehand.
 *                 <ul>
 *                         <li> gpudb::upload_files_true
 *                         <li> gpudb::upload_files_false
 *                 </ul>
 *                 The default value is gpudb::upload_files_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UploadFilesResponse& uploadFiles( const std::vector<std::string>& fileNames,
                                  const std::vector<std::vector<uint8_t> >& fileData,
                                  const std::map<std::string, std::string>& options,
                                  UploadFilesResponse& response_ ) const;

/**
 * Uploads one or more files to <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * <p>
 * Each file path must reside in a top-level KiFS directory, i.e. one of the
 * directories listed in {@link
 * #showDirectories(const ShowDirectoriesRequest&) const}. The user must
 * have write
 * permission on the directory. Nested directories are permitted in file name
 * paths. Directories are deliniated with the directory separator of '/'.  For
 * example, given the file path '/a/b/c/d.txt', 'a' must be a KiFS directory.
 * <p>
 * These characters are allowed in file name paths: letters, numbers, spaces,
 * the
 * path delimiter of '/', and the characters: '.' '-' ':' '[' ']' '(' ')' '#'
 * '='.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UploadFilesFromurlResponse uploadFilesFromurl( const UploadFilesFromurlRequest& request_ ) const;

/**
 * Uploads one or more files to <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * <p>
 * Each file path must reside in a top-level KiFS directory, i.e. one of the
 * directories listed in {@link
 * #showDirectories(const ShowDirectoriesRequest&,ShowDirectoriesResponse&) const}.
 * The user must have write
 * permission on the directory. Nested directories are permitted in file name
 * paths. Directories are deliniated with the directory separator of '/'.  For
 * example, given the file path '/a/b/c/d.txt', 'a' must be a KiFS directory.
 * <p>
 * These characters are allowed in file name paths: letters, numbers, spaces,
 * the
 * path delimiter of '/', and the characters: '.' '-' ':' '[' ']' '(' ')' '#'
 * '='.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UploadFilesFromurlResponse& uploadFilesFromurl( const UploadFilesFromurlRequest& request_,
                                                UploadFilesFromurlResponse& response_ ) const;

/**
 * Uploads one or more files to <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * <p>
 * Each file path must reside in a top-level KiFS directory, i.e. one of the
 * directories listed in {@link
 * #showDirectories(const std::string&,const std::map<std::string, std::string>&) const}.
 * The user must have write
 * permission on the directory. Nested directories are permitted in file name
 * paths. Directories are deliniated with the directory separator of '/'.  For
 * example, given the file path '/a/b/c/d.txt', 'a' must be a KiFS directory.
 * <p>
 * These characters are allowed in file name paths: letters, numbers, spaces,
 * the
 * path delimiter of '/', and the characters: '.' '-' ':' '[' ']' '(' ')' '#'
 * '='.
 * 
 * @param fileNames  An array of full file name paths to be used for the files
 *                   uploaded to KiFS. File names may have any number of nested
 *                   directories in their
 *                   paths, but the top-level directory must be an existing
 *                   KiFS directory. Each file
 *                   must reside in or under a top-level directory. A full file
 *                   name path cannot be
 *                   larger than 1024 characters.
 * @param urls  List of URLs to upload, for each respective file in @a
 *              fileNames.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UploadFilesFromurlResponse uploadFilesFromurl( const std::vector<std::string>& fileNames,
                                               const std::vector<std::string>& urls,
                                               const std::map<std::string, std::string>& options ) const;

/**
 * Uploads one or more files to <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * <p>
 * Each file path must reside in a top-level KiFS directory, i.e. one of the
 * directories listed in {@link
 * #showDirectories(const std::string&,const std::map<std::string, std::string>&,ShowDirectoriesResponse&) const}.
 * The user must have write
 * permission on the directory. Nested directories are permitted in file name
 * paths. Directories are deliniated with the directory separator of '/'.  For
 * example, given the file path '/a/b/c/d.txt', 'a' must be a KiFS directory.
 * <p>
 * These characters are allowed in file name paths: letters, numbers, spaces,
 * the
 * path delimiter of '/', and the characters: '.' '-' ':' '[' ']' '(' ')' '#'
 * '='.
 * 
 * @param fileNames  An array of full file name paths to be used for the files
 *                   uploaded to KiFS. File names may have any number of nested
 *                   directories in their
 *                   paths, but the top-level directory must be an existing
 *                   KiFS directory. Each file
 *                   must reside in or under a top-level directory. A full file
 *                   name path cannot be
 *                   larger than 1024 characters.
 * @param urls  List of URLs to upload, for each respective file in @a
 *              fileNames.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UploadFilesFromurlResponse& uploadFilesFromurl( const std::vector<std::string>& fileNames,
                                                const std::vector<std::string>& urls,
                                                const std::map<std::string, std::string>& options,
                                                UploadFilesFromurlResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeGetFeatureInfoResponse visualizeGetFeatureInfo( const VisualizeGetFeatureInfoRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeGetFeatureInfoResponse& visualizeGetFeatureInfo( const VisualizeGetFeatureInfoRequest& request_,
                                                          VisualizeGetFeatureInfoResponse& response_ ) const;

/**
 * @private
 * 
 * @param tableNames
 * @param xColumnNames
 * @param yColumnNames
 * @param geometryColumnNames
 * @param queryColumnNames
 * @param projection
 *                    <ul>
 *                            <li>
 *                    gpudb::visualize_get_feature_info_plate_carree
 *                            <li>
 *                    gpudb::visualize_get_feature_info_web_mercator
 *                    </ul>
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param x
 * @param y
 * @param radius
 * @param limit
 * @param encoding
 *                  <ul>
 *                          <li> gpudb::visualize_get_feature_info_binary
 *                          <li> gpudb::visualize_get_feature_info_json
 *                          <li> gpudb::visualize_get_feature_info_geojson
 *                          <li> gpudb::visualize_get_feature_info_html
 *                  </ul>
 * @param options
 *                 <ul>
 *                         <li>
 *                 gpudb::visualize_get_feature_info_auto_column_selection:
 *                 <ul>
 *                         <li> gpudb::visualize_get_feature_info_false
 *                         <li> gpudb::visualize_get_feature_info_true
 *                 </ul>
 *                 The default value is
 *                 gpudb::visualize_get_feature_info_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeGetFeatureInfoResponse visualizeGetFeatureInfo( const std::vector<std::string>& tableNames,
                                                         const std::vector<std::string>& xColumnNames,
                                                         const std::vector<std::string>& yColumnNames,
                                                         const std::vector<std::string>& geometryColumnNames,
                                                         const std::vector<std::vector<std::string> >& queryColumnNames,
                                                         const std::string& projection,
                                                         const double minX,
                                                         const double maxX,
                                                         const double minY,
                                                         const double maxY,
                                                         const int32_t width,
                                                         const int32_t height,
                                                         const int32_t x,
                                                         const int32_t y,
                                                         const int32_t radius,
                                                         const int64_t limit,
                                                         const std::string& encoding,
                                                         const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param tableNames
 * @param xColumnNames
 * @param yColumnNames
 * @param geometryColumnNames
 * @param queryColumnNames
 * @param projection
 *                    <ul>
 *                            <li>
 *                    gpudb::visualize_get_feature_info_plate_carree
 *                            <li>
 *                    gpudb::visualize_get_feature_info_web_mercator
 *                    </ul>
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param x
 * @param y
 * @param radius
 * @param limit
 * @param encoding
 *                  <ul>
 *                          <li> gpudb::visualize_get_feature_info_binary
 *                          <li> gpudb::visualize_get_feature_info_json
 *                          <li> gpudb::visualize_get_feature_info_geojson
 *                          <li> gpudb::visualize_get_feature_info_html
 *                  </ul>
 * @param options
 *                 <ul>
 *                         <li>
 *                 gpudb::visualize_get_feature_info_auto_column_selection:
 *                 <ul>
 *                         <li> gpudb::visualize_get_feature_info_false
 *                         <li> gpudb::visualize_get_feature_info_true
 *                 </ul>
 *                 The default value is
 *                 gpudb::visualize_get_feature_info_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeGetFeatureInfoResponse& visualizeGetFeatureInfo( const std::vector<std::string>& tableNames,
                                                          const std::vector<std::string>& xColumnNames,
                                                          const std::vector<std::string>& yColumnNames,
                                                          const std::vector<std::string>& geometryColumnNames,
                                                          const std::vector<std::vector<std::string> >& queryColumnNames,
                                                          const std::string& projection,
                                                          const double minX,
                                                          const double maxX,
                                                          const double minY,
                                                          const double maxY,
                                                          const int32_t width,
                                                          const int32_t height,
                                                          const int32_t x,
                                                          const int32_t y,
                                                          const int32_t radius,
                                                          const int64_t limit,
                                                          const std::string& encoding,
                                                          const std::map<std::string, std::string>& options,
                                                          VisualizeGetFeatureInfoResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageResponse visualizeImage( const VisualizeImageRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageResponse& visualizeImage( const VisualizeImageRequest& request_,
                                        VisualizeImageResponse& response_ ) const;

/**
 * @private
 * 
 * @param tableNames
 * @param worldTableNames
 * @param xColumnName
 * @param yColumnName
 * @param symbolColumnName
 * @param geometryColumnName
 * @param trackIds
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_EPSG_4326
 *                            <li> gpudb::visualize_image_PLATE_CARREE
 *                            <li> gpudb::visualize_image_900913
 *                            <li> gpudb::visualize_image_EPSG_900913
 *                            <li> gpudb::visualize_image_102100
 *                            <li> gpudb::visualize_image_EPSG_102100
 *                            <li> gpudb::visualize_image_3857
 *                            <li> gpudb::visualize_image_EPSG_3857
 *                            <li> gpudb::visualize_image_WEB_MERCATOR
 *                    </ul>
 *                    The default value is gpudb::visualize_image_PLATE_CARREE.
 * @param bgColor
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_image_do_points:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_true.
 *                              <li> gpudb::visualize_image_do_shapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_true.
 *                              <li> gpudb::visualize_image_do_tracks:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_true.
 *                              <li> gpudb::visualize_image_do_symbology:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_false.
 *                              <li> gpudb::visualize_image_pointcolors
 *                              <li> gpudb::visualize_image_pointsizes:   The
 *                      default value is '3'.
 *                              <li> gpudb::visualize_image_pointoffset_x:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_pointoffset_y:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_pointshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_none
 *                              <li> gpudb::visualize_image_circle
 *                              <li> gpudb::visualize_image_square
 *                              <li> gpudb::visualize_image_diamond
 *                              <li> gpudb::visualize_image_hollowcircle
 *                              <li> gpudb::visualize_image_hollowsquare
 *                              <li> gpudb::visualize_image_hollowdiamond
 *                              <li> gpudb::visualize_image_symbolcode
 *                              <li> gpudb::visualize_image_dash
 *                              <li> gpudb::visualize_image_pipe
 *                              <li> gpudb::visualize_image_plus
 *                              <li>
 *                      gpudb::visualize_image_hollowsquarewithplus
 *                              <li> gpudb::visualize_image_dot
 *                      </ul>
 *                      The default value is gpudb::visualize_image_square.
 *                              <li> gpudb::visualize_image_symbolrotations:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_shapelinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_shapelinecolors:
 *                      The default value is 'FFFF00 '.
 *                              <li> gpudb::visualize_image_shapelinepatterns:
 *                      The default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_shapelinepatternlen:   The
 *                      default value is '32'.
 *                              <li> gpudb::visualize_image_shapefillcolors:
 *                      The default value is '-1'.
 *                              <li> gpudb::visualize_image_hashlineintervals:
 *                      The default value is '20'.
 *                              <li> gpudb::visualize_image_hashlinecolors:
 *                      The default value is 'The same as line color.'.
 *                              <li> gpudb::visualize_image_hashlineangles:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_hashlinelens:   The
 *                      default value is '0'.
 *                              <li> gpudb::visualize_image_hashlinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_tracklinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_tracklinecolors:
 *                      The default value is '00FF00'.
 *                              <li> gpudb::visualize_image_trackmarkersizes:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_trackmarkercolors:
 *                      The default value is '0000FF'.
 *                              <li> gpudb::visualize_image_trackmarkershapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_none
 *                              <li> gpudb::visualize_image_circle
 *                              <li> gpudb::visualize_image_square
 *                              <li> gpudb::visualize_image_diamond
 *                              <li> gpudb::visualize_image_hollowcircle
 *                              <li> gpudb::visualize_image_hollowsquare
 *                              <li> gpudb::visualize_image_hollowdiamond
 *                              <li> gpudb::visualize_image_oriented_arrow
 *                              <li> gpudb::visualize_image_oriented_triangle
 *                              <li> gpudb::visualize_image_symbolcode
 *                              <li> gpudb::visualize_image_dash
 *                              <li> gpudb::visualize_image_pipe
 *                              <li> gpudb::visualize_image_plus
 *                              <li>
 *                      gpudb::visualize_image_hollowsquarewithplus
 *                              <li> gpudb::visualize_image_dot
 *                      </ul>
 *                      The default value is gpudb::visualize_image_circle.
 *                              <li> gpudb::visualize_image_trackheadcolors:
 *                      The default value is 'FFFFFF'.
 *                              <li> gpudb::visualize_image_trackheadsizes:
 *                      The default value is '10'.
 *                              <li> gpudb::visualize_image_trackheadshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_none
 *                              <li> gpudb::visualize_image_circle
 *                              <li> gpudb::visualize_image_square
 *                              <li> gpudb::visualize_image_diamond
 *                              <li> gpudb::visualize_image_hollowcircle
 *                              <li> gpudb::visualize_image_hollowsquare
 *                              <li> gpudb::visualize_image_hollowdiamond
 *                              <li> gpudb::visualize_image_symbolcode
 *                              <li> gpudb::visualize_image_dash
 *                              <li> gpudb::visualize_image_pipe
 *                              <li> gpudb::visualize_image_plus
 *                              <li>
 *                      gpudb::visualize_image_hollowsquarewithplus
 *                              <li> gpudb::visualize_image_dot
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_hollowdiamond.
 *                      </ul>
 * @param options
 *                 <ul>
 *                         <li> gpudb::visualize_image_pointcolor_attr
 *                         <li> gpudb::visualize_image_shapefillcolor_attr
 *                         <li> gpudb::visualize_image_track_id_column_name
 *                         <li> gpudb::visualize_image_track_order_column_name
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageResponse visualizeImage( const std::vector<std::string>& tableNames,
                                       const std::vector<std::string>& worldTableNames,
                                       const std::string& xColumnName,
                                       const std::string& yColumnName,
                                       const std::string& symbolColumnName,
                                       const std::string& geometryColumnName,
                                       const std::vector<std::vector<std::string> >& trackIds,
                                       const double minX,
                                       const double maxX,
                                       const double minY,
                                       const double maxY,
                                       const int32_t width,
                                       const int32_t height,
                                       const std::string& projection,
                                       const int64_t bgColor,
                                       const std::map<std::string, std::vector<std::string> >& styleOptions,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param tableNames
 * @param worldTableNames
 * @param xColumnName
 * @param yColumnName
 * @param symbolColumnName
 * @param geometryColumnName
 * @param trackIds
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_EPSG_4326
 *                            <li> gpudb::visualize_image_PLATE_CARREE
 *                            <li> gpudb::visualize_image_900913
 *                            <li> gpudb::visualize_image_EPSG_900913
 *                            <li> gpudb::visualize_image_102100
 *                            <li> gpudb::visualize_image_EPSG_102100
 *                            <li> gpudb::visualize_image_3857
 *                            <li> gpudb::visualize_image_EPSG_3857
 *                            <li> gpudb::visualize_image_WEB_MERCATOR
 *                    </ul>
 *                    The default value is gpudb::visualize_image_PLATE_CARREE.
 * @param bgColor
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_image_do_points:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_true.
 *                              <li> gpudb::visualize_image_do_shapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_true.
 *                              <li> gpudb::visualize_image_do_tracks:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_true.
 *                              <li> gpudb::visualize_image_do_symbology:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_false.
 *                              <li> gpudb::visualize_image_pointcolors
 *                              <li> gpudb::visualize_image_pointsizes:   The
 *                      default value is '3'.
 *                              <li> gpudb::visualize_image_pointoffset_x:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_pointoffset_y:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_pointshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_none
 *                              <li> gpudb::visualize_image_circle
 *                              <li> gpudb::visualize_image_square
 *                              <li> gpudb::visualize_image_diamond
 *                              <li> gpudb::visualize_image_hollowcircle
 *                              <li> gpudb::visualize_image_hollowsquare
 *                              <li> gpudb::visualize_image_hollowdiamond
 *                              <li> gpudb::visualize_image_symbolcode
 *                              <li> gpudb::visualize_image_dash
 *                              <li> gpudb::visualize_image_pipe
 *                              <li> gpudb::visualize_image_plus
 *                              <li>
 *                      gpudb::visualize_image_hollowsquarewithplus
 *                              <li> gpudb::visualize_image_dot
 *                      </ul>
 *                      The default value is gpudb::visualize_image_square.
 *                              <li> gpudb::visualize_image_symbolrotations:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_shapelinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_shapelinecolors:
 *                      The default value is 'FFFF00 '.
 *                              <li> gpudb::visualize_image_shapelinepatterns:
 *                      The default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_shapelinepatternlen:   The
 *                      default value is '32'.
 *                              <li> gpudb::visualize_image_shapefillcolors:
 *                      The default value is '-1'.
 *                              <li> gpudb::visualize_image_hashlineintervals:
 *                      The default value is '20'.
 *                              <li> gpudb::visualize_image_hashlinecolors:
 *                      The default value is 'The same as line color.'.
 *                              <li> gpudb::visualize_image_hashlineangles:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_hashlinelens:   The
 *                      default value is '0'.
 *                              <li> gpudb::visualize_image_hashlinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_tracklinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_tracklinecolors:
 *                      The default value is '00FF00'.
 *                              <li> gpudb::visualize_image_trackmarkersizes:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_trackmarkercolors:
 *                      The default value is '0000FF'.
 *                              <li> gpudb::visualize_image_trackmarkershapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_none
 *                              <li> gpudb::visualize_image_circle
 *                              <li> gpudb::visualize_image_square
 *                              <li> gpudb::visualize_image_diamond
 *                              <li> gpudb::visualize_image_hollowcircle
 *                              <li> gpudb::visualize_image_hollowsquare
 *                              <li> gpudb::visualize_image_hollowdiamond
 *                              <li> gpudb::visualize_image_oriented_arrow
 *                              <li> gpudb::visualize_image_oriented_triangle
 *                              <li> gpudb::visualize_image_symbolcode
 *                              <li> gpudb::visualize_image_dash
 *                              <li> gpudb::visualize_image_pipe
 *                              <li> gpudb::visualize_image_plus
 *                              <li>
 *                      gpudb::visualize_image_hollowsquarewithplus
 *                              <li> gpudb::visualize_image_dot
 *                      </ul>
 *                      The default value is gpudb::visualize_image_circle.
 *                              <li> gpudb::visualize_image_trackheadcolors:
 *                      The default value is 'FFFFFF'.
 *                              <li> gpudb::visualize_image_trackheadsizes:
 *                      The default value is '10'.
 *                              <li> gpudb::visualize_image_trackheadshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_none
 *                              <li> gpudb::visualize_image_circle
 *                              <li> gpudb::visualize_image_square
 *                              <li> gpudb::visualize_image_diamond
 *                              <li> gpudb::visualize_image_hollowcircle
 *                              <li> gpudb::visualize_image_hollowsquare
 *                              <li> gpudb::visualize_image_hollowdiamond
 *                              <li> gpudb::visualize_image_symbolcode
 *                              <li> gpudb::visualize_image_dash
 *                              <li> gpudb::visualize_image_pipe
 *                              <li> gpudb::visualize_image_plus
 *                              <li>
 *                      gpudb::visualize_image_hollowsquarewithplus
 *                              <li> gpudb::visualize_image_dot
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_hollowdiamond.
 *                      </ul>
 * @param options
 *                 <ul>
 *                         <li> gpudb::visualize_image_pointcolor_attr
 *                         <li> gpudb::visualize_image_shapefillcolor_attr
 *                         <li> gpudb::visualize_image_track_id_column_name
 *                         <li> gpudb::visualize_image_track_order_column_name
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageResponse& visualizeImage( const std::vector<std::string>& tableNames,
                                        const std::vector<std::string>& worldTableNames,
                                        const std::string& xColumnName,
                                        const std::string& yColumnName,
                                        const std::string& symbolColumnName,
                                        const std::string& geometryColumnName,
                                        const std::vector<std::vector<std::string> >& trackIds,
                                        const double minX,
                                        const double maxX,
                                        const double minY,
                                        const double maxY,
                                        const int32_t width,
                                        const int32_t height,
                                        const std::string& projection,
                                        const int64_t bgColor,
                                        const std::map<std::string, std::vector<std::string> >& styleOptions,
                                        const std::map<std::string, std::string>& options,
                                        VisualizeImageResponse& response_ ) const;

/**
 * Scatter plot is the only plot type currently supported. A non-numeric column
 * can be specified as x or y column and jitters can be added to them to avoid
 * excessive overlapping. All color values must be in the format RRGGBB or
 * AARRGGBB (to specify the alpha value).
 * The image is contained in the @a imageData field.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageChartResponse visualizeImageChart( const VisualizeImageChartRequest& request_ ) const;

/**
 * Scatter plot is the only plot type currently supported. A non-numeric column
 * can be specified as x or y column and jitters can be added to them to avoid
 * excessive overlapping. All color values must be in the format RRGGBB or
 * AARRGGBB (to specify the alpha value).
 * The image is contained in the @a imageData field.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageChartResponse& visualizeImageChart( const VisualizeImageChartRequest& request_,
                                                  VisualizeImageChartResponse& response_ ) const;

/**
 * Scatter plot is the only plot type currently supported. A non-numeric column
 * can be specified as x or y column and jitters can be added to them to avoid
 * excessive overlapping. All color values must be in the format RRGGBB or
 * AARRGGBB (to specify the alpha value).
 * The image is contained in the @a imageData field.
 * 
 * @param tableName  Name of the table containing the data to be drawn as a
 *                   chart, in [schema_name.]table_name format, using standard
 *                   <a href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param xColumnNames  Names of the columns containing the data mapped to the
 *                      x axis of a chart.
 * @param yColumnNames  Names of the columns containing the data mapped to the
 *                      y axis of a chart.
 * @param minX  Lower bound for the x column values. For non-numeric x column,
 *              each x column item is mapped to an integral value starting from
 *              0.
 * @param maxX  Upper bound for the x column values. For non-numeric x column,
 *              each x column item is mapped to an integral value starting from
 *              0.
 * @param minY  Lower bound for the y column values. For non-numeric y column,
 *              each y column item is mapped to an integral value starting from
 *              0.
 * @param maxY  Upper bound for the y column values. For non-numeric y column,
 *              each y column item is mapped to an integral value starting from
 *              0.
 * @param width  Width of the generated image in pixels.
 * @param height  Height of the generated image in pixels.
 * @param bgColor  Background color of the generated image.
 * @param styleOptions  Rendering style options for a chart.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_pointcolor:
 *                      The color of points in the plot represented as a
 *                      hexadecimal number.  The default value is '0000FF'.
 *                              <li> gpudb::visualize_image_chart_pointsize:
 *                      The size of points in the plot represented as number of
 *                      pixels.  The default value is '3'.
 *                              <li> gpudb::visualize_image_chart_pointshape:
 *                      The shape of points in the plot.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_none
 *                              <li> gpudb::visualize_image_chart_circle
 *                              <li> gpudb::visualize_image_chart_square
 *                              <li> gpudb::visualize_image_chart_diamond
 *                              <li> gpudb::visualize_image_chart_hollowcircle
 *                              <li> gpudb::visualize_image_chart_hollowsquare
 *                              <li> gpudb::visualize_image_chart_hollowdiamond
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_chart_square.
 *                              <li>
 *                      gpudb::visualize_image_chart_cb_pointcolors: Point
 *                      color class break information consisting of three
 *                      entries: class-break attribute, class-break
 *                      values/ranges, and point color values. This option
 *                      overrides the pointcolor option if both are provided.
 *                      Class-break ranges are represented in the form of
 *                      "min:max". Class-break values/ranges and point color
 *                      values are separated by cb_delimiter, e.g. {"price",
 *                      "20:30;30:40;40:50", "0xFF0000;0x00FF00;0x0000FF"}.
 *                              <li>
 *                      gpudb::visualize_image_chart_cb_pointsizes: Point size
 *                      class break information consisting of three entries:
 *                      class-break attribute, class-break values/ranges, and
 *                      point size values. This option overrides the pointsize
 *                      option if both are provided. Class-break ranges are
 *                      represented in the form of "min:max". Class-break
 *                      values/ranges and point size values are separated by
 *                      cb_delimiter, e.g. {"states", "NY;TX;CA", "3;5;7"}.
 *                              <li>
 *                      gpudb::visualize_image_chart_cb_pointshapes: Point
 *                      shape class break information consisting of three
 *                      entries: class-break attribute, class-break
 *                      values/ranges, and point shape names. This option
 *                      overrides the pointshape option if both are provided.
 *                      Class-break ranges are represented in the form of
 *                      "min:max". Class-break values/ranges and point shape
 *                      names are separated by cb_delimiter, e.g. {"states",
 *                      "NY;TX;CA", "circle;square;diamond"}.
 *                              <li> gpudb::visualize_image_chart_cb_delimiter:
 *                      A character or string which separates per-class values
 *                      in a class-break style option string.  The default
 *                      value is ';'.
 *                              <li> gpudb::visualize_image_chart_x_order_by:
 *                      An expression or aggregate expression by which
 *                      non-numeric x column values are sorted, e.g.
 *                      "avg(price) descending".
 *                              <li> gpudb::visualize_image_chart_y_order_by:
 *                      An expression or aggregate expression by which
 *                      non-numeric y column values are sorted, e.g.
 *                      "avg(price)", which defaults to "avg(price) ascending".
 *                              <li> gpudb::visualize_image_chart_scale_type_x:
 *                      Type of x axis scale.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_none: No
 *                      scale is applied to the x axis.
 *                              <li> gpudb::visualize_image_chart_log: A
 *                      base-10 log scale is applied to the x axis.
 *                      </ul>
 *                      The default value is gpudb::visualize_image_chart_none.
 *                              <li> gpudb::visualize_image_chart_scale_type_y:
 *                      Type of y axis scale.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_none: No
 *                      scale is applied to the y axis.
 *                              <li> gpudb::visualize_image_chart_log: A
 *                      base-10 log scale is applied to the y axis.
 *                      </ul>
 *                      The default value is gpudb::visualize_image_chart_none.
 *                              <li>
 *                      gpudb::visualize_image_chart_min_max_scaled: If this
 *                      options is set to "false", this endpoint expects
 *                      request's min/max values are not yet scaled. They will
 *                      be scaled according to scale_type_x or scale_type_y for
 *                      response. If this options is set to "true", this
 *                      endpoint expects request's min/max values are already
 *                      scaled according to scale_type_x/scale_type_y.
 *                      Response's min/max values will be equal to request's
 *                      min/max values.  The default value is 'false'.
 *                              <li> gpudb::visualize_image_chart_jitter_x:
 *                      Amplitude of horizontal jitter applied to non-numeric x
 *                      column values.  The default value is '0.0'.
 *                              <li> gpudb::visualize_image_chart_jitter_y:
 *                      Amplitude of vertical jitter applied to non-numeric y
 *                      column values.  The default value is '0.0'.
 *                              <li> gpudb::visualize_image_chart_plot_all: If
 *                      this options is set to "true", all non-numeric column
 *                      values are plotted ignoring min_x, max_x, min_y and
 *                      max_y parameters.  The default value is 'false'.
 *                      </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::visualize_image_chart_image_encoding:
 *                 Encoding to be applied to the output image. When using JSON
 *                 serialization it is recommended to specify this as @a
 *                 base64.
 *                 <ul>
 *                         <li> gpudb::visualize_image_chart_base64: Apply
 *                 base64 encoding to the output image.
 *                         <li> gpudb::visualize_image_chart_none: Do not apply
 *                 any additional encoding to the output image.
 *                 </ul>
 *                 The default value is gpudb::visualize_image_chart_none.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageChartResponse visualizeImageChart( const std::string& tableName,
                                                 const std::vector<std::string>& xColumnNames,
                                                 const std::vector<std::string>& yColumnNames,
                                                 const double minX,
                                                 const double maxX,
                                                 const double minY,
                                                 const double maxY,
                                                 const int32_t width,
                                                 const int32_t height,
                                                 const std::string& bgColor,
                                                 const std::map<std::string, std::vector<std::string> >& styleOptions,
                                                 const std::map<std::string, std::string>& options ) const;

/**
 * Scatter plot is the only plot type currently supported. A non-numeric column
 * can be specified as x or y column and jitters can be added to them to avoid
 * excessive overlapping. All color values must be in the format RRGGBB or
 * AARRGGBB (to specify the alpha value).
 * The image is contained in the @a imageData field.
 * 
 * @param tableName  Name of the table containing the data to be drawn as a
 *                   chart, in [schema_name.]table_name format, using standard
 *                   <a href="../../../concepts/tables/#table-name-resolution"
 *                   target="_top">name resolution rules</a>.
 * @param xColumnNames  Names of the columns containing the data mapped to the
 *                      x axis of a chart.
 * @param yColumnNames  Names of the columns containing the data mapped to the
 *                      y axis of a chart.
 * @param minX  Lower bound for the x column values. For non-numeric x column,
 *              each x column item is mapped to an integral value starting from
 *              0.
 * @param maxX  Upper bound for the x column values. For non-numeric x column,
 *              each x column item is mapped to an integral value starting from
 *              0.
 * @param minY  Lower bound for the y column values. For non-numeric y column,
 *              each y column item is mapped to an integral value starting from
 *              0.
 * @param maxY  Upper bound for the y column values. For non-numeric y column,
 *              each y column item is mapped to an integral value starting from
 *              0.
 * @param width  Width of the generated image in pixels.
 * @param height  Height of the generated image in pixels.
 * @param bgColor  Background color of the generated image.
 * @param styleOptions  Rendering style options for a chart.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_pointcolor:
 *                      The color of points in the plot represented as a
 *                      hexadecimal number.  The default value is '0000FF'.
 *                              <li> gpudb::visualize_image_chart_pointsize:
 *                      The size of points in the plot represented as number of
 *                      pixels.  The default value is '3'.
 *                              <li> gpudb::visualize_image_chart_pointshape:
 *                      The shape of points in the plot.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_none
 *                              <li> gpudb::visualize_image_chart_circle
 *                              <li> gpudb::visualize_image_chart_square
 *                              <li> gpudb::visualize_image_chart_diamond
 *                              <li> gpudb::visualize_image_chart_hollowcircle
 *                              <li> gpudb::visualize_image_chart_hollowsquare
 *                              <li> gpudb::visualize_image_chart_hollowdiamond
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_chart_square.
 *                              <li>
 *                      gpudb::visualize_image_chart_cb_pointcolors: Point
 *                      color class break information consisting of three
 *                      entries: class-break attribute, class-break
 *                      values/ranges, and point color values. This option
 *                      overrides the pointcolor option if both are provided.
 *                      Class-break ranges are represented in the form of
 *                      "min:max". Class-break values/ranges and point color
 *                      values are separated by cb_delimiter, e.g. {"price",
 *                      "20:30;30:40;40:50", "0xFF0000;0x00FF00;0x0000FF"}.
 *                              <li>
 *                      gpudb::visualize_image_chart_cb_pointsizes: Point size
 *                      class break information consisting of three entries:
 *                      class-break attribute, class-break values/ranges, and
 *                      point size values. This option overrides the pointsize
 *                      option if both are provided. Class-break ranges are
 *                      represented in the form of "min:max". Class-break
 *                      values/ranges and point size values are separated by
 *                      cb_delimiter, e.g. {"states", "NY;TX;CA", "3;5;7"}.
 *                              <li>
 *                      gpudb::visualize_image_chart_cb_pointshapes: Point
 *                      shape class break information consisting of three
 *                      entries: class-break attribute, class-break
 *                      values/ranges, and point shape names. This option
 *                      overrides the pointshape option if both are provided.
 *                      Class-break ranges are represented in the form of
 *                      "min:max". Class-break values/ranges and point shape
 *                      names are separated by cb_delimiter, e.g. {"states",
 *                      "NY;TX;CA", "circle;square;diamond"}.
 *                              <li> gpudb::visualize_image_chart_cb_delimiter:
 *                      A character or string which separates per-class values
 *                      in a class-break style option string.  The default
 *                      value is ';'.
 *                              <li> gpudb::visualize_image_chart_x_order_by:
 *                      An expression or aggregate expression by which
 *                      non-numeric x column values are sorted, e.g.
 *                      "avg(price) descending".
 *                              <li> gpudb::visualize_image_chart_y_order_by:
 *                      An expression or aggregate expression by which
 *                      non-numeric y column values are sorted, e.g.
 *                      "avg(price)", which defaults to "avg(price) ascending".
 *                              <li> gpudb::visualize_image_chart_scale_type_x:
 *                      Type of x axis scale.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_none: No
 *                      scale is applied to the x axis.
 *                              <li> gpudb::visualize_image_chart_log: A
 *                      base-10 log scale is applied to the x axis.
 *                      </ul>
 *                      The default value is gpudb::visualize_image_chart_none.
 *                              <li> gpudb::visualize_image_chart_scale_type_y:
 *                      Type of y axis scale.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_none: No
 *                      scale is applied to the y axis.
 *                              <li> gpudb::visualize_image_chart_log: A
 *                      base-10 log scale is applied to the y axis.
 *                      </ul>
 *                      The default value is gpudb::visualize_image_chart_none.
 *                              <li>
 *                      gpudb::visualize_image_chart_min_max_scaled: If this
 *                      options is set to "false", this endpoint expects
 *                      request's min/max values are not yet scaled. They will
 *                      be scaled according to scale_type_x or scale_type_y for
 *                      response. If this options is set to "true", this
 *                      endpoint expects request's min/max values are already
 *                      scaled according to scale_type_x/scale_type_y.
 *                      Response's min/max values will be equal to request's
 *                      min/max values.  The default value is 'false'.
 *                              <li> gpudb::visualize_image_chart_jitter_x:
 *                      Amplitude of horizontal jitter applied to non-numeric x
 *                      column values.  The default value is '0.0'.
 *                              <li> gpudb::visualize_image_chart_jitter_y:
 *                      Amplitude of vertical jitter applied to non-numeric y
 *                      column values.  The default value is '0.0'.
 *                              <li> gpudb::visualize_image_chart_plot_all: If
 *                      this options is set to "true", all non-numeric column
 *                      values are plotted ignoring min_x, max_x, min_y and
 *                      max_y parameters.  The default value is 'false'.
 *                      </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::visualize_image_chart_image_encoding:
 *                 Encoding to be applied to the output image. When using JSON
 *                 serialization it is recommended to specify this as @a
 *                 base64.
 *                 <ul>
 *                         <li> gpudb::visualize_image_chart_base64: Apply
 *                 base64 encoding to the output image.
 *                         <li> gpudb::visualize_image_chart_none: Do not apply
 *                 any additional encoding to the output image.
 *                 </ul>
 *                 The default value is gpudb::visualize_image_chart_none.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageChartResponse& visualizeImageChart( const std::string& tableName,
                                                  const std::vector<std::string>& xColumnNames,
                                                  const std::vector<std::string>& yColumnNames,
                                                  const double minX,
                                                  const double maxX,
                                                  const double minY,
                                                  const double maxY,
                                                  const int32_t width,
                                                  const int32_t height,
                                                  const std::string& bgColor,
                                                  const std::map<std::string, std::vector<std::string> >& styleOptions,
                                                  const std::map<std::string, std::string>& options,
                                                  VisualizeImageChartResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageClassbreakResponse visualizeImageClassbreak( const VisualizeImageClassbreakRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageClassbreakResponse& visualizeImageClassbreak( const VisualizeImageClassbreakRequest& request_,
                                                            VisualizeImageClassbreakResponse& response_ ) const;

/**
 * @private
 * 
 * @param tableNames
 * @param worldTableNames
 * @param xColumnName
 * @param yColumnName
 * @param symbolColumnName
 * @param geometryColumnName
 * @param trackIds
 * @param cbAttr
 * @param cbVals
 * @param cbPointcolorAttr
 * @param cbPointcolorVals
 * @param cbPointalphaAttr
 * @param cbPointalphaVals
 * @param cbPointsizeAttr
 * @param cbPointsizeVals
 * @param cbPointshapeAttr
 * @param cbPointshapeVals
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_classbreak_EPSG_4326
 *                            <li>
 *                    gpudb::visualize_image_classbreak_PLATE_CARREE
 *                            <li> gpudb::visualize_image_classbreak_900913
 *                            <li>
 *                    gpudb::visualize_image_classbreak_EPSG_900913
 *                            <li> gpudb::visualize_image_classbreak_102100
 *                            <li>
 *                    gpudb::visualize_image_classbreak_EPSG_102100
 *                            <li> gpudb::visualize_image_classbreak_3857
 *                            <li> gpudb::visualize_image_classbreak_EPSG_3857
 *                            <li>
 *                    gpudb::visualize_image_classbreak_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_classbreak_PLATE_CARREE.
 * @param bgColor
 * @param styleOptions
 *                      <ul>
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_points:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_true.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_shapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_true.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_tracks:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_true.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_symbology:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_false.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointcolors:   The
 *                      default value is 'FF0000'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_cb_pointalphas:   The
 *                      default value is '255'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointsizes:   The
 *                      default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointoffset_x:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointoffset_y:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_none
 *                              <li> gpudb::visualize_image_classbreak_circle
 *                              <li> gpudb::visualize_image_classbreak_square
 *                              <li> gpudb::visualize_image_classbreak_diamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowcircle
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowsquare
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowdiamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_symbolcode
 *                              <li> gpudb::visualize_image_classbreak_dash
 *                              <li> gpudb::visualize_image_classbreak_pipe
 *                              <li> gpudb::visualize_image_classbreak_plus
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowsquarewithplus
 *                              <li> gpudb::visualize_image_classbreak_dot
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_none.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_symbolrotations:
 *                      The default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinewidths:
 *                      The default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinecolors:
 *                      The default value is 'FFFF00 '.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinepatterns:
 *                      The default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinepatternlen:
 *                      The default value is '32'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapefillcolors:
 *                      The default value is '-1'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlineintervals:
 *                      The default value is '20'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlinecolors:   The
 *                      default value is 'The same as line color.'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlineangles:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlinelens:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlinewidths:   The
 *                      default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_tracklinewidths:
 *                      The default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_tracklinecolors:
 *                      The default value is '00FF00'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackmarkersizes:
 *                      The default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackmarkercolors:
 *                      The default value is '0000FF'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackmarkershapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_none
 *                              <li> gpudb::visualize_image_classbreak_circle
 *                              <li> gpudb::visualize_image_classbreak_square
 *                              <li> gpudb::visualize_image_classbreak_diamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowcircle
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowsquare
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowdiamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_oriented_arrow
 *                              <li>
 *                      gpudb::visualize_image_classbreak_oriented_triangle
 *                              <li>
 *                      gpudb::visualize_image_classbreak_symbolcode
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_none.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackheadcolors:
 *                      The default value is 'FFFFFF'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackheadsizes:   The
 *                      default value is '10'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackheadshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_none
 *                              <li> gpudb::visualize_image_classbreak_circle
 *                              <li> gpudb::visualize_image_classbreak_square
 *                              <li> gpudb::visualize_image_classbreak_diamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowcircle
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowsquare
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowdiamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_symbolcode
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_circle.
 *                      </ul>
 * @param options
 *                 <ul>
 *                         <li>
 *                 gpudb::visualize_image_classbreak_track_id_column_name
 *                         <li>
 *                 gpudb::visualize_image_classbreak_track_order_column_name
 *                 </ul>
 * @param cbTransparencyVec
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageClassbreakResponse visualizeImageClassbreak( const std::vector<std::string>& tableNames,
                                                           const std::vector<std::string>& worldTableNames,
                                                           const std::string& xColumnName,
                                                           const std::string& yColumnName,
                                                           const std::string& symbolColumnName,
                                                           const std::string& geometryColumnName,
                                                           const std::vector<std::vector<std::string> >& trackIds,
                                                           const std::string& cbAttr,
                                                           const std::vector<std::string>& cbVals,
                                                           const std::string& cbPointcolorAttr,
                                                           const std::vector<std::string>& cbPointcolorVals,
                                                           const std::string& cbPointalphaAttr,
                                                           const std::vector<std::string>& cbPointalphaVals,
                                                           const std::string& cbPointsizeAttr,
                                                           const std::vector<std::string>& cbPointsizeVals,
                                                           const std::string& cbPointshapeAttr,
                                                           const std::vector<std::string>& cbPointshapeVals,
                                                           const double minX,
                                                           const double maxX,
                                                           const double minY,
                                                           const double maxY,
                                                           const int32_t width,
                                                           const int32_t height,
                                                           const std::string& projection,
                                                           const int64_t bgColor,
                                                           const std::map<std::string, std::vector<std::string> >& styleOptions,
                                                           const std::map<std::string, std::string>& options,
                                                           const std::vector<int32_t>& cbTransparencyVec ) const;

/**
 * @private
 * 
 * @param tableNames
 * @param worldTableNames
 * @param xColumnName
 * @param yColumnName
 * @param symbolColumnName
 * @param geometryColumnName
 * @param trackIds
 * @param cbAttr
 * @param cbVals
 * @param cbPointcolorAttr
 * @param cbPointcolorVals
 * @param cbPointalphaAttr
 * @param cbPointalphaVals
 * @param cbPointsizeAttr
 * @param cbPointsizeVals
 * @param cbPointshapeAttr
 * @param cbPointshapeVals
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_classbreak_EPSG_4326
 *                            <li>
 *                    gpudb::visualize_image_classbreak_PLATE_CARREE
 *                            <li> gpudb::visualize_image_classbreak_900913
 *                            <li>
 *                    gpudb::visualize_image_classbreak_EPSG_900913
 *                            <li> gpudb::visualize_image_classbreak_102100
 *                            <li>
 *                    gpudb::visualize_image_classbreak_EPSG_102100
 *                            <li> gpudb::visualize_image_classbreak_3857
 *                            <li> gpudb::visualize_image_classbreak_EPSG_3857
 *                            <li>
 *                    gpudb::visualize_image_classbreak_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_classbreak_PLATE_CARREE.
 * @param bgColor
 * @param styleOptions
 *                      <ul>
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_points:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_true.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_shapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_true.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_tracks:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_true.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_symbology:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_false.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointcolors:   The
 *                      default value is 'FF0000'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_cb_pointalphas:   The
 *                      default value is '255'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointsizes:   The
 *                      default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointoffset_x:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointoffset_y:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_none
 *                              <li> gpudb::visualize_image_classbreak_circle
 *                              <li> gpudb::visualize_image_classbreak_square
 *                              <li> gpudb::visualize_image_classbreak_diamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowcircle
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowsquare
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowdiamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_symbolcode
 *                              <li> gpudb::visualize_image_classbreak_dash
 *                              <li> gpudb::visualize_image_classbreak_pipe
 *                              <li> gpudb::visualize_image_classbreak_plus
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowsquarewithplus
 *                              <li> gpudb::visualize_image_classbreak_dot
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_none.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_symbolrotations:
 *                      The default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinewidths:
 *                      The default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinecolors:
 *                      The default value is 'FFFF00 '.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinepatterns:
 *                      The default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinepatternlen:
 *                      The default value is '32'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapefillcolors:
 *                      The default value is '-1'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlineintervals:
 *                      The default value is '20'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlinecolors:   The
 *                      default value is 'The same as line color.'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlineangles:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlinelens:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlinewidths:   The
 *                      default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_tracklinewidths:
 *                      The default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_tracklinecolors:
 *                      The default value is '00FF00'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackmarkersizes:
 *                      The default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackmarkercolors:
 *                      The default value is '0000FF'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackmarkershapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_none
 *                              <li> gpudb::visualize_image_classbreak_circle
 *                              <li> gpudb::visualize_image_classbreak_square
 *                              <li> gpudb::visualize_image_classbreak_diamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowcircle
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowsquare
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowdiamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_oriented_arrow
 *                              <li>
 *                      gpudb::visualize_image_classbreak_oriented_triangle
 *                              <li>
 *                      gpudb::visualize_image_classbreak_symbolcode
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_none.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackheadcolors:
 *                      The default value is 'FFFFFF'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackheadsizes:   The
 *                      default value is '10'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackheadshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_none
 *                              <li> gpudb::visualize_image_classbreak_circle
 *                              <li> gpudb::visualize_image_classbreak_square
 *                              <li> gpudb::visualize_image_classbreak_diamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowcircle
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowsquare
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowdiamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_symbolcode
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_circle.
 *                      </ul>
 * @param options
 *                 <ul>
 *                         <li>
 *                 gpudb::visualize_image_classbreak_track_id_column_name
 *                         <li>
 *                 gpudb::visualize_image_classbreak_track_order_column_name
 *                 </ul>
 * @param cbTransparencyVec
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageClassbreakResponse& visualizeImageClassbreak( const std::vector<std::string>& tableNames,
                                                            const std::vector<std::string>& worldTableNames,
                                                            const std::string& xColumnName,
                                                            const std::string& yColumnName,
                                                            const std::string& symbolColumnName,
                                                            const std::string& geometryColumnName,
                                                            const std::vector<std::vector<std::string> >& trackIds,
                                                            const std::string& cbAttr,
                                                            const std::vector<std::string>& cbVals,
                                                            const std::string& cbPointcolorAttr,
                                                            const std::vector<std::string>& cbPointcolorVals,
                                                            const std::string& cbPointalphaAttr,
                                                            const std::vector<std::string>& cbPointalphaVals,
                                                            const std::string& cbPointsizeAttr,
                                                            const std::vector<std::string>& cbPointsizeVals,
                                                            const std::string& cbPointshapeAttr,
                                                            const std::vector<std::string>& cbPointshapeVals,
                                                            const double minX,
                                                            const double maxX,
                                                            const double minY,
                                                            const double maxY,
                                                            const int32_t width,
                                                            const int32_t height,
                                                            const std::string& projection,
                                                            const int64_t bgColor,
                                                            const std::map<std::string, std::vector<std::string> >& styleOptions,
                                                            const std::map<std::string, std::string>& options,
                                                            const std::vector<int32_t>& cbTransparencyVec,
                                                            VisualizeImageClassbreakResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageContourResponse visualizeImageContour( const VisualizeImageContourRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageContourResponse& visualizeImageContour( const VisualizeImageContourRequest& request_,
                                                      VisualizeImageContourResponse& response_ ) const;

/**
 * @private
 * 
 * @param tableNames
 * @param xColumnName
 * @param yColumnName
 * @param valueColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_contour_3857
 *                            <li> gpudb::visualize_image_contour_102100
 *                            <li> gpudb::visualize_image_contour_900913
 *                            <li> gpudb::visualize_image_contour_EPSG_4326
 *                            <li> gpudb::visualize_image_contour_PLATE_CARREE
 *                            <li> gpudb::visualize_image_contour_EPSG_900913
 *                            <li> gpudb::visualize_image_contour_EPSG_102100
 *                            <li> gpudb::visualize_image_contour_EPSG_3857
 *                            <li> gpudb::visualize_image_contour_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_contour_PLATE_CARREE.
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_image_contour_line_size:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_contour_color:
 *                      The default value is 'FF696969'.
 *                              <li> gpudb::visualize_image_contour_bg_color:
 *                      The default value is '00000000'.
 *                              <li> gpudb::visualize_image_contour_text_color:
 *                      The default value is 'FF000000'.
 *                              <li> gpudb::visualize_image_contour_colormap:
 *                      <ul>
 *                              <li> gpudb::visualize_image_contour_jet
 *                              <li> gpudb::visualize_image_contour_accent
 *                              <li> gpudb::visualize_image_contour_afmhot
 *                              <li> gpudb::visualize_image_contour_autumn
 *                              <li> gpudb::visualize_image_contour_binary
 *                              <li> gpudb::visualize_image_contour_blues
 *                              <li> gpudb::visualize_image_contour_bone
 *                              <li> gpudb::visualize_image_contour_brbg
 *                              <li> gpudb::visualize_image_contour_brg
 *                              <li> gpudb::visualize_image_contour_bugn
 *                              <li> gpudb::visualize_image_contour_bupu
 *                              <li> gpudb::visualize_image_contour_bwr
 *                              <li> gpudb::visualize_image_contour_cmrmap
 *                              <li> gpudb::visualize_image_contour_cool
 *                              <li> gpudb::visualize_image_contour_coolwarm
 *                              <li> gpudb::visualize_image_contour_copper
 *                              <li> gpudb::visualize_image_contour_cubehelix
 *                              <li> gpudb::visualize_image_contour_dark2
 *                              <li> gpudb::visualize_image_contour_flag
 *                              <li> gpudb::visualize_image_contour_gist_earth
 *                              <li> gpudb::visualize_image_contour_gist_gray
 *                              <li> gpudb::visualize_image_contour_gist_heat
 *                              <li> gpudb::visualize_image_contour_gist_ncar
 *                              <li>
 *                      gpudb::visualize_image_contour_gist_rainbow
 *                              <li> gpudb::visualize_image_contour_gist_stern
 *                              <li> gpudb::visualize_image_contour_gist_yarg
 *                              <li> gpudb::visualize_image_contour_gnbu
 *                              <li> gpudb::visualize_image_contour_gnuplot2
 *                              <li> gpudb::visualize_image_contour_gnuplot
 *                              <li> gpudb::visualize_image_contour_gray
 *                              <li> gpudb::visualize_image_contour_greens
 *                              <li> gpudb::visualize_image_contour_greys
 *                              <li> gpudb::visualize_image_contour_hot
 *                              <li> gpudb::visualize_image_contour_hsv
 *                              <li> gpudb::visualize_image_contour_inferno
 *                              <li> gpudb::visualize_image_contour_magma
 *                              <li>
 *                      gpudb::visualize_image_contour_nipy_spectral
 *                              <li> gpudb::visualize_image_contour_ocean
 *                              <li> gpudb::visualize_image_contour_oranges
 *                              <li> gpudb::visualize_image_contour_orrd
 *                              <li> gpudb::visualize_image_contour_paired
 *                              <li> gpudb::visualize_image_contour_pastel1
 *                              <li> gpudb::visualize_image_contour_pastel2
 *                              <li> gpudb::visualize_image_contour_pink
 *                              <li> gpudb::visualize_image_contour_piyg
 *                              <li> gpudb::visualize_image_contour_plasma
 *                              <li> gpudb::visualize_image_contour_prgn
 *                              <li> gpudb::visualize_image_contour_prism
 *                              <li> gpudb::visualize_image_contour_pubu
 *                              <li> gpudb::visualize_image_contour_pubugn
 *                              <li> gpudb::visualize_image_contour_puor
 *                              <li> gpudb::visualize_image_contour_purd
 *                              <li> gpudb::visualize_image_contour_purples
 *                              <li> gpudb::visualize_image_contour_rainbow
 *                              <li> gpudb::visualize_image_contour_rdbu
 *                              <li> gpudb::visualize_image_contour_rdgy
 *                              <li> gpudb::visualize_image_contour_rdpu
 *                              <li> gpudb::visualize_image_contour_rdylbu
 *                              <li> gpudb::visualize_image_contour_rdylgn
 *                              <li> gpudb::visualize_image_contour_reds
 *                              <li> gpudb::visualize_image_contour_seismic
 *                              <li> gpudb::visualize_image_contour_set1
 *                              <li> gpudb::visualize_image_contour_set2
 *                              <li> gpudb::visualize_image_contour_set3
 *                              <li> gpudb::visualize_image_contour_spectral
 *                              <li> gpudb::visualize_image_contour_spring
 *                              <li> gpudb::visualize_image_contour_summer
 *                              <li> gpudb::visualize_image_contour_terrain
 *                              <li> gpudb::visualize_image_contour_viridis
 *                              <li> gpudb::visualize_image_contour_winter
 *                              <li> gpudb::visualize_image_contour_wistia
 *                              <li> gpudb::visualize_image_contour_ylgn
 *                              <li> gpudb::visualize_image_contour_ylgnbu
 *                              <li> gpudb::visualize_image_contour_ylorbr
 *                              <li> gpudb::visualize_image_contour_ylorrd
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_contour_jet.
 *                      </ul>
 * @param options
 *                 <ul>
 *                         <li> gpudb::visualize_image_contour_min_level
 *                         <li> gpudb::visualize_image_contour_max_level
 *                         <li> gpudb::visualize_image_contour_num_levels:
 *                 The default value is '10'.
 *                         <li> gpudb::visualize_image_contour_adjust_levels:
 *                 The default value is 'true'.
 *                         <li> gpudb::visualize_image_contour_search_radius:
 *                 The default value is '20'.
 *                         <li>
 *                 gpudb::visualize_image_contour_max_search_cells:   The
 *                 default value is '100'.
 *                         <li> gpudb::visualize_image_contour_gridding_method:
 *                 <ul>
 *                         <li> gpudb::visualize_image_contour_INV_DST_POW
 *                         <li> gpudb::visualize_image_contour_MIN_CURV
 *                         <li> gpudb::visualize_image_contour_KRIGING
 *                         <li> gpudb::visualize_image_contour_PASS_THROUGH
 *                         <li> gpudb::visualize_image_contour_FILL_RATIO
 *                 </ul>
 *                 The default value is
 *                 gpudb::visualize_image_contour_INV_DST_POW.
 *                         <li>
 *                 gpudb::visualize_image_contour_smoothing_factor:   The
 *                 default value is '10'.
 *                         <li> gpudb::visualize_image_contour_grid_size:   The
 *                 default value is '100'.
 *                         <li> gpudb::visualize_image_contour_adjust_grid:
 *                 The default value is 'false'.
 *                         <li>
 *                 gpudb::visualize_image_contour_adjust_grid_neigh:   The
 *                 default value is '1'.
 *                         <li>
 *                 gpudb::visualize_image_contour_adjust_grid_size:   The
 *                 default value is '1'.
 *                         <li> gpudb::visualize_image_contour_max_grid_size:
 *                 The default value is '500'.
 *                         <li> gpudb::visualize_image_contour_min_grid_size:
 *                 The default value is '10'.
 *                         <li>
 *                 gpudb::visualize_image_contour_render_output_grid:   The
 *                 default value is 'false'.
 *                         <li> gpudb::visualize_image_contour_color_isolines:
 *                 The default value is 'true'.
 *                         <li> gpudb::visualize_image_contour_add_labels:
 *                 The default value is 'false'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_font_size:   The
 *                 default value is '12'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_font_family:   The
 *                 default value is 'sans'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_search_window:   The
 *                 default value is '4'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_intralevel_separation:
 *                 The default value is '4'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_interlevel_separation:
 *                 The default value is '20'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_max_angle:   The
 *                 default value is '60'.
 *                         <li>
 *                 gpudb::visualize_image_contour_isochrone_concavity:   The
 *                 default value is '-1'.
 *                         <li>
 *                 gpudb::visualize_image_contour_isochrone_output_table:   The
 *                 default value is ''.
 *                         <li> gpudb::visualize_image_contour_isochrone_image:
 *                 The default value is 'false'.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageContourResponse visualizeImageContour( const std::vector<std::string>& tableNames,
                                                     const std::string& xColumnName,
                                                     const std::string& yColumnName,
                                                     const std::string& valueColumnName,
                                                     const double minX,
                                                     const double maxX,
                                                     const double minY,
                                                     const double maxY,
                                                     const int32_t width,
                                                     const int32_t height,
                                                     const std::string& projection,
                                                     const std::map<std::string, std::string>& styleOptions,
                                                     const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param tableNames
 * @param xColumnName
 * @param yColumnName
 * @param valueColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_contour_3857
 *                            <li> gpudb::visualize_image_contour_102100
 *                            <li> gpudb::visualize_image_contour_900913
 *                            <li> gpudb::visualize_image_contour_EPSG_4326
 *                            <li> gpudb::visualize_image_contour_PLATE_CARREE
 *                            <li> gpudb::visualize_image_contour_EPSG_900913
 *                            <li> gpudb::visualize_image_contour_EPSG_102100
 *                            <li> gpudb::visualize_image_contour_EPSG_3857
 *                            <li> gpudb::visualize_image_contour_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_contour_PLATE_CARREE.
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_image_contour_line_size:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_contour_color:
 *                      The default value is 'FF696969'.
 *                              <li> gpudb::visualize_image_contour_bg_color:
 *                      The default value is '00000000'.
 *                              <li> gpudb::visualize_image_contour_text_color:
 *                      The default value is 'FF000000'.
 *                              <li> gpudb::visualize_image_contour_colormap:
 *                      <ul>
 *                              <li> gpudb::visualize_image_contour_jet
 *                              <li> gpudb::visualize_image_contour_accent
 *                              <li> gpudb::visualize_image_contour_afmhot
 *                              <li> gpudb::visualize_image_contour_autumn
 *                              <li> gpudb::visualize_image_contour_binary
 *                              <li> gpudb::visualize_image_contour_blues
 *                              <li> gpudb::visualize_image_contour_bone
 *                              <li> gpudb::visualize_image_contour_brbg
 *                              <li> gpudb::visualize_image_contour_brg
 *                              <li> gpudb::visualize_image_contour_bugn
 *                              <li> gpudb::visualize_image_contour_bupu
 *                              <li> gpudb::visualize_image_contour_bwr
 *                              <li> gpudb::visualize_image_contour_cmrmap
 *                              <li> gpudb::visualize_image_contour_cool
 *                              <li> gpudb::visualize_image_contour_coolwarm
 *                              <li> gpudb::visualize_image_contour_copper
 *                              <li> gpudb::visualize_image_contour_cubehelix
 *                              <li> gpudb::visualize_image_contour_dark2
 *                              <li> gpudb::visualize_image_contour_flag
 *                              <li> gpudb::visualize_image_contour_gist_earth
 *                              <li> gpudb::visualize_image_contour_gist_gray
 *                              <li> gpudb::visualize_image_contour_gist_heat
 *                              <li> gpudb::visualize_image_contour_gist_ncar
 *                              <li>
 *                      gpudb::visualize_image_contour_gist_rainbow
 *                              <li> gpudb::visualize_image_contour_gist_stern
 *                              <li> gpudb::visualize_image_contour_gist_yarg
 *                              <li> gpudb::visualize_image_contour_gnbu
 *                              <li> gpudb::visualize_image_contour_gnuplot2
 *                              <li> gpudb::visualize_image_contour_gnuplot
 *                              <li> gpudb::visualize_image_contour_gray
 *                              <li> gpudb::visualize_image_contour_greens
 *                              <li> gpudb::visualize_image_contour_greys
 *                              <li> gpudb::visualize_image_contour_hot
 *                              <li> gpudb::visualize_image_contour_hsv
 *                              <li> gpudb::visualize_image_contour_inferno
 *                              <li> gpudb::visualize_image_contour_magma
 *                              <li>
 *                      gpudb::visualize_image_contour_nipy_spectral
 *                              <li> gpudb::visualize_image_contour_ocean
 *                              <li> gpudb::visualize_image_contour_oranges
 *                              <li> gpudb::visualize_image_contour_orrd
 *                              <li> gpudb::visualize_image_contour_paired
 *                              <li> gpudb::visualize_image_contour_pastel1
 *                              <li> gpudb::visualize_image_contour_pastel2
 *                              <li> gpudb::visualize_image_contour_pink
 *                              <li> gpudb::visualize_image_contour_piyg
 *                              <li> gpudb::visualize_image_contour_plasma
 *                              <li> gpudb::visualize_image_contour_prgn
 *                              <li> gpudb::visualize_image_contour_prism
 *                              <li> gpudb::visualize_image_contour_pubu
 *                              <li> gpudb::visualize_image_contour_pubugn
 *                              <li> gpudb::visualize_image_contour_puor
 *                              <li> gpudb::visualize_image_contour_purd
 *                              <li> gpudb::visualize_image_contour_purples
 *                              <li> gpudb::visualize_image_contour_rainbow
 *                              <li> gpudb::visualize_image_contour_rdbu
 *                              <li> gpudb::visualize_image_contour_rdgy
 *                              <li> gpudb::visualize_image_contour_rdpu
 *                              <li> gpudb::visualize_image_contour_rdylbu
 *                              <li> gpudb::visualize_image_contour_rdylgn
 *                              <li> gpudb::visualize_image_contour_reds
 *                              <li> gpudb::visualize_image_contour_seismic
 *                              <li> gpudb::visualize_image_contour_set1
 *                              <li> gpudb::visualize_image_contour_set2
 *                              <li> gpudb::visualize_image_contour_set3
 *                              <li> gpudb::visualize_image_contour_spectral
 *                              <li> gpudb::visualize_image_contour_spring
 *                              <li> gpudb::visualize_image_contour_summer
 *                              <li> gpudb::visualize_image_contour_terrain
 *                              <li> gpudb::visualize_image_contour_viridis
 *                              <li> gpudb::visualize_image_contour_winter
 *                              <li> gpudb::visualize_image_contour_wistia
 *                              <li> gpudb::visualize_image_contour_ylgn
 *                              <li> gpudb::visualize_image_contour_ylgnbu
 *                              <li> gpudb::visualize_image_contour_ylorbr
 *                              <li> gpudb::visualize_image_contour_ylorrd
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_contour_jet.
 *                      </ul>
 * @param options
 *                 <ul>
 *                         <li> gpudb::visualize_image_contour_min_level
 *                         <li> gpudb::visualize_image_contour_max_level
 *                         <li> gpudb::visualize_image_contour_num_levels:
 *                 The default value is '10'.
 *                         <li> gpudb::visualize_image_contour_adjust_levels:
 *                 The default value is 'true'.
 *                         <li> gpudb::visualize_image_contour_search_radius:
 *                 The default value is '20'.
 *                         <li>
 *                 gpudb::visualize_image_contour_max_search_cells:   The
 *                 default value is '100'.
 *                         <li> gpudb::visualize_image_contour_gridding_method:
 *                 <ul>
 *                         <li> gpudb::visualize_image_contour_INV_DST_POW
 *                         <li> gpudb::visualize_image_contour_MIN_CURV
 *                         <li> gpudb::visualize_image_contour_KRIGING
 *                         <li> gpudb::visualize_image_contour_PASS_THROUGH
 *                         <li> gpudb::visualize_image_contour_FILL_RATIO
 *                 </ul>
 *                 The default value is
 *                 gpudb::visualize_image_contour_INV_DST_POW.
 *                         <li>
 *                 gpudb::visualize_image_contour_smoothing_factor:   The
 *                 default value is '10'.
 *                         <li> gpudb::visualize_image_contour_grid_size:   The
 *                 default value is '100'.
 *                         <li> gpudb::visualize_image_contour_adjust_grid:
 *                 The default value is 'false'.
 *                         <li>
 *                 gpudb::visualize_image_contour_adjust_grid_neigh:   The
 *                 default value is '1'.
 *                         <li>
 *                 gpudb::visualize_image_contour_adjust_grid_size:   The
 *                 default value is '1'.
 *                         <li> gpudb::visualize_image_contour_max_grid_size:
 *                 The default value is '500'.
 *                         <li> gpudb::visualize_image_contour_min_grid_size:
 *                 The default value is '10'.
 *                         <li>
 *                 gpudb::visualize_image_contour_render_output_grid:   The
 *                 default value is 'false'.
 *                         <li> gpudb::visualize_image_contour_color_isolines:
 *                 The default value is 'true'.
 *                         <li> gpudb::visualize_image_contour_add_labels:
 *                 The default value is 'false'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_font_size:   The
 *                 default value is '12'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_font_family:   The
 *                 default value is 'sans'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_search_window:   The
 *                 default value is '4'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_intralevel_separation:
 *                 The default value is '4'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_interlevel_separation:
 *                 The default value is '20'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_max_angle:   The
 *                 default value is '60'.
 *                         <li>
 *                 gpudb::visualize_image_contour_isochrone_concavity:   The
 *                 default value is '-1'.
 *                         <li>
 *                 gpudb::visualize_image_contour_isochrone_output_table:   The
 *                 default value is ''.
 *                         <li> gpudb::visualize_image_contour_isochrone_image:
 *                 The default value is 'false'.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageContourResponse& visualizeImageContour( const std::vector<std::string>& tableNames,
                                                      const std::string& xColumnName,
                                                      const std::string& yColumnName,
                                                      const std::string& valueColumnName,
                                                      const double minX,
                                                      const double maxX,
                                                      const double minY,
                                                      const double maxY,
                                                      const int32_t width,
                                                      const int32_t height,
                                                      const std::string& projection,
                                                      const std::map<std::string, std::string>& styleOptions,
                                                      const std::map<std::string, std::string>& options,
                                                      VisualizeImageContourResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageHeatmapResponse visualizeImageHeatmap( const VisualizeImageHeatmapRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageHeatmapResponse& visualizeImageHeatmap( const VisualizeImageHeatmapRequest& request_,
                                                      VisualizeImageHeatmapResponse& response_ ) const;

/**
 * @private
 * 
 * @param tableNames
 * @param xColumnName
 * @param yColumnName
 * @param valueColumnName
 * @param geometryColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_heatmap_EPSG_4326
 *                            <li> gpudb::visualize_image_heatmap_PLATE_CARREE
 *                            <li> gpudb::visualize_image_heatmap_900913
 *                            <li> gpudb::visualize_image_heatmap_EPSG_900913
 *                            <li> gpudb::visualize_image_heatmap_102100
 *                            <li> gpudb::visualize_image_heatmap_EPSG_102100
 *                            <li> gpudb::visualize_image_heatmap_3857
 *                            <li> gpudb::visualize_image_heatmap_EPSG_3857
 *                            <li> gpudb::visualize_image_heatmap_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_heatmap_PLATE_CARREE.
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_image_heatmap_colormap:
 *                      <ul>
 *                              <li> gpudb::visualize_image_heatmap_jet
 *                              <li> gpudb::visualize_image_heatmap_accent
 *                              <li> gpudb::visualize_image_heatmap_afmhot
 *                              <li> gpudb::visualize_image_heatmap_autumn
 *                              <li> gpudb::visualize_image_heatmap_binary
 *                              <li> gpudb::visualize_image_heatmap_blues
 *                              <li> gpudb::visualize_image_heatmap_bone
 *                              <li> gpudb::visualize_image_heatmap_brbg
 *                              <li> gpudb::visualize_image_heatmap_brg
 *                              <li> gpudb::visualize_image_heatmap_bugn
 *                              <li> gpudb::visualize_image_heatmap_bupu
 *                              <li> gpudb::visualize_image_heatmap_bwr
 *                              <li> gpudb::visualize_image_heatmap_cmrmap
 *                              <li> gpudb::visualize_image_heatmap_cool
 *                              <li> gpudb::visualize_image_heatmap_coolwarm
 *                              <li> gpudb::visualize_image_heatmap_copper
 *                              <li> gpudb::visualize_image_heatmap_cubehelix
 *                              <li> gpudb::visualize_image_heatmap_dark2
 *                              <li> gpudb::visualize_image_heatmap_flag
 *                              <li> gpudb::visualize_image_heatmap_gist_earth
 *                              <li> gpudb::visualize_image_heatmap_gist_gray
 *                              <li> gpudb::visualize_image_heatmap_gist_heat
 *                              <li> gpudb::visualize_image_heatmap_gist_ncar
 *                              <li>
 *                      gpudb::visualize_image_heatmap_gist_rainbow
 *                              <li> gpudb::visualize_image_heatmap_gist_stern
 *                              <li> gpudb::visualize_image_heatmap_gist_yarg
 *                              <li> gpudb::visualize_image_heatmap_gnbu
 *                              <li> gpudb::visualize_image_heatmap_gnuplot2
 *                              <li> gpudb::visualize_image_heatmap_gnuplot
 *                              <li> gpudb::visualize_image_heatmap_gray
 *                              <li> gpudb::visualize_image_heatmap_greens
 *                              <li> gpudb::visualize_image_heatmap_greys
 *                              <li> gpudb::visualize_image_heatmap_hot
 *                              <li> gpudb::visualize_image_heatmap_hsv
 *                              <li> gpudb::visualize_image_heatmap_inferno
 *                              <li> gpudb::visualize_image_heatmap_magma
 *                              <li>
 *                      gpudb::visualize_image_heatmap_nipy_spectral
 *                              <li> gpudb::visualize_image_heatmap_ocean
 *                              <li> gpudb::visualize_image_heatmap_oranges
 *                              <li> gpudb::visualize_image_heatmap_orrd
 *                              <li> gpudb::visualize_image_heatmap_paired
 *                              <li> gpudb::visualize_image_heatmap_pastel1
 *                              <li> gpudb::visualize_image_heatmap_pastel2
 *                              <li> gpudb::visualize_image_heatmap_pink
 *                              <li> gpudb::visualize_image_heatmap_piyg
 *                              <li> gpudb::visualize_image_heatmap_plasma
 *                              <li> gpudb::visualize_image_heatmap_prgn
 *                              <li> gpudb::visualize_image_heatmap_prism
 *                              <li> gpudb::visualize_image_heatmap_pubu
 *                              <li> gpudb::visualize_image_heatmap_pubugn
 *                              <li> gpudb::visualize_image_heatmap_puor
 *                              <li> gpudb::visualize_image_heatmap_purd
 *                              <li> gpudb::visualize_image_heatmap_purples
 *                              <li> gpudb::visualize_image_heatmap_rainbow
 *                              <li> gpudb::visualize_image_heatmap_rdbu
 *                              <li> gpudb::visualize_image_heatmap_rdgy
 *                              <li> gpudb::visualize_image_heatmap_rdpu
 *                              <li> gpudb::visualize_image_heatmap_rdylbu
 *                              <li> gpudb::visualize_image_heatmap_rdylgn
 *                              <li> gpudb::visualize_image_heatmap_reds
 *                              <li> gpudb::visualize_image_heatmap_seismic
 *                              <li> gpudb::visualize_image_heatmap_set1
 *                              <li> gpudb::visualize_image_heatmap_set2
 *                              <li> gpudb::visualize_image_heatmap_set3
 *                              <li> gpudb::visualize_image_heatmap_spectral
 *                              <li> gpudb::visualize_image_heatmap_spring
 *                              <li> gpudb::visualize_image_heatmap_summer
 *                              <li> gpudb::visualize_image_heatmap_terrain
 *                              <li> gpudb::visualize_image_heatmap_viridis
 *                              <li> gpudb::visualize_image_heatmap_winter
 *                              <li> gpudb::visualize_image_heatmap_wistia
 *                              <li> gpudb::visualize_image_heatmap_ylgn
 *                              <li> gpudb::visualize_image_heatmap_ylgnbu
 *                              <li> gpudb::visualize_image_heatmap_ylorbr
 *                              <li> gpudb::visualize_image_heatmap_ylorrd
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_heatmap_jet.
 *                              <li>
 *                      gpudb::visualize_image_heatmap_blur_radius:   The
 *                      default value is '5'.
 *                              <li> gpudb::visualize_image_heatmap_bg_color
 *                              <li>
 *                      gpudb::visualize_image_heatmap_gradient_start_color:
 *                      The default value is 'FFFFFF'.
 *                              <li>
 *                      gpudb::visualize_image_heatmap_gradient_end_color:
 *                      The default value is 'FF0000'.
 *                      </ul>
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageHeatmapResponse visualizeImageHeatmap( const std::vector<std::string>& tableNames,
                                                     const std::string& xColumnName,
                                                     const std::string& yColumnName,
                                                     const std::string& valueColumnName,
                                                     const std::string& geometryColumnName,
                                                     const double minX,
                                                     const double maxX,
                                                     const double minY,
                                                     const double maxY,
                                                     const int32_t width,
                                                     const int32_t height,
                                                     const std::string& projection,
                                                     const std::map<std::string, std::string>& styleOptions,
                                                     const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param tableNames
 * @param xColumnName
 * @param yColumnName
 * @param valueColumnName
 * @param geometryColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_heatmap_EPSG_4326
 *                            <li> gpudb::visualize_image_heatmap_PLATE_CARREE
 *                            <li> gpudb::visualize_image_heatmap_900913
 *                            <li> gpudb::visualize_image_heatmap_EPSG_900913
 *                            <li> gpudb::visualize_image_heatmap_102100
 *                            <li> gpudb::visualize_image_heatmap_EPSG_102100
 *                            <li> gpudb::visualize_image_heatmap_3857
 *                            <li> gpudb::visualize_image_heatmap_EPSG_3857
 *                            <li> gpudb::visualize_image_heatmap_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_heatmap_PLATE_CARREE.
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_image_heatmap_colormap:
 *                      <ul>
 *                              <li> gpudb::visualize_image_heatmap_jet
 *                              <li> gpudb::visualize_image_heatmap_accent
 *                              <li> gpudb::visualize_image_heatmap_afmhot
 *                              <li> gpudb::visualize_image_heatmap_autumn
 *                              <li> gpudb::visualize_image_heatmap_binary
 *                              <li> gpudb::visualize_image_heatmap_blues
 *                              <li> gpudb::visualize_image_heatmap_bone
 *                              <li> gpudb::visualize_image_heatmap_brbg
 *                              <li> gpudb::visualize_image_heatmap_brg
 *                              <li> gpudb::visualize_image_heatmap_bugn
 *                              <li> gpudb::visualize_image_heatmap_bupu
 *                              <li> gpudb::visualize_image_heatmap_bwr
 *                              <li> gpudb::visualize_image_heatmap_cmrmap
 *                              <li> gpudb::visualize_image_heatmap_cool
 *                              <li> gpudb::visualize_image_heatmap_coolwarm
 *                              <li> gpudb::visualize_image_heatmap_copper
 *                              <li> gpudb::visualize_image_heatmap_cubehelix
 *                              <li> gpudb::visualize_image_heatmap_dark2
 *                              <li> gpudb::visualize_image_heatmap_flag
 *                              <li> gpudb::visualize_image_heatmap_gist_earth
 *                              <li> gpudb::visualize_image_heatmap_gist_gray
 *                              <li> gpudb::visualize_image_heatmap_gist_heat
 *                              <li> gpudb::visualize_image_heatmap_gist_ncar
 *                              <li>
 *                      gpudb::visualize_image_heatmap_gist_rainbow
 *                              <li> gpudb::visualize_image_heatmap_gist_stern
 *                              <li> gpudb::visualize_image_heatmap_gist_yarg
 *                              <li> gpudb::visualize_image_heatmap_gnbu
 *                              <li> gpudb::visualize_image_heatmap_gnuplot2
 *                              <li> gpudb::visualize_image_heatmap_gnuplot
 *                              <li> gpudb::visualize_image_heatmap_gray
 *                              <li> gpudb::visualize_image_heatmap_greens
 *                              <li> gpudb::visualize_image_heatmap_greys
 *                              <li> gpudb::visualize_image_heatmap_hot
 *                              <li> gpudb::visualize_image_heatmap_hsv
 *                              <li> gpudb::visualize_image_heatmap_inferno
 *                              <li> gpudb::visualize_image_heatmap_magma
 *                              <li>
 *                      gpudb::visualize_image_heatmap_nipy_spectral
 *                              <li> gpudb::visualize_image_heatmap_ocean
 *                              <li> gpudb::visualize_image_heatmap_oranges
 *                              <li> gpudb::visualize_image_heatmap_orrd
 *                              <li> gpudb::visualize_image_heatmap_paired
 *                              <li> gpudb::visualize_image_heatmap_pastel1
 *                              <li> gpudb::visualize_image_heatmap_pastel2
 *                              <li> gpudb::visualize_image_heatmap_pink
 *                              <li> gpudb::visualize_image_heatmap_piyg
 *                              <li> gpudb::visualize_image_heatmap_plasma
 *                              <li> gpudb::visualize_image_heatmap_prgn
 *                              <li> gpudb::visualize_image_heatmap_prism
 *                              <li> gpudb::visualize_image_heatmap_pubu
 *                              <li> gpudb::visualize_image_heatmap_pubugn
 *                              <li> gpudb::visualize_image_heatmap_puor
 *                              <li> gpudb::visualize_image_heatmap_purd
 *                              <li> gpudb::visualize_image_heatmap_purples
 *                              <li> gpudb::visualize_image_heatmap_rainbow
 *                              <li> gpudb::visualize_image_heatmap_rdbu
 *                              <li> gpudb::visualize_image_heatmap_rdgy
 *                              <li> gpudb::visualize_image_heatmap_rdpu
 *                              <li> gpudb::visualize_image_heatmap_rdylbu
 *                              <li> gpudb::visualize_image_heatmap_rdylgn
 *                              <li> gpudb::visualize_image_heatmap_reds
 *                              <li> gpudb::visualize_image_heatmap_seismic
 *                              <li> gpudb::visualize_image_heatmap_set1
 *                              <li> gpudb::visualize_image_heatmap_set2
 *                              <li> gpudb::visualize_image_heatmap_set3
 *                              <li> gpudb::visualize_image_heatmap_spectral
 *                              <li> gpudb::visualize_image_heatmap_spring
 *                              <li> gpudb::visualize_image_heatmap_summer
 *                              <li> gpudb::visualize_image_heatmap_terrain
 *                              <li> gpudb::visualize_image_heatmap_viridis
 *                              <li> gpudb::visualize_image_heatmap_winter
 *                              <li> gpudb::visualize_image_heatmap_wistia
 *                              <li> gpudb::visualize_image_heatmap_ylgn
 *                              <li> gpudb::visualize_image_heatmap_ylgnbu
 *                              <li> gpudb::visualize_image_heatmap_ylorbr
 *                              <li> gpudb::visualize_image_heatmap_ylorrd
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_heatmap_jet.
 *                              <li>
 *                      gpudb::visualize_image_heatmap_blur_radius:   The
 *                      default value is '5'.
 *                              <li> gpudb::visualize_image_heatmap_bg_color
 *                              <li>
 *                      gpudb::visualize_image_heatmap_gradient_start_color:
 *                      The default value is 'FFFFFF'.
 *                              <li>
 *                      gpudb::visualize_image_heatmap_gradient_end_color:
 *                      The default value is 'FF0000'.
 *                      </ul>
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageHeatmapResponse& visualizeImageHeatmap( const std::vector<std::string>& tableNames,
                                                      const std::string& xColumnName,
                                                      const std::string& yColumnName,
                                                      const std::string& valueColumnName,
                                                      const std::string& geometryColumnName,
                                                      const double minX,
                                                      const double maxX,
                                                      const double minY,
                                                      const double maxY,
                                                      const int32_t width,
                                                      const int32_t height,
                                                      const std::string& projection,
                                                      const std::map<std::string, std::string>& styleOptions,
                                                      const std::map<std::string, std::string>& options,
                                                      VisualizeImageHeatmapResponse& response_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageLabelsResponse visualizeImageLabels( const VisualizeImageLabelsRequest& request_ ) const;

/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageLabelsResponse& visualizeImageLabels( const VisualizeImageLabelsRequest& request_,
                                                    VisualizeImageLabelsResponse& response_ ) const;

/**
 * @private
 * 
 * @param tableName
 * @param xColumnName
 * @param yColumnName
 * @param xOffset
 * @param yOffset
 * @param textString
 * @param font
 * @param textColor
 * @param textAngle
 * @param textScale
 * @param drawBox
 * @param drawLeader
 * @param lineWidth
 * @param lineColor
 * @param fillColor
 * @param leaderXColumnName
 * @param leaderYColumnName
 * @param filter
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_labels_EPSG_4326
 *                            <li> gpudb::visualize_image_labels_PLATE_CARREE
 *                            <li> gpudb::visualize_image_labels_900913
 *                            <li> gpudb::visualize_image_labels_EPSG_900913
 *                            <li> gpudb::visualize_image_labels_102100
 *                            <li> gpudb::visualize_image_labels_EPSG_102100
 *                            <li> gpudb::visualize_image_labels_3857
 *                            <li> gpudb::visualize_image_labels_EPSG_3857
 *                            <li> gpudb::visualize_image_labels_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_labels_PLATE_CARREE.
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageLabelsResponse visualizeImageLabels( const std::string& tableName,
                                                   const std::string& xColumnName,
                                                   const std::string& yColumnName,
                                                   const std::string& xOffset,
                                                   const std::string& yOffset,
                                                   const std::string& textString,
                                                   const std::string& font,
                                                   const std::string& textColor,
                                                   const std::string& textAngle,
                                                   const std::string& textScale,
                                                   const std::string& drawBox,
                                                   const std::string& drawLeader,
                                                   const std::string& lineWidth,
                                                   const std::string& lineColor,
                                                   const std::string& fillColor,
                                                   const std::string& leaderXColumnName,
                                                   const std::string& leaderYColumnName,
                                                   const std::string& filter,
                                                   const double minX,
                                                   const double maxX,
                                                   const double minY,
                                                   const double maxY,
                                                   const int32_t width,
                                                   const int32_t height,
                                                   const std::string& projection,
                                                   const std::map<std::string, std::string>& options ) const;

/**
 * @private
 * 
 * @param tableName
 * @param xColumnName
 * @param yColumnName
 * @param xOffset
 * @param yOffset
 * @param textString
 * @param font
 * @param textColor
 * @param textAngle
 * @param textScale
 * @param drawBox
 * @param drawLeader
 * @param lineWidth
 * @param lineColor
 * @param fillColor
 * @param leaderXColumnName
 * @param leaderYColumnName
 * @param filter
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_labels_EPSG_4326
 *                            <li> gpudb::visualize_image_labels_PLATE_CARREE
 *                            <li> gpudb::visualize_image_labels_900913
 *                            <li> gpudb::visualize_image_labels_EPSG_900913
 *                            <li> gpudb::visualize_image_labels_102100
 *                            <li> gpudb::visualize_image_labels_EPSG_102100
 *                            <li> gpudb::visualize_image_labels_3857
 *                            <li> gpudb::visualize_image_labels_EPSG_3857
 *                            <li> gpudb::visualize_image_labels_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_labels_PLATE_CARREE.
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageLabelsResponse& visualizeImageLabels( const std::string& tableName,
                                                    const std::string& xColumnName,
                                                    const std::string& yColumnName,
                                                    const std::string& xOffset,
                                                    const std::string& yOffset,
                                                    const std::string& textString,
                                                    const std::string& font,
                                                    const std::string& textColor,
                                                    const std::string& textAngle,
                                                    const std::string& textScale,
                                                    const std::string& drawBox,
                                                    const std::string& drawLeader,
                                                    const std::string& lineWidth,
                                                    const std::string& lineColor,
                                                    const std::string& fillColor,
                                                    const std::string& leaderXColumnName,
                                                    const std::string& leaderYColumnName,
                                                    const std::string& filter,
                                                    const double minX,
                                                    const double maxX,
                                                    const double minY,
                                                    const double maxY,
                                                    const int32_t width,
                                                    const int32_t height,
                                                    const std::string& projection,
                                                    const std::map<std::string, std::string>& options,
                                                    VisualizeImageLabelsResponse& response_ ) const;

/**
 * Generate an image containing isolines for travel results using an
 * existing graph. Isolines represent curves of equal cost, with cost typically
 * referring to the time or distance assigned as the weights of the underlying
 * graph. See
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * for more information on graphs.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeIsochroneResponse visualizeIsochrone( const VisualizeIsochroneRequest& request_ ) const;

/**
 * Generate an image containing isolines for travel results using an
 * existing graph. Isolines represent curves of equal cost, with cost typically
 * referring to the time or distance assigned as the weights of the underlying
 * graph. See
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * for more information on graphs.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeIsochroneResponse& visualizeIsochrone( const VisualizeIsochroneRequest& request_,
                                                VisualizeIsochroneResponse& response_ ) const;

/**
 * Generate an image containing isolines for travel results using an
 * existing graph. Isolines represent curves of equal cost, with cost typically
 * referring to the time or distance assigned as the weights of the underlying
 * graph. See
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * for more information on graphs.
 * 
 * @param graphName  Name of the graph on which the isochrone is to be
 *                   computed.
 * @param sourceNode  Starting vertex on the underlying graph from/to which the
 *                    isochrones are created.
 * @param maxSolutionRadius  Extent of the search radius around @a sourceNode.
 *                           Set to '-1.0' for unrestricted search radius.
 * @param weightsOnEdges  Additional weights to apply to the edges of an
 *                        existing graph. Weights must be specified using <a
 *                        href="../../../graph_solver/network_graph_solver/#identifiers"
 *                        target="_top">identifiers</a>; identifiers are
 *                        grouped as <a
 *                        href="../../../graph_solver/network_graph_solver/#id-combos"
 *                        target="_top">combinations</a>. Identifiers can be
 *                        used with existing column names, e.g., 'table.column
 *                        AS WEIGHTS_EDGE_ID', or expressions, e.g.,
 *                        'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED'. Any
 *                        provided weights will be added (in the case of
 *                        'WEIGHTS_VALUESPECIFIED') to or multiplied with (in
 *                        the case of 'WEIGHTS_FACTORSPECIFIED') the existing
 *                        weight(s).
 * @param restrictions  Additional restrictions to apply to the nodes/edges of
 *                      an existing graph. Restrictions must be specified using
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../../graph_solver/network_graph_solver/#id-combos"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with existing column names, e.g., 'table.column AS
 *                      RESTRICTIONS_EDGE_ID', or expressions, e.g., 'column/2
 *                      AS RESTRICTIONS_VALUECOMPARED'. If @a
 *                      remove_previous_restrictions is set to @a true, any
 *                      provided restrictions will replace the existing
 *                      restrictions. If @a remove_previous_restrictions is set
 *                      to @a false, any provided restrictions will be added
 *                      (in the case of 'RESTRICTIONS_VALUECOMPARED') to or
 *                      replaced (in the case of 'RESTRICTIONS_ONOFFCOMPARED').
 * @param numLevels  Number of equally-separated isochrones to compute.
 * @param generateImage  If set to @a true, generates a PNG image of the
 *                       isochrones in the response.
 *                       <ul>
 *                               <li> gpudb::visualize_isochrone_true
 *                               <li> gpudb::visualize_isochrone_false
 *                       </ul>
 *                       The default value is gpudb::visualize_isochrone_true.
 * @param levelsTable  Name of the table to output the isochrones to, in
 *                     [schema_name.]table_name format, using standard <a
 *                     href="../../../concepts/tables/#table-name-resolution"
 *                     target="_top">name resolution rules</a> and meeting <a
 *                     href="../../../concepts/tables/#table-naming-criteria"
 *                     target="_top">table naming criteria</a>.  The table will
 *                     contain levels and their corresponding WKT geometry. If
 *                     no value is provided, the table is not generated.
 * @param styleOptions  Various style related options of the isochrone image.
 *                      <ul>
 *                              <li> gpudb::visualize_isochrone_line_size: The
 *                      width of the contour lines in pixels.  The default
 *                      value is '3'.
 *                              <li> gpudb::visualize_isochrone_color: Color of
 *                      generated isolines. All color values must be in the
 *                      format RRGGBB or AARRGGBB (to specify the alpha value).
 *                      If alpha is specified and flooded contours are enabled,
 *                      it will be used for as the transparency of the latter.
 *                      The default value is 'FF696969'.
 *                              <li> gpudb::visualize_isochrone_bg_color: When
 *                      @a generateImage is set to @a true, background color of
 *                      the generated image. All color values must be in the
 *                      format RRGGBB or AARRGGBB (to specify the alpha value).
 *                      The default value is '00000000'.
 *                              <li> gpudb::visualize_isochrone_text_color:
 *                      When @a add_labels is set to @a true, color for the
 *                      labels. All color values must be in the format RRGGBB
 *                      or AARRGGBB (to specify the alpha value).  The default
 *                      value is 'FF000000'.
 *                              <li> gpudb::visualize_isochrone_colormap:
 *                      Colormap for contours or fill-in regions when
 *                      applicable. All color values must be in the format
 *                      RRGGBB or AARRGGBB (to specify the alpha value)
 *                      <ul>
 *                              <li> gpudb::visualize_isochrone_jet
 *                              <li> gpudb::visualize_isochrone_accent
 *                              <li> gpudb::visualize_isochrone_afmhot
 *                              <li> gpudb::visualize_isochrone_autumn
 *                              <li> gpudb::visualize_isochrone_binary
 *                              <li> gpudb::visualize_isochrone_blues
 *                              <li> gpudb::visualize_isochrone_bone
 *                              <li> gpudb::visualize_isochrone_brbg
 *                              <li> gpudb::visualize_isochrone_brg
 *                              <li> gpudb::visualize_isochrone_bugn
 *                              <li> gpudb::visualize_isochrone_bupu
 *                              <li> gpudb::visualize_isochrone_bwr
 *                              <li> gpudb::visualize_isochrone_cmrmap
 *                              <li> gpudb::visualize_isochrone_cool
 *                              <li> gpudb::visualize_isochrone_coolwarm
 *                              <li> gpudb::visualize_isochrone_copper
 *                              <li> gpudb::visualize_isochrone_cubehelix
 *                              <li> gpudb::visualize_isochrone_dark2
 *                              <li> gpudb::visualize_isochrone_flag
 *                              <li> gpudb::visualize_isochrone_gist_earth
 *                              <li> gpudb::visualize_isochrone_gist_gray
 *                              <li> gpudb::visualize_isochrone_gist_heat
 *                              <li> gpudb::visualize_isochrone_gist_ncar
 *                              <li> gpudb::visualize_isochrone_gist_rainbow
 *                              <li> gpudb::visualize_isochrone_gist_stern
 *                              <li> gpudb::visualize_isochrone_gist_yarg
 *                              <li> gpudb::visualize_isochrone_gnbu
 *                              <li> gpudb::visualize_isochrone_gnuplot2
 *                              <li> gpudb::visualize_isochrone_gnuplot
 *                              <li> gpudb::visualize_isochrone_gray
 *                              <li> gpudb::visualize_isochrone_greens
 *                              <li> gpudb::visualize_isochrone_greys
 *                              <li> gpudb::visualize_isochrone_hot
 *                              <li> gpudb::visualize_isochrone_hsv
 *                              <li> gpudb::visualize_isochrone_inferno
 *                              <li> gpudb::visualize_isochrone_magma
 *                              <li> gpudb::visualize_isochrone_nipy_spectral
 *                              <li> gpudb::visualize_isochrone_ocean
 *                              <li> gpudb::visualize_isochrone_oranges
 *                              <li> gpudb::visualize_isochrone_orrd
 *                              <li> gpudb::visualize_isochrone_paired
 *                              <li> gpudb::visualize_isochrone_pastel1
 *                              <li> gpudb::visualize_isochrone_pastel2
 *                              <li> gpudb::visualize_isochrone_pink
 *                              <li> gpudb::visualize_isochrone_piyg
 *                              <li> gpudb::visualize_isochrone_plasma
 *                              <li> gpudb::visualize_isochrone_prgn
 *                              <li> gpudb::visualize_isochrone_prism
 *                              <li> gpudb::visualize_isochrone_pubu
 *                              <li> gpudb::visualize_isochrone_pubugn
 *                              <li> gpudb::visualize_isochrone_puor
 *                              <li> gpudb::visualize_isochrone_purd
 *                              <li> gpudb::visualize_isochrone_purples
 *                              <li> gpudb::visualize_isochrone_rainbow
 *                              <li> gpudb::visualize_isochrone_rdbu
 *                              <li> gpudb::visualize_isochrone_rdgy
 *                              <li> gpudb::visualize_isochrone_rdpu
 *                              <li> gpudb::visualize_isochrone_rdylbu
 *                              <li> gpudb::visualize_isochrone_rdylgn
 *                              <li> gpudb::visualize_isochrone_reds
 *                              <li> gpudb::visualize_isochrone_seismic
 *                              <li> gpudb::visualize_isochrone_set1
 *                              <li> gpudb::visualize_isochrone_set2
 *                              <li> gpudb::visualize_isochrone_set3
 *                              <li> gpudb::visualize_isochrone_spectral
 *                              <li> gpudb::visualize_isochrone_spring
 *                              <li> gpudb::visualize_isochrone_summer
 *                              <li> gpudb::visualize_isochrone_terrain
 *                              <li> gpudb::visualize_isochrone_viridis
 *                              <li> gpudb::visualize_isochrone_winter
 *                              <li> gpudb::visualize_isochrone_wistia
 *                              <li> gpudb::visualize_isochrone_ylgn
 *                              <li> gpudb::visualize_isochrone_ylgnbu
 *                              <li> gpudb::visualize_isochrone_ylorbr
 *                              <li> gpudb::visualize_isochrone_ylorrd
 *                      </ul>
 *                      The default value is gpudb::visualize_isochrone_jet.
 *                      </ul>
 * @param solveOptions  Solver specific parameters
 *                      <ul>
 *                              <li>
 *                      gpudb::visualize_isochrone_remove_previous_restrictions:
 *                      Ignore the restrictions applied to the graph during the
 *                      creation stage and only use the restrictions specified
 *                      in this request if set to @a true.
 *                      <ul>
 *                              <li> gpudb::visualize_isochrone_true
 *                              <li> gpudb::visualize_isochrone_false
 *                      </ul>
 *                      The default value is gpudb::visualize_isochrone_false.
 *                              <li>
 *                      gpudb::visualize_isochrone_restriction_threshold_value:
 *                      Value-based restriction comparison. Any node or edge
 *                      with a 'RESTRICTIONS_VALUECOMPARED' value greater than
 *                      the @a restriction_threshold_value will not be included
 *                      in the solution.
 *                              <li>
 *                      gpudb::visualize_isochrone_uniform_weights: When
 *                      specified, assigns the given value to all the edges in
 *                      the graph. Note that weights provided in @a
 *                      weightsOnEdges will override this value.
 *                      </ul>
 * @param contourOptions  Solver specific parameters
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_projection:
 *                        Spatial Reference System (i.e. EPSG Code).
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_3857
 *                                <li> gpudb::visualize_isochrone_102100
 *                                <li> gpudb::visualize_isochrone_900913
 *                                <li> gpudb::visualize_isochrone_EPSG_4326
 *                                <li> gpudb::visualize_isochrone_PLATE_CARREE
 *                                <li> gpudb::visualize_isochrone_EPSG_900913
 *                                <li> gpudb::visualize_isochrone_EPSG_102100
 *                                <li> gpudb::visualize_isochrone_EPSG_3857
 *                                <li> gpudb::visualize_isochrone_WEB_MERCATOR
 *                        </ul>
 *                        The default value is
 *                        gpudb::visualize_isochrone_PLATE_CARREE.
 *                                <li> gpudb::visualize_isochrone_width: When
 *                        @a generateImage is set to @a true, width of the
 *                        generated image.  The default value is '512'.
 *                                <li> gpudb::visualize_isochrone_height: When
 *                        @a generateImage is set to @a true, height of the
 *                        generated image. If the default value is used, the @a
 *                        height is set to the value resulting from multiplying
 *                        the aspect ratio by the @a width.  The default value
 *                        is '-1'.
 *                                <li>
 *                        gpudb::visualize_isochrone_search_radius: When
 *                        interpolating the graph solution to generate the
 *                        isochrone, neighborhood of influence of sample data
 *                        (in percent of the image/grid).  The default value is
 *                        '20'.
 *                                <li> gpudb::visualize_isochrone_grid_size:
 *                        When interpolating the graph solution to generate the
 *                        isochrone, number of subdivisions along the x axis
 *                        when building the grid (the y is computed using the
 *                        aspect ratio of the output image).  The default value
 *                        is '100'.
 *                                <li>
 *                        gpudb::visualize_isochrone_color_isolines: Color each
 *                        isoline according to the colormap; otherwise, use the
 *                        foreground color.
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_true
 *                                <li> gpudb::visualize_isochrone_false
 *                        </ul>
 *                        The default value is gpudb::visualize_isochrone_true.
 *                                <li> gpudb::visualize_isochrone_add_labels:
 *                        If set to @a true, add labels to the isolines.
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_true
 *                                <li> gpudb::visualize_isochrone_false
 *                        </ul>
 *                        The default value is
 *                        gpudb::visualize_isochrone_false.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_font_size: When @a
 *                        add_labels is set to @a true, size of the font (in
 *                        pixels) to use for labels.  The default value is
 *                        '12'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_font_family: When
 *                        @a add_labels is set to @a true, font name to be used
 *                        when adding labels.  The default value is 'arial'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_search_window: When
 *                        @a add_labels is set to @a true, a search window is
 *                        used to rate the local quality of each isoline.
 *                        Smooth, continuous, long stretches with relatively
 *                        flat angles are favored. The provided value is
 *                        multiplied by the @a labels_font_size to calculate
 *                        the final window size.  The default value is '4'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_intralevel_separation:
 *                        When @a add_labels is set to @a true, this value
 *                        determines the  distance (in multiples of the @a
 *                        labels_font_size) to use when separating labels of
 *                        different values.  The default value is '4'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_interlevel_separation:
 *                        When @a add_labels is set to @a true, this value
 *                        determines the distance (in percent of the total
 *                        window size) to use when separating labels of the
 *                        same value.  The default value is '20'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_max_angle: When @a
 *                        add_labels is set to @a true, maximum angle (in
 *                        degrees) from the vertical to use when adding labels.
 *                        The default value is '60'.
 *                        </ul>
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_solve_table: Name of
 *                 the table to host intermediate solve results, in
 *                 [schema_name.]table_name format, using standard <a
 *                 href="../../../concepts/tables/#table-name-resolution"
 *                 target="_top">name resolution rules</a> and meeting <a
 *                 href="../../../concepts/tables/#table-naming-criteria"
 *                 target="_top">table naming criteria</a>.  This table will
 *                 contain the position and cost for each vertex in the graph.
 *                 If the default value is used, a temporary table is created
 *                 and deleted once the solution is calculated.  The default
 *                 value is ''.
 *                         <li> gpudb::visualize_isochrone_is_replicated: If
 *                 set to @a true, replicate the @a solve_table.
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_true
 *                         <li> gpudb::visualize_isochrone_false
 *                 </ul>
 *                 The default value is gpudb::visualize_isochrone_true.
 *                         <li> gpudb::visualize_isochrone_data_min_x: Lower
 *                 bound for the x values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_data_max_x: Upper
 *                 bound for the x values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_data_min_y: Lower
 *                 bound for the y values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_data_max_y: Upper
 *                 bound for the y values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_concavity_level:
 *                 Factor to qualify the concavity of the isochrone curves. The
 *                 lower the value, the more convex (with '0' being completely
 *                 convex and '1' being the most concave).  The default value
 *                 is '0.5'.
 *                         <li>
 *                 gpudb::visualize_isochrone_use_priority_queue_solvers: sets
 *                 the solver methods explicitly if true
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_true: uses the
 *                 solvers scheduled for 'shortest_path' and
 *                 'inverse_shortest_path' based on solve_direction
 *                         <li> gpudb::visualize_isochrone_false: uses the
 *                 solvers 'priority_queue' and 'inverse_priority_queue' based
 *                 on solve_direction
 *                 </ul>
 *                 The default value is gpudb::visualize_isochrone_false.
 *                         <li> gpudb::visualize_isochrone_solve_direction:
 *                 Specify whether we are going to the source node, or starting
 *                 from it.
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_from_source:
 *                 Shortest path to get to the source (inverse Dijkstra)
 *                         <li> gpudb::visualize_isochrone_to_source: Shortest
 *                 path to source (Dijkstra)
 *                 </ul>
 *                 The default value is gpudb::visualize_isochrone_from_source.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeIsochroneResponse visualizeIsochrone( const std::string& graphName,
                                               const std::string& sourceNode,
                                               const double maxSolutionRadius,
                                               const std::vector<std::string>& weightsOnEdges,
                                               const std::vector<std::string>& restrictions,
                                               const int32_t numLevels,
                                               const bool generateImage,
                                               const std::string& levelsTable,
                                               const std::map<std::string, std::string>& styleOptions,
                                               const std::map<std::string, std::string>& solveOptions,
                                               const std::map<std::string, std::string>& contourOptions,
                                               const std::map<std::string, std::string>& options ) const;

/**
 * Generate an image containing isolines for travel results using an
 * existing graph. Isolines represent curves of equal cost, with cost typically
 * referring to the time or distance assigned as the weights of the underlying
 * graph. See
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * for more information on graphs.
 * 
 * @param graphName  Name of the graph on which the isochrone is to be
 *                   computed.
 * @param sourceNode  Starting vertex on the underlying graph from/to which the
 *                    isochrones are created.
 * @param maxSolutionRadius  Extent of the search radius around @a sourceNode.
 *                           Set to '-1.0' for unrestricted search radius.
 * @param weightsOnEdges  Additional weights to apply to the edges of an
 *                        existing graph. Weights must be specified using <a
 *                        href="../../../graph_solver/network_graph_solver/#identifiers"
 *                        target="_top">identifiers</a>; identifiers are
 *                        grouped as <a
 *                        href="../../../graph_solver/network_graph_solver/#id-combos"
 *                        target="_top">combinations</a>. Identifiers can be
 *                        used with existing column names, e.g., 'table.column
 *                        AS WEIGHTS_EDGE_ID', or expressions, e.g.,
 *                        'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED'. Any
 *                        provided weights will be added (in the case of
 *                        'WEIGHTS_VALUESPECIFIED') to or multiplied with (in
 *                        the case of 'WEIGHTS_FACTORSPECIFIED') the existing
 *                        weight(s).
 * @param restrictions  Additional restrictions to apply to the nodes/edges of
 *                      an existing graph. Restrictions must be specified using
 *                      <a
 *                      href="../../../graph_solver/network_graph_solver/#identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../../graph_solver/network_graph_solver/#id-combos"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with existing column names, e.g., 'table.column AS
 *                      RESTRICTIONS_EDGE_ID', or expressions, e.g., 'column/2
 *                      AS RESTRICTIONS_VALUECOMPARED'. If @a
 *                      remove_previous_restrictions is set to @a true, any
 *                      provided restrictions will replace the existing
 *                      restrictions. If @a remove_previous_restrictions is set
 *                      to @a false, any provided restrictions will be added
 *                      (in the case of 'RESTRICTIONS_VALUECOMPARED') to or
 *                      replaced (in the case of 'RESTRICTIONS_ONOFFCOMPARED').
 * @param numLevels  Number of equally-separated isochrones to compute.
 * @param generateImage  If set to @a true, generates a PNG image of the
 *                       isochrones in the response.
 *                       <ul>
 *                               <li> gpudb::visualize_isochrone_true
 *                               <li> gpudb::visualize_isochrone_false
 *                       </ul>
 *                       The default value is gpudb::visualize_isochrone_true.
 * @param levelsTable  Name of the table to output the isochrones to, in
 *                     [schema_name.]table_name format, using standard <a
 *                     href="../../../concepts/tables/#table-name-resolution"
 *                     target="_top">name resolution rules</a> and meeting <a
 *                     href="../../../concepts/tables/#table-naming-criteria"
 *                     target="_top">table naming criteria</a>.  The table will
 *                     contain levels and their corresponding WKT geometry. If
 *                     no value is provided, the table is not generated.
 * @param styleOptions  Various style related options of the isochrone image.
 *                      <ul>
 *                              <li> gpudb::visualize_isochrone_line_size: The
 *                      width of the contour lines in pixels.  The default
 *                      value is '3'.
 *                              <li> gpudb::visualize_isochrone_color: Color of
 *                      generated isolines. All color values must be in the
 *                      format RRGGBB or AARRGGBB (to specify the alpha value).
 *                      If alpha is specified and flooded contours are enabled,
 *                      it will be used for as the transparency of the latter.
 *                      The default value is 'FF696969'.
 *                              <li> gpudb::visualize_isochrone_bg_color: When
 *                      @a generateImage is set to @a true, background color of
 *                      the generated image. All color values must be in the
 *                      format RRGGBB or AARRGGBB (to specify the alpha value).
 *                      The default value is '00000000'.
 *                              <li> gpudb::visualize_isochrone_text_color:
 *                      When @a add_labels is set to @a true, color for the
 *                      labels. All color values must be in the format RRGGBB
 *                      or AARRGGBB (to specify the alpha value).  The default
 *                      value is 'FF000000'.
 *                              <li> gpudb::visualize_isochrone_colormap:
 *                      Colormap for contours or fill-in regions when
 *                      applicable. All color values must be in the format
 *                      RRGGBB or AARRGGBB (to specify the alpha value)
 *                      <ul>
 *                              <li> gpudb::visualize_isochrone_jet
 *                              <li> gpudb::visualize_isochrone_accent
 *                              <li> gpudb::visualize_isochrone_afmhot
 *                              <li> gpudb::visualize_isochrone_autumn
 *                              <li> gpudb::visualize_isochrone_binary
 *                              <li> gpudb::visualize_isochrone_blues
 *                              <li> gpudb::visualize_isochrone_bone
 *                              <li> gpudb::visualize_isochrone_brbg
 *                              <li> gpudb::visualize_isochrone_brg
 *                              <li> gpudb::visualize_isochrone_bugn
 *                              <li> gpudb::visualize_isochrone_bupu
 *                              <li> gpudb::visualize_isochrone_bwr
 *                              <li> gpudb::visualize_isochrone_cmrmap
 *                              <li> gpudb::visualize_isochrone_cool
 *                              <li> gpudb::visualize_isochrone_coolwarm
 *                              <li> gpudb::visualize_isochrone_copper
 *                              <li> gpudb::visualize_isochrone_cubehelix
 *                              <li> gpudb::visualize_isochrone_dark2
 *                              <li> gpudb::visualize_isochrone_flag
 *                              <li> gpudb::visualize_isochrone_gist_earth
 *                              <li> gpudb::visualize_isochrone_gist_gray
 *                              <li> gpudb::visualize_isochrone_gist_heat
 *                              <li> gpudb::visualize_isochrone_gist_ncar
 *                              <li> gpudb::visualize_isochrone_gist_rainbow
 *                              <li> gpudb::visualize_isochrone_gist_stern
 *                              <li> gpudb::visualize_isochrone_gist_yarg
 *                              <li> gpudb::visualize_isochrone_gnbu
 *                              <li> gpudb::visualize_isochrone_gnuplot2
 *                              <li> gpudb::visualize_isochrone_gnuplot
 *                              <li> gpudb::visualize_isochrone_gray
 *                              <li> gpudb::visualize_isochrone_greens
 *                              <li> gpudb::visualize_isochrone_greys
 *                              <li> gpudb::visualize_isochrone_hot
 *                              <li> gpudb::visualize_isochrone_hsv
 *                              <li> gpudb::visualize_isochrone_inferno
 *                              <li> gpudb::visualize_isochrone_magma
 *                              <li> gpudb::visualize_isochrone_nipy_spectral
 *                              <li> gpudb::visualize_isochrone_ocean
 *                              <li> gpudb::visualize_isochrone_oranges
 *                              <li> gpudb::visualize_isochrone_orrd
 *                              <li> gpudb::visualize_isochrone_paired
 *                              <li> gpudb::visualize_isochrone_pastel1
 *                              <li> gpudb::visualize_isochrone_pastel2
 *                              <li> gpudb::visualize_isochrone_pink
 *                              <li> gpudb::visualize_isochrone_piyg
 *                              <li> gpudb::visualize_isochrone_plasma
 *                              <li> gpudb::visualize_isochrone_prgn
 *                              <li> gpudb::visualize_isochrone_prism
 *                              <li> gpudb::visualize_isochrone_pubu
 *                              <li> gpudb::visualize_isochrone_pubugn
 *                              <li> gpudb::visualize_isochrone_puor
 *                              <li> gpudb::visualize_isochrone_purd
 *                              <li> gpudb::visualize_isochrone_purples
 *                              <li> gpudb::visualize_isochrone_rainbow
 *                              <li> gpudb::visualize_isochrone_rdbu
 *                              <li> gpudb::visualize_isochrone_rdgy
 *                              <li> gpudb::visualize_isochrone_rdpu
 *                              <li> gpudb::visualize_isochrone_rdylbu
 *                              <li> gpudb::visualize_isochrone_rdylgn
 *                              <li> gpudb::visualize_isochrone_reds
 *                              <li> gpudb::visualize_isochrone_seismic
 *                              <li> gpudb::visualize_isochrone_set1
 *                              <li> gpudb::visualize_isochrone_set2
 *                              <li> gpudb::visualize_isochrone_set3
 *                              <li> gpudb::visualize_isochrone_spectral
 *                              <li> gpudb::visualize_isochrone_spring
 *                              <li> gpudb::visualize_isochrone_summer
 *                              <li> gpudb::visualize_isochrone_terrain
 *                              <li> gpudb::visualize_isochrone_viridis
 *                              <li> gpudb::visualize_isochrone_winter
 *                              <li> gpudb::visualize_isochrone_wistia
 *                              <li> gpudb::visualize_isochrone_ylgn
 *                              <li> gpudb::visualize_isochrone_ylgnbu
 *                              <li> gpudb::visualize_isochrone_ylorbr
 *                              <li> gpudb::visualize_isochrone_ylorrd
 *                      </ul>
 *                      The default value is gpudb::visualize_isochrone_jet.
 *                      </ul>
 * @param solveOptions  Solver specific parameters
 *                      <ul>
 *                              <li>
 *                      gpudb::visualize_isochrone_remove_previous_restrictions:
 *                      Ignore the restrictions applied to the graph during the
 *                      creation stage and only use the restrictions specified
 *                      in this request if set to @a true.
 *                      <ul>
 *                              <li> gpudb::visualize_isochrone_true
 *                              <li> gpudb::visualize_isochrone_false
 *                      </ul>
 *                      The default value is gpudb::visualize_isochrone_false.
 *                              <li>
 *                      gpudb::visualize_isochrone_restriction_threshold_value:
 *                      Value-based restriction comparison. Any node or edge
 *                      with a 'RESTRICTIONS_VALUECOMPARED' value greater than
 *                      the @a restriction_threshold_value will not be included
 *                      in the solution.
 *                              <li>
 *                      gpudb::visualize_isochrone_uniform_weights: When
 *                      specified, assigns the given value to all the edges in
 *                      the graph. Note that weights provided in @a
 *                      weightsOnEdges will override this value.
 *                      </ul>
 * @param contourOptions  Solver specific parameters
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_projection:
 *                        Spatial Reference System (i.e. EPSG Code).
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_3857
 *                                <li> gpudb::visualize_isochrone_102100
 *                                <li> gpudb::visualize_isochrone_900913
 *                                <li> gpudb::visualize_isochrone_EPSG_4326
 *                                <li> gpudb::visualize_isochrone_PLATE_CARREE
 *                                <li> gpudb::visualize_isochrone_EPSG_900913
 *                                <li> gpudb::visualize_isochrone_EPSG_102100
 *                                <li> gpudb::visualize_isochrone_EPSG_3857
 *                                <li> gpudb::visualize_isochrone_WEB_MERCATOR
 *                        </ul>
 *                        The default value is
 *                        gpudb::visualize_isochrone_PLATE_CARREE.
 *                                <li> gpudb::visualize_isochrone_width: When
 *                        @a generateImage is set to @a true, width of the
 *                        generated image.  The default value is '512'.
 *                                <li> gpudb::visualize_isochrone_height: When
 *                        @a generateImage is set to @a true, height of the
 *                        generated image. If the default value is used, the @a
 *                        height is set to the value resulting from multiplying
 *                        the aspect ratio by the @a width.  The default value
 *                        is '-1'.
 *                                <li>
 *                        gpudb::visualize_isochrone_search_radius: When
 *                        interpolating the graph solution to generate the
 *                        isochrone, neighborhood of influence of sample data
 *                        (in percent of the image/grid).  The default value is
 *                        '20'.
 *                                <li> gpudb::visualize_isochrone_grid_size:
 *                        When interpolating the graph solution to generate the
 *                        isochrone, number of subdivisions along the x axis
 *                        when building the grid (the y is computed using the
 *                        aspect ratio of the output image).  The default value
 *                        is '100'.
 *                                <li>
 *                        gpudb::visualize_isochrone_color_isolines: Color each
 *                        isoline according to the colormap; otherwise, use the
 *                        foreground color.
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_true
 *                                <li> gpudb::visualize_isochrone_false
 *                        </ul>
 *                        The default value is gpudb::visualize_isochrone_true.
 *                                <li> gpudb::visualize_isochrone_add_labels:
 *                        If set to @a true, add labels to the isolines.
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_true
 *                                <li> gpudb::visualize_isochrone_false
 *                        </ul>
 *                        The default value is
 *                        gpudb::visualize_isochrone_false.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_font_size: When @a
 *                        add_labels is set to @a true, size of the font (in
 *                        pixels) to use for labels.  The default value is
 *                        '12'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_font_family: When
 *                        @a add_labels is set to @a true, font name to be used
 *                        when adding labels.  The default value is 'arial'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_search_window: When
 *                        @a add_labels is set to @a true, a search window is
 *                        used to rate the local quality of each isoline.
 *                        Smooth, continuous, long stretches with relatively
 *                        flat angles are favored. The provided value is
 *                        multiplied by the @a labels_font_size to calculate
 *                        the final window size.  The default value is '4'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_intralevel_separation:
 *                        When @a add_labels is set to @a true, this value
 *                        determines the  distance (in multiples of the @a
 *                        labels_font_size) to use when separating labels of
 *                        different values.  The default value is '4'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_interlevel_separation:
 *                        When @a add_labels is set to @a true, this value
 *                        determines the distance (in percent of the total
 *                        window size) to use when separating labels of the
 *                        same value.  The default value is '20'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_max_angle: When @a
 *                        add_labels is set to @a true, maximum angle (in
 *                        degrees) from the vertical to use when adding labels.
 *                        The default value is '60'.
 *                        </ul>
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_solve_table: Name of
 *                 the table to host intermediate solve results, in
 *                 [schema_name.]table_name format, using standard <a
 *                 href="../../../concepts/tables/#table-name-resolution"
 *                 target="_top">name resolution rules</a> and meeting <a
 *                 href="../../../concepts/tables/#table-naming-criteria"
 *                 target="_top">table naming criteria</a>.  This table will
 *                 contain the position and cost for each vertex in the graph.
 *                 If the default value is used, a temporary table is created
 *                 and deleted once the solution is calculated.  The default
 *                 value is ''.
 *                         <li> gpudb::visualize_isochrone_is_replicated: If
 *                 set to @a true, replicate the @a solve_table.
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_true
 *                         <li> gpudb::visualize_isochrone_false
 *                 </ul>
 *                 The default value is gpudb::visualize_isochrone_true.
 *                         <li> gpudb::visualize_isochrone_data_min_x: Lower
 *                 bound for the x values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_data_max_x: Upper
 *                 bound for the x values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_data_min_y: Lower
 *                 bound for the y values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_data_max_y: Upper
 *                 bound for the y values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_concavity_level:
 *                 Factor to qualify the concavity of the isochrone curves. The
 *                 lower the value, the more convex (with '0' being completely
 *                 convex and '1' being the most concave).  The default value
 *                 is '0.5'.
 *                         <li>
 *                 gpudb::visualize_isochrone_use_priority_queue_solvers: sets
 *                 the solver methods explicitly if true
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_true: uses the
 *                 solvers scheduled for 'shortest_path' and
 *                 'inverse_shortest_path' based on solve_direction
 *                         <li> gpudb::visualize_isochrone_false: uses the
 *                 solvers 'priority_queue' and 'inverse_priority_queue' based
 *                 on solve_direction
 *                 </ul>
 *                 The default value is gpudb::visualize_isochrone_false.
 *                         <li> gpudb::visualize_isochrone_solve_direction:
 *                 Specify whether we are going to the source node, or starting
 *                 from it.
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_from_source:
 *                 Shortest path to get to the source (inverse Dijkstra)
 *                         <li> gpudb::visualize_isochrone_to_source: Shortest
 *                 path to source (Dijkstra)
 *                 </ul>
 *                 The default value is gpudb::visualize_isochrone_from_source.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeIsochroneResponse& visualizeIsochrone( const std::string& graphName,
                                                const std::string& sourceNode,
                                                const double maxSolutionRadius,
                                                const std::vector<std::string>& weightsOnEdges,
                                                const std::vector<std::string>& restrictions,
                                                const int32_t numLevels,
                                                const bool generateImage,
                                                const std::string& levelsTable,
                                                const std::map<std::string, std::string>& styleOptions,
                                                const std::map<std::string, std::string>& solveOptions,
                                                const std::map<std::string, std::string>& contourOptions,
                                                const std::map<std::string, std::string>& options,
                                                VisualizeIsochroneResponse& response_ ) const;
